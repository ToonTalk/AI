<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Fireworks Demo</title>
<style>
    /* Make the canvas cover the whole page */
    body, html {margin:0; height:100%; overflow:hidden;}
    canvas {display:block;}

    /* Simple control panel for interactivity */
    #controls {
        position:fixed;
        top:10px;
        left:10px;
        z-index: 10;
        color:#fff;
        font-family:sans-serif;
        background:rgba(0,0,0,.3);
        padding:8px 12px;
        border-radius:4px;
    }
    #controls label{margin-right:15px;}
    #controls input[type=range]{
        vertical-align:middle;
        width:100px;
    }
</style>
</head>
<body>

<div id="controls">
    <label>Gravity:
        <input type="range" id="gravitySlider" min="0.05" max="0.5" step="0.01" value="0.15">
    </label>
    <label>Particles per firework:
        <input type="number" id="particlesInput" min="10" max="200" step="10" value="80">
    </label>
</div>

<canvas id="c"></canvas>

<script>
/* =======================
   Fireworks simulation
   ======================= */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

// Resize canvas to fill the window
function resizeCanvas() {
    canvas.width  = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// Global parameters (can be changed via UI)
let gravity      = parseFloat(document.getElementById('gravitySlider').value);   // pixels per frame²
let particlesPerFirework = parseInt(document.getElementById('particlesInput').value);

// UI event listeners
document.getElementById('gravitySlider')
    .addEventListener('input', e => gravity = parseFloat(e.target.value));

document.getElementById('particlesInput')
    .addEventListener('change', e => particlesPerFirework = parseInt(e.target.value));

// Array that holds every active particle
const particles = [];

// ---------- Utility functions ----------
function randomBetween(min, max) {
    return min + Math.random() * (max - min);
}

function hslColor(hue) {
    // Return a vibrant HSL color string
    return `hsl(${hue}, 80%, 60%)`;
}

// ---------- Particle class ----------
class Particle {
    constructor(x, y, vx, vy, hue, life = 100) {
        this.x     = x;
        this.y     = y;
        this.vx    = vx;          // velocity in x
        this.vy    = vy;          // velocity in y
        this.hue   = hue;         // color hue (0-360)
        this.life  = life;        // remaining life ticks
        this.alpha = 1.0;         // opacity (fades to 0)
    }

    update() {
        // Apply gravity
        this.vy += gravity;

        // Update position
        this.x += this.vx;
        this.y += this.vy;

        // Fade out over time
        this.life--;
        this.alpha = Math.max(this.life / 100, 0);
    }

    draw(ctx) {
        ctx.globalAlpha = this.alpha;
        ctx.fillStyle   = hslColor(this.hue);
        ctx.beginPath();
        ctx.arc(this.x, this.y, 2.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1; // reset alpha for other drawings
    }
}

// ---------- Firework launcher ----------
function launchFirework(x, y) {
    const hueBase = randomBetween(0, 360);

    for (let i = 0; i < particlesPerFirework; i++) {
        // Emit in a circle with some spread
        const angle   = Math.random() * Math.PI * 2;
        const speed   = randomBetween(1.5, 4);
        const vx      = Math.cos(angle) * speed;
        const vy      = Math.sin(angle) * speed;

        // Slightly vary the hue per particle for a rainbow effect
        const hue     = (hueBase + i * 2) % 360;

        particles.push(new Particle(x, y, vx, vy, hue));
    }
}

// ---------- Mouse interactivity ----------
let mouseDown = false;
canvas.addEventListener('mousedown', e => {
    mouseDown = true;
    launchFirework(e.clientX, e.clientY);
});
canvas.addEventListener('mousemove', e => {
    if (mouseDown) launchFirework(e.clientX, e.clientY);
});
canvas.addEventListener('mouseup',   () => mouseDown = false);

// ---------- Animation loop ----------
function animate() {
    requestAnimationFrame(animate);

    // Draw a translucent rectangle over the whole canvas.
    // This creates the “after‑image” trail effect – old frames fade gradually.
    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Update & draw particles
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.update();
        if (p.life <= 0) {           // remove dead particles
            particles.splice(i, 1);
            continue;
        }
        p.draw(ctx);
    }
}

animate();   // kick off the loop
</script>
</body>
</html>
