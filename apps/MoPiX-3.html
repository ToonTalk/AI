<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MoPiX 3</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .app-container {
            max-width: 1600px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 250px 1fr 300px;
            gap: 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 20px;
        }

        .sidebar {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            overflow-y: auto;
            max-height: calc(100vh - 80px);
        }

        .sidebar h3 {
            color: #333;
            font-size: 16px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }

        .main-content {
            display: flex;
            flex-direction: column;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 28px;
        }

        .subtitle {
            color: #666;
            margin-bottom: 15px;
            font-size: 14px;
        }

        canvas {
            border: 2px solid #333;
            display: block;
            margin: 15px auto;
            border-radius: 8px;
            background: white;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            cursor: crosshair;
        }

        canvas.dragging {
            cursor: move;
        }

        .controls {
            display: flex;
            gap: 8px;
            align-items: center;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 20px;
            font-size: 14px;
            cursor: pointer;
            border-radius: 6px;
            border: none;
            background: #667eea;
            color: white;
            font-weight: 600;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        button:hover:not(:disabled) {
            background: #5568d3;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        button.secondary { background: #6c757d; box-shadow: 0 2px 8px rgba(108, 117, 125, 0.3); }
        button.secondary:hover:not(:disabled) { background: #5a6268; }
        button.play { background: #28a745; box-shadow: 0 2px 8px rgba(40, 167, 69, 0.3); }
        button.play:hover { background: #218838; }
        button.pause { background: #dc3545; box-shadow: 0 2px 8px rgba(220, 53, 69, 0.3); }
        button.pause:hover { background: #c82333; }
        button.danger { background: #dc3545; box-shadow: 0 2px 8px rgba(220, 53, 69, 0.3); }
        button.danger:hover:not(:disabled) { background: #c82333; }
        button.success { background: #28a745; box-shadow: 0 2px 8px rgba(40, 167, 69, 0.3); }
        button.success:hover { background: #218838; }
        button.warning { background: #ffc107; color: #333; box-shadow: 0 2px 8px rgba(255, 193, 7, 0.3); }
        button.warning:hover { background: #e0a800; }

        .frame-control, .speed-control {
            display: flex;
            align-items: center;
            gap: 8px;
            background: #f8f9fa;
            padding: 8px 12px;
            border-radius: 6px;
        }

        .frame-control label, .speed-control label {
            font-weight: 600;
            color: #333;
            font-size: 14px;
        }

        .frame-control input[type="number"] {
            padding: 6px 10px;
            font-size: 14px;
            width: 80px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }

        .frame-control input[type="range"], .speed-control input[type="range"] {
            width: 150px;
        }

        .speed-control span {
            font-weight: 600;
            color: #856404;
            min-width: 50px;
            font-size: 14px;
        }

        /* Object List Sidebar */
        .object-list {
            list-style: none;
        }

        .object-item {
            padding: 10px;
            margin: 5px 0;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .object-item:hover {
            background: #e7f3ff;
            border-color: #667eea;
        }

        .object-item.selected {
            background: #667eea;
            color: white;
            border-color: #5568d3;
        }

        .object-name {
            font-weight: 600;
            font-size: 14px;
        }

        .object-type {
            font-size: 12px;
            opacity: 0.8;
            margin-top: 3px;
        }

        /* Property Panel */
        .property-panel {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
        }

        .property-panel.empty {
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-style: italic;
            min-height: 200px;
        }

        .property-group {
            margin-bottom: 20px;
        }

        .property-group h4 {
            color: #333;
            font-size: 14px;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid #ddd;
        }

        .property-row {
            margin: 12px 0;
        }

        .property-row label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: #555;
            margin-bottom: 5px;
        }

        .property-row input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }

        .property-row input[type="number"] {
            width: 100%;
            padding: 6px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
        }

        .property-row input[type="color"] {
            width: 100%;
            height: 40px;
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
        }

        .property-row .value-display {
            display: inline-block;
            min-width: 50px;
            text-align: right;
            font-weight: 600;
            color: #667eea;
            font-size: 14px;
        }

        .property-buttons {
            display: flex;
            gap: 8px;
            margin-top: 15px;
        }

        .property-buttons button {
            flex: 1;
            font-size: 12px;
            padding: 8px;
        }

        /* History Controls */
        .history-controls {
            display: flex;
            gap: 8px;
            margin: 10px 0;
        }

        .history-info {
            font-size: 12px;
            color: #666;
            padding: 8px 12px;
            background: #f8f9fa;
            border-radius: 4px;
            flex-grow: 1;
            text-align: center;
        }

        .stats-compact {
            background: #fff3cd;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #ffc107;
            margin-top: 15px;
        }

        .stats-compact h4 {
            margin: 0 0 10px 0;
            color: #856404;
            font-size: 14px;
        }

        .stats-compact ul {
            margin-left: 20px;
            font-size: 12px;
        }

        .stats-compact li {
            margin: 5px 0;
            color: #856404;
        }

        .stats-compact kbd {
            background: #856404;
            color: white;
            padding: 2px 5px;
            border-radius: 3px;
            font-family: monospace;
            font-weight: bold;
            font-size: 11px;
        }

        .grid-snap-indicator {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #28a745;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.4);
            display: none;
            z-index: 1000;
        }

        .grid-snap-indicator.active {
            display: block;
        }

        @media (max-width: 1400px) {
            .app-container {
                grid-template-columns: 1fr;
                gap: 15px;
            }

            .sidebar {
                max-height: 300px;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Left Sidebar: Variables & Objects -->
        <div class="sidebar">
            <h3>üî¢ Variables</h3>
            <div id="variablesList" style="margin-bottom: 15px;"></div>
            <div style="display: flex; gap: 5px; margin-bottom: 20px;">
                <input type="text" id="varName" placeholder="name" style="width: 80px; padding: 6px; border: 1px solid #ccc; border-radius: 4px; font-size: 12px;" />
                <input type="number" id="varValue" placeholder="value" style="width: 80px; padding: 6px; border: 1px solid #ccc; border-radius: 4px; font-size: 12px;" />
                <button onclick="addVariable()" style="padding: 6px 10px; font-size: 12px; flex-shrink: 0;">+</button>
            </div>

            <h3>üì¶ Objects</h3>
            <div style="margin-bottom: 10px; display: flex; flex-direction: column; gap: 5px;">
                <button class="success" onclick="toggleCreateForm()" style="width: 100%; font-size: 12px;">‚ûï Create New</button>
                <button class="danger" onclick="clearAllObjects()" style="width: 100%; font-size: 12px;">üóëÔ∏è Clear All</button>
            </div>
            <ul id="objectList" class="object-list"></ul>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <h1>MoPiX 3 - Programming with Algebra</h1>
            <p class="subtitle">Full-featured visual programming using algebraic statements</p>

            <!-- Error Message Display -->
            <div id="errorMessage" style="display: none; background: #ffebee; border: 2px solid #f44336; color: #c62828; padding: 12px; border-radius: 6px; margin-bottom: 15px; font-weight: 600;">
                <span id="errorText"></span>
                <button onclick="document.getElementById('errorMessage').style.display='none'" style="float: right; background: none; border: none; color: #c62828; font-size: 18px; cursor: pointer; padding: 0 8px;">√ó</button>
            </div>

            <!-- Sample Model Info Display -->
            <div id="modelInfoMessage" style="display: none; background: #e3f2fd; border: 2px solid #2196f3; color: #0d47a1; padding: 12px; border-radius: 6px; margin-bottom: 15px;">
                <strong id="modelInfoTitle"></strong>
                <p id="modelInfoText" style="margin: 5px 0 0 0;"></p>
                <button onclick="document.getElementById('modelInfoMessage').style.display='none'" style="float: right; background: none; border: none; color: #0d47a1; font-size: 18px; cursor: pointer; padding: 0 8px; margin-top: -30px;">√ó</button>
            </div>

            <canvas id="canvas" width="800" height="600"></canvas>

            <div class="controls">
                <button class="secondary" onclick="resetAnimation()">‚èÆ Reset</button>
                <button class="secondary" onclick="stepBackward()">‚è™ Back</button>
                <button id="playButton" class="play" onclick="togglePlay()">‚ñ∂ Play</button>
                <button class="secondary" onclick="stepForward()">Forward ‚è©</button>

                <div class="frame-control">
                    <label for="frameInput">Frame:</label>
                    <input type="number" id="frameInput" value="0" min="0" max="1000" onchange="setFrame(this.value)">
                    <input type="range" id="frameSlider" value="0" min="0" max="200" oninput="setFrame(this.value)">
                </div>

                <div class="speed-control">
                    <label for="speedSlider">Speed:</label>
                    <input type="range" id="speedSlider" min="1" max="60" value="30" oninput="updateSpeed(this.value)">
                    <span id="speedDisplay">30 fps</span>
                </div>
            </div>

            <div class="controls">
                <div class="history-controls">
                    <button class="secondary" onclick="undo()" id="undoButton" disabled title="Ctrl+Z">‚Ü∂ Undo</button>
                    <button class="secondary" onclick="redo()" id="redoButton" disabled title="Ctrl+Y">‚Ü∑ Redo</button>
                    <div class="history-info" id="historyInfo">History: 0 / 0</div>
                </div>
            </div>

            <div class="controls">
                <button class="success" onclick="saveToLocalStorage()">üíæ Save</button>
                <button class="secondary" onclick="loadFromLocalStorage()">üìÇ Load</button>
                <button class="secondary" onclick="exportToFile()">üì• Export</button>
                <button class="secondary" onclick="importFromFile()">üì§ Import</button>
                <button class="warning" onclick="clearAllTrails()">üßπ Clear Trails</button>
                <input type="file" id="fileInput" accept=".json" style="display: none;" onchange="handleFileImport(event)">
            </div>

            <div class="stats-compact">
                <h4>‚å®Ô∏è Keyboard Shortcuts & Features</h4>
                <div style="margin-bottom: 10px;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="keyboardShortcutsToggle" onchange="toggleKeyboardShortcuts(this.checked)" style="cursor: pointer;">
                        <span>Enable Keyboard Shortcuts (disabled by default to avoid conflicts with equation-based keyboard controls)</span>
                    </label>
                </div>
                <ul>
                    <li><kbd>Space</kbd> Play/Pause | <kbd>‚Üê/‚Üí</kbd> Step (or nudge object) | <kbd>Home</kbd> Reset</li>
                    <li><kbd>‚Üë‚Üì‚Üê‚Üí</kbd> Nudge object 1px (<kbd>Shift</kbd> for 10px) | <kbd>[</kbd> Send back | <kbd>]</kbd> Bring front</li>
                    <li><kbd>Delete</kbd> Delete object | <kbd>P</kbd> Toggle pen | <kbd>C</kbd> Copy object</li>
                    <li><kbd>Ctrl+Z</kbd> Undo | <kbd>Ctrl+Y</kbd> Redo | <kbd>Shift+Drag</kbd> Snap to grid (always active)</li>
                    <li><strong>üî¢ Variables:</strong> Define custom variables (speed, radius, etc.) - use in equations!</li>
                    <li><strong>üìê Equations:</strong> 12 shapes, collision detection, conditionals, and 30+ functions!</li>
                </ul>
            </div>
        </div>

        <!-- Right Sidebar: Property Inspector -->
        <div class="sidebar">
            <div style="margin-bottom: 20px;">
                <button class="success" onclick="showSampleModels()" style="width: 100%; font-size: 12px; padding: 10px;">
                    üìö Load Sample Model
                </button>
            </div>

            <h3>‚öôÔ∏è Properties</h3>
            <div id="propertyPanel" class="property-panel empty">
                Select an object to edit properties
            </div>
        </div>
    </div>

    <!-- Grid Snap Indicator -->
    <div id="gridSnapIndicator" class="grid-snap-indicator">
        üìê Grid Snap: ON
    </div>

    <!-- Hidden Create Form -->
    <div id="createObjectForm" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 12px; box-shadow: 0 10px 40px rgba(0,0,0,0.3); z-index: 2000; min-width: 400px;">
        <h3 style="margin-top: 0;">Create New Object</h3>
        <div style="margin: 15px 0;">
            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Name:</label>
            <input type="text" id="newObjectName" value="MyObject" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;" />
        </div>
        <div style="margin: 15px 0;">
            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Shape:</label>
            <select id="newObjectShape" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
                <option value="square">Square</option>
                <option value="circle">Circle</option>
                <option value="triangle">Triangle</option>
                <option value="star">Star (5-pointed)</option>
                <option value="pentagon">Pentagon</option>
                <option value="hexagon">Hexagon</option>
                <option value="roundrect">Rounded Rectangle</option>
                <option value="arrow">Arrow</option>
                <option value="text">Text/Label</option>
            </select>
        </div>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 15px 0;">
            <div>
                <label style="display: block; margin-bottom: 5px; font-weight: 600;">X:</label>
                <input type="number" id="newObjectX" value="400" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;" />
            </div>
            <div>
                <label style="display: block; margin-bottom: 5px; font-weight: 600;">Y:</label>
                <input type="number" id="newObjectY" value="300" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;" />
            </div>
        </div>
        <div style="margin: 15px 0;">
            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Size:</label>
            <input type="number" id="newObjectSize" value="60" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;" />
        </div>
        <div style="margin: 15px 0;">
            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Text (for text shape):</label>
            <input type="text" id="newObjectText" value="Hello" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;" />
        </div>
        <div style="display: flex; gap: 10px; margin-top: 20px;">
            <button class="success" onclick="createObject()" style="flex: 1;">Create</button>
            <button class="secondary" onclick="toggleCreateForm()" style="flex: 1;">Cancel</button>
        </div>
    </div>

    <!-- Equation Editor Modal -->
    <div id="equationEditorModal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 12px; box-shadow: 0 10px 40px rgba(0,0,0,0.3); z-index: 2000; min-width: 500px; max-width: 600px; max-height: 80vh; overflow-y: auto;">
        <h3 style="margin-top: 0; color: #667eea;">üìê Equation Editor</h3>

        <div style="margin: 15px 0;">
            <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #333;">Property:</label>
            <select id="equationProperty" style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 14px;">
                <option value="x">X Position</option>
                <option value="y">Y Position</option>
                <option value="width">Width</option>
                <option value="height">Height</option>
                <option value="rotation">Rotation</option>
                <option value="red">Red (0-255)</option>
                <option value="green">Green (0-255)</option>
                <option value="blue">Blue (0-255)</option>
                <option value="opacity">Opacity (0-100)</option>
                <option value="thicknessPen">Pen Thickness</option>
                <option value="redColourPen">Pen Red (0-255)</option>
                <option value="greenColourPen">Pen Green (0-255)</option>
                <option value="blueColourPen">Pen Blue (0-255)</option>
                <option value="opacityPen">Pen Opacity (0-100)</option>
            </select>
        </div>

        <div style="margin: 15px 0;">
            <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #333;">Equation:</label>
            <textarea id="equationInput" placeholder="e.g., sin(t * 10) * 100 + 300" style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-family: 'Courier New', monospace; font-size: 14px; min-height: 60px; resize: vertical;" oninput="validateEquation()" rows="3"></textarea>
            <div id="equationError" style="color: #dc3545; margin-top: 5px; font-size: 12px; display: none;"></div>
            <div id="equationSuccess" style="color: #28a745; margin-top: 5px; font-size: 12px; display: none;">‚úì Valid equation</div>
        </div>

        <div style="margin: 15px 0;">
            <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #333;">Description (optional):</label>
            <textarea id="equationDescription" placeholder="e.g., Makes the object bounce vertically" style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 14px; min-height: 40px; resize: vertical;" rows="2"></textarea>
        </div>

        <div style="margin: 15px 0;">
            <div style="display: flex; gap: 10px; margin-top: 10px;">
                <button class="success" onclick="saveEquation()" style="flex: 1;" id="saveEquationBtn">üíæ Save</button>
                <button class="secondary" onclick="closeEquationEditor()" style="flex: 1;">Cancel</button>
            </div>
        </div>

        <div style="background: #f8f9fa; padding: 15px; border-radius: 6px; margin: 15px 0; border: 1px solid #dee2e6;">
            <h4 style="margin: 0 0 10px 0; color: #667eea; font-size: 14px;">üìö Examples:</h4>
            <div style="display: grid; gap: 8px;">
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('t * 2 + 100')">
                    <strong>Linear motion:</strong> t * 2 + 100
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('sin(t * 10) * 100 + 300')">
                    <strong>Sine wave:</strong> sin(t * 10) * 100 + 300
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('bouncer.x + 50')">
                    <strong>Follow object:</strong> bouncer.x + 50
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('dist(bouncer.x, bouncer.y, mover.x, mover.y)')">
                    <strong>Distance:</strong> dist(bouncer.x, bouncer.y, mover.x, mover.y)
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('angle(bouncer.x, bouncer.y, mover.x, mover.y)')">
                    <strong>Point at object:</strong> angle(bouncer.x, bouncer.y, mover.x, mover.y)
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('128 + sin(t * 6) * 127')">
                    <strong>Color pulse:</strong> 128 + sin(t * 6) * 127
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('if(t > 50, bouncer.x, mover.x)')">
                    <strong>Conditional:</strong> if(t > 50, bouncer.x, mover.x)
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('clamp(bouncer.x, 100, 700)')">
                    <strong>Clamp value:</strong> clamp(bouncer.x, 100, 700)
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('lerp(100, 700, sin(t * 5) / 2 + 0.5)')">
                    <strong>Interpolate:</strong> lerp(100, 700, sin(t * 5) / 2 + 0.5)
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('t * speed + 100')">
                    <strong>Use variable:</strong> t * speed + 100
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('if(overlaps(mover, bouncer), 255, 100)')">
                    <strong>Collision:</strong> if(overlaps(mover, bouncer), 255, 100)
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('centerX + cos(t * 5) * radius')">
                    <strong>Orbit:</strong> centerX + cos(t * 5) * radius
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('random(50, 750)')">
                    <strong>Random position:</strong> random(50, 750)
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('200 + sin(t * pi / 30) * 100')">
                    <strong>Use pi constant:</strong> 200 + sin(t * pi / 30) * 100
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('pow(2, t / 10) + 100')">
                    <strong>Exponential growth:</strong> pow(2, t / 10) + 100
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('mod(t * 10, 400) + 100')">
                    <strong>Repeating pattern:</strong> mod(t * 10, 400) + 100
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('atan2(bouncer.y - mover.y, bouncer.x - mover.x)')">
                    <strong>Point from A to B:</strong> atan2(bouncer.y - mover.y, bouncer.x - mover.x)
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('100 + smoothstep(0, 100, t) * 400')">
                    <strong>Smooth easing:</strong> 100 + smoothstep(0, 100, t) * 400
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('300 + bounce(t / 50) * 200')">
                    <strong>Bounce effect:</strong> 300 + bounce(t / 50) * 200
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('wrap(t * 5, 100, 700)')">
                    <strong>Wrapping motion:</strong> wrap(t * 5, 100, 700)
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('mouse.x')">
                    <strong>Follow mouse X:</strong> mouse.x
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('mouse.y')">
                    <strong>Follow mouse Y:</strong> mouse.y
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('400 + keyDown(d) * 150 - keyDown(a) * 150')">
                    <strong>Keyboard control:</strong> 400 + keyDown(d) * 150 - keyDown(a) * 150
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('if(keyDown(space), 255, 100)')">
                    <strong>Key pressed color:</strong> if(keyDown(space), 255, 100)
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('prev.x + 2')">
                    <strong>Previous value (t-1):</strong> prev.x + 2
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('prev.y + prev.vy')">
                    <strong>Physics velocity:</strong> prev.y + prev.vy
                </div>
                <div style="cursor: pointer; padding: 8px; background: white; border-radius: 4px; border: 1px solid #dee2e6; font-size: 12px; font-family: 'Courier New', monospace;" onclick="setEquationExample('prev.bouncer.x + 10')">
                    <strong>Track another object:</strong> prev.bouncer.x + 10
                </div>
            </div>
        </div>

        <div style="background: #e7f3ff; padding: 12px; border-radius: 6px; margin: 15px 0; border: 1px solid #b3d7ff;">
            <h4 style="margin: 0 0 8px 0; color: #004085; font-size: 13px;">üí° Available:</h4>
            <div style="font-size: 12px; color: #004085; line-height: 1.6;">
                <strong>Variables:</strong> t (time), <em>user variables</em> (define in sidebar), <em><span title="Reference another object's property by name, e.g., Ball.x or Paddle.y">object name.property</span></em><br>
                <strong>Constants:</strong> <span title="3.14159265...">pi</span>, <span title="2.71828182... (Euler's number)">e</span><br>
                <strong>Properties:</strong> x, y, width, height, rotation, red, green, blue, thicknessPen, redColourPen, greenColourPen, blueColourPen, opacityPen, <em>custom properties</em><br>
                <strong>Input:</strong> <span title="Current mouse X coordinate">mouse.x</span>, <span title="Current mouse Y coordinate">mouse.y</span>, <span title="Returns 1 if key is pressed, 0 otherwise. Example: keyDown(w)">keyDown(key)</span><br>
                <strong>Previous Frame (t-1):</strong> <span title="Access this object's property from the previous frame">prev.x</span>, <span title="Access another object's property from the previous frame">prev.object name.property</span><br>
                <strong>Operators:</strong> + - * / ^ (power), <, >, <=, >=, ==, !=<br>
                <strong>Math:</strong> <span title="Sine function (input in radians)">sin</span>, <span title="Cosine function (input in radians)">cos</span>, <span title="Tangent function (input in radians)">tan</span>, <span title="Absolute value">abs</span>, <span title="Square root">sqrt</span>, <span title="Natural logarithm (base e)">ln</span>, <span title="Logarithm base 10">log</span>, <span title="e raised to the power (e^x)">exp</span>, <span title="Round down to nearest integer">floor</span>, <span title="Round up to nearest integer">ceil</span>, <span title="Round to nearest integer">round</span>, <span title="Returns -1, 0, or 1 based on sign">sign</span>, <span title="Fractional part (value - floor(value))">fract</span><br>
                <strong>Logic:</strong> <span title="Conditional: if condition is true, return 2nd arg, else return 3rd arg">if(cond, true, false)</span>, <span title="Logical AND (returns 1 if both true)">and</span>, <span title="Logical OR (returns 1 if either true)">or</span>, <span title="Logical NOT (returns 1 if false, 0 if true)">not</span><br>
                <strong>Collision:</strong> <span title="Returns 1 if two objects are overlapping, 0 otherwise">overlaps(obj1, obj2)</span><br>
                <strong>Multi-arg:</strong> <span title="Distance between two points: dist(x1, y1, x2, y2)">dist</span>, <span title="Angle in radians: angle(x1, y1, x2, y2)">angle</span>, <span title="Minimum of values">min</span>, <span title="Maximum of values">max</span>, <span title="Constrain value between min and max">clamp</span>, <span title="Linear interpolation: lerp(a, b, t)">lerp</span>, <span title="Random value: random() [0-1], random(max), random(min, max)">random</span>, <span title="Modulo (remainder after division)">mod</span>, <span title="Power: pow(base, exponent)">pow</span>, <span title="Arctangent of y/x in radians: atan2(y, x)">atan2</span><br>
                <strong>Easing:</strong> <span title="Smooth Hermite interpolation between edge0 and edge1">smoothstep(edge0, edge1, x)</span>, <span title="Returns 0 if x < edge, else 1">step(edge, x)</span>, <span title="Power-based easing (x clamped to 0-1)">ease(x, power)</span>, <span title="Bouncing easing function (input normalized to 0-1)">bounce(t)</span>, <span title="Wraps value to range [min, max)">wrap(val, min, max)</span>
            </div>
        </div>
    </div>

    <!-- Emoji Picker Modal -->
    <div id="emojiPickerModal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 12px; box-shadow: 0 10px 40px rgba(0,0,0,0.3); z-index: 2000; min-width: 500px; max-width: 600px;">
        <h3 style="margin-top: 0; color: #667eea;">üòÄ Emoji Picker</h3>
        <p style="color: #666; margin-bottom: 15px;">Click an emoji to insert it into your text:</p>

        <div style="max-height: 400px; overflow-y: auto; border: 1px solid #dee2e6; border-radius: 6px; padding: 15px; background: #f8f9fa;">
            <div style="margin-bottom: 15px;">
                <h4 style="margin: 0 0 8px 0; font-size: 13px; color: #555;">üòä Smileys & Emotion</h4>
                <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                    <button onclick="insertEmoji('üòÄ')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Grinning">üòÄ</button>
                    <button onclick="insertEmoji('üòÉ')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Grinning with big eyes">üòÉ</button>
                    <button onclick="insertEmoji('üòÑ')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Grinning with smiling eyes">üòÑ</button>
                    <button onclick="insertEmoji('üòÅ')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Beaming">üòÅ</button>
                    <button onclick="insertEmoji('üòä')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Smiling">üòä</button>
                    <button onclick="insertEmoji('üòç')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Heart eyes">üòç</button>
                    <button onclick="insertEmoji('ü§©')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Star-struck">ü§©</button>
                    <button onclick="insertEmoji('üòé')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Sunglasses">üòé</button>
                    <button onclick="insertEmoji('ü§î')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Thinking">ü§î</button>
                    <button onclick="insertEmoji('üòÆ')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Surprised">üòÆ</button>
                    <button onclick="insertEmoji('üò¢')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Crying">üò¢</button>
                    <button onclick="insertEmoji('üò≠')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Loudly crying">üò≠</button>
                </div>
            </div>
            <div style="margin-bottom: 15px;">
                <h4 style="margin: 0 0 8px 0; font-size: 13px; color: #555;">‚ù§Ô∏è Hearts & Symbols</h4>
                <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                    <button onclick="insertEmoji('‚ù§Ô∏è')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Red heart">‚ù§Ô∏è</button>
                    <button onclick="insertEmoji('üíô')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Blue heart">üíô</button>
                    <button onclick="insertEmoji('üíö')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Green heart">üíö</button>
                    <button onclick="insertEmoji('üíõ')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Yellow heart">üíõ</button>
                    <button onclick="insertEmoji('üß°')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Orange heart">üß°</button>
                    <button onclick="insertEmoji('üíú')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Purple heart">üíú</button>
                    <button onclick="insertEmoji('‚≠ê')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Star">‚≠ê</button>
                    <button onclick="insertEmoji('‚ú®')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Sparkles">‚ú®</button>
                    <button onclick="insertEmoji('üî•')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Fire">üî•</button>
                    <button onclick="insertEmoji('üíØ')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="100">üíØ</button>
                    <button onclick="insertEmoji('‚úÖ')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Check">‚úÖ</button>
                    <button onclick="insertEmoji('üéâ')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Party">üéâ</button>
                </div>
            </div>
            <div style="margin-bottom: 15px;">
                <h4 style="margin: 0 0 8px 0; font-size: 13px; color: #555;">üê∂ Animals & Nature</h4>
                <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                    <button onclick="insertEmoji('üê∂')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Dog">üê∂</button>
                    <button onclick="insertEmoji('üê±')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Cat">üê±</button>
                    <button onclick="insertEmoji('üê≠')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Mouse">üê≠</button>
                    <button onclick="insertEmoji('üê∞')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Rabbit">üê∞</button>
                    <button onclick="insertEmoji('ü¶ä')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Fox">ü¶ä</button>
                    <button onclick="insertEmoji('üêª')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Bear">üêª</button>
                    <button onclick="insertEmoji('üêº')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Panda">üêº</button>
                    <button onclick="insertEmoji('üê®')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Koala">üê®</button>
                    <button onclick="insertEmoji('ü¶Å')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Lion">ü¶Å</button>
                    <button onclick="insertEmoji('üêØ')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Tiger">üêØ</button>
                    <button onclick="insertEmoji('ü¶Ñ')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Unicorn">ü¶Ñ</button>
                    <button onclick="insertEmoji('üåà')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Rainbow">üåà</button>
                </div>
            </div>
            <div style="margin-bottom: 15px;">
                <h4 style="margin: 0 0 8px 0; font-size: 13px; color: #555;">üçï Food & Drink</h4>
                <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                    <button onclick="insertEmoji('üçï')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Pizza">üçï</button>
                    <button onclick="insertEmoji('üçî')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Burger">üçî</button>
                    <button onclick="insertEmoji('üçü')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Fries">üçü</button>
                    <button onclick="insertEmoji('üåÆ')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Taco">üåÆ</button>
                    <button onclick="insertEmoji('üç∞')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Cake">üç∞</button>
                    <button onclick="insertEmoji('üçé')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Apple">üçé</button>
                    <button onclick="insertEmoji('üçå')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Banana">üçå</button>
                    <button onclick="insertEmoji('üçì')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Strawberry">üçì</button>
                    <button onclick="insertEmoji('‚òï')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Coffee">‚òï</button>
                    <button onclick="insertEmoji('üçµ')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Tea">üçµ</button>
                    <button onclick="insertEmoji('ü•§')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Drink">ü•§</button>
                    <button onclick="insertEmoji('üç¶')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Ice cream">üç¶</button>
                </div>
            </div>
            <div style="margin-bottom: 15px;">
                <h4 style="margin: 0 0 8px 0; font-size: 13px; color: #555;">‚öΩ Sports & Activities</h4>
                <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                    <button onclick="insertEmoji('‚öΩ')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Soccer">‚öΩ</button>
                    <button onclick="insertEmoji('üèÄ')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Basketball">üèÄ</button>
                    <button onclick="insertEmoji('üèà')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Football">üèà</button>
                    <button onclick="insertEmoji('‚öæ')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Baseball">‚öæ</button>
                    <button onclick="insertEmoji('üéÆ')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Video game">üéÆ</button>
                    <button onclick="insertEmoji('üéØ')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Dart">üéØ</button>
                    <button onclick="insertEmoji('üé≤')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Dice">üé≤</button>
                    <button onclick="insertEmoji('üé∏')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Guitar">üé∏</button>
                    <button onclick="insertEmoji('üé®')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Art">üé®</button>
                    <button onclick="insertEmoji('üìö')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Books">üìö</button>
                    <button onclick="insertEmoji('‚úàÔ∏è')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Airplane">‚úàÔ∏è</button>
                    <button onclick="insertEmoji('üöÄ')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Rocket">üöÄ</button>
                </div>
            </div>
            <div>
                <h4 style="margin: 0 0 8px 0; font-size: 13px; color: #555;">üåç Travel & Places</h4>
                <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                    <button onclick="insertEmoji('üåç')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Earth">üåç</button>
                    <button onclick="insertEmoji('üè†')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Home">üè†</button>
                    <button onclick="insertEmoji('üè¢')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Office">üè¢</button>
                    <button onclick="insertEmoji('üè´')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="School">üè´</button>
                    <button onclick="insertEmoji('üè∞')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Castle">üè∞</button>
                    <button onclick="insertEmoji('üóΩ')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Statue of Liberty">üóΩ</button>
                    <button onclick="insertEmoji('üå≥')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Tree">üå≥</button>
                    <button onclick="insertEmoji('üå∫')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Flower">üå∫</button>
                    <button onclick="insertEmoji('‚òÄÔ∏è')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Sun">‚òÄÔ∏è</button>
                    <button onclick="insertEmoji('üåô')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Moon">üåô</button>
                    <button onclick="insertEmoji('‚õÖ')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Cloud">‚õÖ</button>
                    <button onclick="insertEmoji('‚õàÔ∏è')" style="font-size: 24px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer;" title="Storm">‚õàÔ∏è</button>
                </div>
            </div>
        </div>

        <div style="margin-top: 20px;">
            <button class="secondary" onclick="closeEmojiPicker()" style="width: 100%;">Close</button>
        </div>
    </div>

    <!-- Sample Models Dialog -->
    <div id="sampleModelsDialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 12px; box-shadow: 0 10px 40px rgba(0,0,0,0.3); z-index: 2000; min-width: 600px; max-width: 700px; max-height: 80vh; overflow-y: auto;">
        <h3 style="margin-top: 0; color: #667eea;">üìö Sample Models</h3>
        <p style="color: #666; margin-bottom: 20px;">Choose a sample model to load. These are recreations of the original MoPiX examples.</p>

        <div id="sampleModelsList" style="display: flex; flex-direction: column; gap: 15px;">
            <!-- Sample models will be populated here -->
        </div>

        <div style="margin-top: 20px;">
            <button class="secondary" onclick="closeSampleModels()" style="width: 100%;">Cancel</button>
        </div>
    </div>

    <script>
        // ==================== Expression Engine ====================

        class Expression {
            evaluate(context) {
                throw new Error('Must be implemented by subclass');
            }
        }

        class ConstantExpression extends Expression {
            constructor(value) {
                super();
                this.value = value;
            }

            evaluate(context) {
                return this.value;
            }
        }

        class VariableExpression extends Expression {
            constructor(name) {
                super();
                this.name = name;
            }

            evaluate(context) {
                const isObject3 = context.object && context.object.id === 'object_3' && context.time <= 2;

                if (this.name === 't') {
                    return context.time;
                }

                // Built-in constants
                if (this.name === 'pi') return Math.PI;
                if (this.name === 'e') return Math.E;

                // Check user-defined variables
                if (userVariables.has(this.name)) {
                    return userVariables.get(this.name);
                }

                // Handle object property references (e.g., "bouncer.x")
                if (this.name.includes('.')) {
                    const parts = this.name.split('.');
                    const objectId = parts[0];
                    const property = parts[1];

                    // Special built-in object: mouse
                    if (objectId === 'mouse') {
                        if (property === 'x') return mouseX;
                        if (property === 'y') return mouseY;
                        return 0;
                    }

                    // Special built-in object: prev (previous frame values)
                    if (objectId === 'prev') {
                        // Handle both prev.x (current object) and prev.objectId.x (other object)
                        if (parts.length === 2) {
                            // prev.x - get current object's previous value
                            const currentObjId = context.object.id;
                            const prevValues = previousFrameValues.get(currentObjId);
                            const result = prevValues ? (prevValues[property] || 0) : 0;

                            if (isObject3) {
                                console.log(`    [VAR] prev.${property} ‚Üí looking up in previousFrameValues['${currentObjId}']`);
                                console.log(`    [VAR] prevValues =`, prevValues);
                                console.log(`    [VAR] prev.${property} = ${result}`);
                            }

                            return result;
                        } else if (parts.length === 3) {
                            // prev.objectId.x - get another object's previous value (case-insensitive)
                            const targetObjId = parts[1];
                            const targetProperty = parts[2];

                            // Try exact match first
                            let prevValues = previousFrameValues.get(targetObjId);

                            // If not found, try case-insensitive search
                            if (!prevValues) {
                                const targetObjIdLower = targetObjId.toLowerCase();
                                for (const [id, obj] of context.allObjects.entries()) {
                                    if (id.toLowerCase() === targetObjIdLower || obj.name.toLowerCase() === targetObjIdLower) {
                                        prevValues = previousFrameValues.get(id);
                                        break;
                                    }
                                }
                            }

                            return prevValues ? (prevValues[targetProperty] || 0) : 0;
                        }
                        return 0;
                    }

                    // Try to find object by ID or name (case-insensitive)
                    let targetObj = context.allObjects.get(objectId);

                    // If not found by exact ID, try case-insensitive search by both ID and name
                    if (!targetObj) {
                        const objectIdLower = objectId.toLowerCase();
                        for (const [id, obj] of context.allObjects.entries()) {
                            if (id.toLowerCase() === objectIdLower || obj.name.toLowerCase() === objectIdLower) {
                                targetObj = obj;
                                break;
                            }
                        }
                    }

                    if (targetObj) {
                        // Evaluate the target object at the same time
                        const updated = updateObjectAtTime(targetObj, context.time, context.allObjects);
                        if (!(property in updated)) {
                            const contextInfo = context.object ? ` in equation for property "${context.currentAttribute || 'unknown'}" in object "${context.object.name || context.object.id}"` : '';
                            showError(`Unknown property "${property}" in object "${objectId}"${contextInfo}. Available properties: x, y, width, height, rotation, red, green, blue, and any custom properties.`);
                        }
                        return updated[property] || 0;
                    } else {
                        const contextInfo = context.object ? ` in equation for property "${context.currentAttribute || 'unknown'}" in object "${context.object.name || context.object.id}"` : '';
                        showError(`Unknown object "${objectId}" referenced${contextInfo}. Check that the object exists in the Objects list.`);
                        return 0;
                    }
                }

                // Check current object's properties (local variables)
                // For same-object property references, use the updated value from cache if available
                // This ensures proper evaluation order (e.g., x=prev.x+Vx uses the current frame's Vx)
                if (context.object && this.name in context.object) {
                    const cacheKey = `${context.object.id}_${context.time}`;
                    if (updateCache.has(cacheKey)) {
                        const updatedObj = updateCache.get(cacheKey);
                        if (this.name in updatedObj) {
                            return updatedObj[this.name];
                        }
                    }
                    return context.object[this.name];
                }

                return 0;
            }
        }

        class MultiFunctionExpression extends Expression {
            constructor(functionName, args) {
                super();
                this.functionName = functionName;
                this.args = args;
            }

            evaluate(context) {
                switch (this.functionName) {
                    case 'if': {
                        // if(condition, trueValue, falseValue) - conditional expression
                        if (this.args.length === 3) {
                            const condition = this.args[0].evaluate(context);
                            return condition !== 0 ? this.args[1].evaluate(context) : this.args[2].evaluate(context);
                        }
                        return 0;
                    }
                    case 'dist': {
                        // dist(x1, y1, x2, y2)
                        const values = this.args.map(arg => arg.evaluate(context));
                        if (values.length === 4) {
                            const dx = values[2] - values[0];
                            const dy = values[3] - values[1];
                            return Math.sqrt(dx * dx + dy * dy);
                        }
                        return 0;
                    }
                    case 'angle': {
                        // angle(x1, y1, x2, y2) - angle in degrees from point 1 to point 2
                        const values = this.args.map(arg => arg.evaluate(context));
                        if (values.length === 4) {
                            const dx = values[2] - values[0];
                            const dy = values[3] - values[1];
                            return Math.atan2(dy, dx) * 180 / Math.PI;
                        }
                        return 0;
                    }
                    case 'min': {
                        const values = this.args.map(arg => arg.evaluate(context));
                        return Math.min(...values);
                    }
                    case 'max': {
                        const values = this.args.map(arg => arg.evaluate(context));
                        return Math.max(...values);
                    }
                    case 'clamp': {
                        // clamp(value, min, max)
                        const values = this.args.map(arg => arg.evaluate(context));
                        if (values.length === 3) {
                            return Math.max(values[1], Math.min(values[2], values[0]));
                        }
                        return 0;
                    }
                    case 'lerp': {
                        // lerp(start, end, t) - linear interpolation
                        const values = this.args.map(arg => arg.evaluate(context));
                        if (values.length === 3) {
                            return values[0] + (values[1] - values[0]) * values[2];
                        }
                        return 0;
                    }
                    case 'random': {
                        // random() or random(max) or random(min, max)
                        const values = this.args.map(arg => arg.evaluate(context));

                        // Seeded random using context.time for determinism
                        const seed = randomSeed + context.time;
                        const x = Math.sin(seed) * 10000;
                        const rand = x - Math.floor(x);

                        if (values.length === 0) {
                            return rand;  // 0 to 1
                        } else if (values.length === 1) {
                            return rand * values[0];  // 0 to max
                        } else if (values.length === 2) {
                            return values[0] + rand * (values[1] - values[0]);  // min to max
                        }
                        return 0;
                    }
                    case 'mod': {
                        // mod(value, divisor) - modulo operation
                        const values = this.args.map(arg => arg.evaluate(context));
                        if (values.length === 2) {
                            return ((values[0] % values[1]) + values[1]) % values[1];  // Always positive
                        }
                        return 0;
                    }
                    case 'pow': {
                        // pow(base, exponent)
                        const values = this.args.map(arg => arg.evaluate(context));
                        if (values.length === 2) {
                            return Math.pow(values[0], values[1]);
                        }
                        return 0;
                    }
                    case 'atan2': {
                        // atan2(y, x) - angle in degrees
                        const values = this.args.map(arg => arg.evaluate(context));
                        if (values.length === 2) {
                            return Math.atan2(values[0], values[1]) * 180 / Math.PI;
                        }
                        return 0;
                    }
                    case 'smoothstep': {
                        // smoothstep(edge0, edge1, x) - smooth Hermite interpolation
                        const values = this.args.map(arg => arg.evaluate(context));
                        if (values.length === 3) {
                            const edge0 = values[0];
                            const edge1 = values[1];
                            let x = values[2];
                            // Clamp x to 0-1 range
                            x = Math.max(0, Math.min(1, (x - edge0) / (edge1 - edge0)));
                            // Hermite interpolation: 3x^2 - 2x^3
                            return x * x * (3 - 2 * x);
                        }
                        return 0;
                    }
                    case 'step': {
                        // step(edge, x) - returns 0 if x < edge, else 1
                        const values = this.args.map(arg => arg.evaluate(context));
                        if (values.length === 2) {
                            return values[1] < values[0] ? 0 : 1;
                        }
                        return 0;
                    }
                    case 'wrap': {
                        // wrap(value, min, max) - wraps value to range [min, max)
                        const values = this.args.map(arg => arg.evaluate(context));
                        if (values.length === 3) {
                            const value = values[0];
                            const min = values[1];
                            const max = values[2];
                            const range = max - min;
                            if (range === 0) return min;
                            return min + ((((value - min) % range) + range) % range);
                        }
                        return 0;
                    }
                    case 'bounce': {
                        // bounce(t) - bouncing easing (0 to 1 input)
                        const values = this.args.map(arg => arg.evaluate(context));
                        if (values.length === 1) {
                            let t = values[0];
                            // Normalize to 0-1 if needed
                            t = t - Math.floor(t);

                            if (t < 1/2.75) {
                                return 7.5625 * t * t;
                            } else if (t < 2/2.75) {
                                t -= 1.5/2.75;
                                return 7.5625 * t * t + 0.75;
                            } else if (t < 2.5/2.75) {
                                t -= 2.25/2.75;
                                return 7.5625 * t * t + 0.9375;
                            } else {
                                t -= 2.625/2.75;
                                return 7.5625 * t * t + 0.984375;
                            }
                        }
                        return 0;
                    }
                    case 'ease': {
                        // ease(x, power) - power-based easing
                        const values = this.args.map(arg => arg.evaluate(context));
                        if (values.length === 2) {
                            const x = Math.max(0, Math.min(1, values[0]));  // Clamp to 0-1
                            const power = values[1];
                            return Math.pow(x, power);
                        }
                        return 0;
                    }
                    case 'overlaps': {
                        // overlaps(obj1Id, obj2Id) - returns 1 if objects overlap, 0 otherwise
                        if (this.args.length === 2) {
                            const obj1Name = this.args[0];
                            const obj2Name = this.args[1];

                            // Get object IDs from variable expressions
                            if (obj1Name instanceof VariableExpression && obj2Name instanceof VariableExpression) {
                                const obj1 = context.allObjects.get(obj1Name.name);
                                const obj2 = context.allObjects.get(obj2Name.name);

                                if (obj1 && obj2) {
                                    const updated1 = updateObjectAtTime(obj1, context.time, context.allObjects);
                                    const updated2 = updateObjectAtTime(obj2, context.time, context.allObjects);

                                    // Simple bounding box collision
                                    const dx = Math.abs(updated1.x - updated2.x);
                                    const dy = Math.abs(updated1.y - updated2.y);
                                    const minDistX = (updated1.width + updated2.width) / 2;
                                    const minDistY = (updated1.height + updated2.height) / 2;

                                    return (dx < minDistX && dy < minDistY) ? 1 : 0;
                                }
                            }
                        }
                        return 0;
                    }
                    case 'keydown': {
                        // keyDown(key) - returns 1 if key is pressed, 0 otherwise
                        if (this.args.length >= 1) {
                            const keyArg = this.args[0];
                            if (keyArg instanceof VariableExpression) {
                                const keyName = keyArg.name.toLowerCase();
                                return keysPressed.has(keyName) ? 1 : 0;
                            }
                        }
                        return 0;
                    }
                    default:
                        return 0;
                }
            }
        }

        class BinaryOperatorExpression extends Expression {
            constructor(operator, left, right) {
                super();
                this.operator = operator;
                this.left = left;
                this.right = right;
            }

            evaluate(context) {
                const isObject3 = context.object && context.object.id === 'object_3' && context.time <= 2;

                const leftValue = this.left.evaluate(context);
                const rightValue = this.right.evaluate(context);

                if (isObject3 && this.operator === '+') {
                    // Log addition operations for debugging
                    const leftStr = this.left.constructor.name === 'VariableExpression' ? this.left.name : 'expr';
                    const rightStr = this.right.constructor.name === 'VariableExpression' ? this.right.name : 'expr';
                    console.log(`    [BINOP] ${leftStr} + ${rightStr} = ${leftValue} + ${rightValue} = ${leftValue + rightValue}`);
                }

                switch (this.operator) {
                    case '+': return leftValue + rightValue;
                    case '-': return leftValue - rightValue;
                    case '*': return leftValue * rightValue;
                    case '/': return rightValue !== 0 ? leftValue / rightValue : 0;
                    case '^': return Math.pow(leftValue, rightValue);
                    case 'rem': return leftValue % rightValue;
                    case 'and': return (leftValue !== 0 && rightValue !== 0) ? 1 : 0;
                    case 'or': return (leftValue !== 0 || rightValue !== 0) ? 1 : 0;
                    case '==': return leftValue === rightValue ? 1 : 0;
                    case '!=': return leftValue !== rightValue ? 1 : 0;
                    case '<': return leftValue < rightValue ? 1 : 0;
                    case '>': return leftValue > rightValue ? 1 : 0;
                    case '<=': return leftValue <= rightValue ? 1 : 0;
                    case '>=': return leftValue >= rightValue ? 1 : 0;
                    default: return 0;
                }
            }
        }

        class UnaryOperatorExpression extends Expression {
            constructor(operator, operand) {
                super();
                this.operator = operator;
                this.operand = operand;
            }

            evaluate(context) {
                const value = this.operand.evaluate(context);

                switch (this.operator) {
                    case '-': return -value;
                    case 'abs': return Math.abs(value);
                    case 'sin': return Math.sin((value * Math.PI) / 180);
                    case 'cos': return Math.cos((value * Math.PI) / 180);
                    case 'tan': return Math.tan((value * Math.PI) / 180);
                    case 'asin': return (Math.asin(value) * 180) / Math.PI;
                    case 'acos': return (Math.acos(value) * 180) / Math.PI;
                    case 'atan': return (Math.atan(value) * 180) / Math.PI;
                    case 'not': return value === 0 ? 1 : 0;
                    case 'sqrt': return Math.sqrt(Math.abs(value));
                    case 'ln': return Math.log(value);
                    case 'log': return Math.log10(value);
                    case 'exp': return Math.exp(value);
                    case 'floor': return Math.floor(value);
                    case 'ceil': return Math.ceil(value);
                    case 'round': return Math.round(value);
                    case 'sign': return Math.sign(value);
                    case 'fract': return value - Math.floor(value);  // Fractional part
                    default: return 0;
                }
            }
        }

        function evaluateEquation(equation, context) {
            const time = context.time;
            if (equation.cache.has(time)) {
                return equation.cache.get(time);
            }

            // Safety check for null expression
            if (!equation.expression) {
                console.error('Null expression in equation:', equation);
                return 0;
            }

            const result = equation.expression.evaluate(context);

            equation.cache.set(time, result);
            return result;
        }

        // ==================== Equation Parser ====================

        class Token {
            constructor(type, value) {
                this.type = type;
                this.value = value;
            }
        }

        class Tokenizer {
            constructor(input) {
                this.input = input.replace(/\s+/g, ''); // Remove whitespace
                this.position = 0;
            }

            peek() {
                return this.input[this.position];
            }

            advance() {
                return this.input[this.position++];
            }

            isDigit(ch) {
                return ch >= '0' && ch <= '9';
            }

            isLetter(ch) {
                return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z');
            }

            isIdentifierChar(ch) {
                // Allow letters, digits, underscores, and dots in identifiers
                return this.isLetter(ch) || this.isDigit(ch) || ch === '_' || ch === '.';
            }

            tokenize() {
                const tokens = [];

                while (this.position < this.input.length) {
                    const ch = this.peek();

                    if (this.isDigit(ch)) {
                        tokens.push(this.readNumber());
                    } else if (ch === '.' && this.position + 1 < this.input.length && this.isDigit(this.input[this.position + 1])) {
                        // Decimal number starting with .
                        tokens.push(this.readNumber());
                    } else if (this.isLetter(ch)) {
                        tokens.push(this.readIdentifier());
                    } else if (ch === '+') {
                        tokens.push(new Token('PLUS', '+'));
                        this.advance();
                    } else if (ch === '-') {
                        tokens.push(new Token('MINUS', '-'));
                        this.advance();
                    } else if (ch === '*') {
                        tokens.push(new Token('MULTIPLY', '*'));
                        this.advance();
                    } else if (ch === '/') {
                        tokens.push(new Token('DIVIDE', '/'));
                        this.advance();
                    } else if (ch === '^') {
                        tokens.push(new Token('POWER', '^'));
                        this.advance();
                    } else if (ch === '(') {
                        tokens.push(new Token('LPAREN', '('));
                        this.advance();
                    } else if (ch === ')') {
                        tokens.push(new Token('RPAREN', ')'));
                        this.advance();
                    } else if (ch === ',') {
                        tokens.push(new Token('COMMA', ','));
                        this.advance();
                    } else if (ch === '<') {
                        this.advance();
                        if (this.peek() === '=') {
                            tokens.push(new Token('LTE', '<='));
                            this.advance();
                        } else {
                            tokens.push(new Token('LT', '<'));
                        }
                    } else if (ch === '>') {
                        this.advance();
                        if (this.peek() === '=') {
                            tokens.push(new Token('GTE', '>='));
                            this.advance();
                        } else {
                            tokens.push(new Token('GT', '>'));
                        }
                    } else if (ch === '=') {
                        this.advance();
                        if (this.peek() === '=') {
                            tokens.push(new Token('EQ', '=='));
                            this.advance();
                        } else {
                            throw new Error('Unexpected single = (use == for equality)');
                        }
                    } else if (ch === '!') {
                        this.advance();
                        if (this.peek() === '=') {
                            tokens.push(new Token('NEQ', '!='));
                            this.advance();
                        } else {
                            throw new Error('Unexpected ! (use != for inequality)');
                        }
                    } else {
                        throw new Error(`Unexpected character: ${ch}`);
                    }
                }

                tokens.push(new Token('EOF', null));
                return tokens;
            }

            readNumber() {
                let num = '';
                while (this.position < this.input.length &&
                       (this.isDigit(this.peek()) || this.peek() === '.')) {
                    num += this.advance();
                }
                return new Token('NUMBER', parseFloat(num));
            }

            readIdentifier() {
                let id = '';
                // First character must be a letter
                if (this.isLetter(this.peek())) {
                    id += this.advance();
                }
                // Subsequent characters can be letters, digits, underscores, or dots
                while (this.position < this.input.length && this.isIdentifierChar(this.peek())) {
                    id += this.advance();
                }
                // PRESERVE CASE - don't lowercase identifiers!
                // This allows case-sensitive variables like Vx, Vy, Ax, Ay
                // and object names with underscores like object_3
                return new Token('IDENTIFIER', id);
            }
        }

        class Parser {
            constructor(tokens) {
                this.tokens = tokens;
                this.position = 0;
            }

            peek() {
                return this.tokens[this.position];
            }

            advance() {
                return this.tokens[this.position++];
            }

            expect(type) {
                const token = this.advance();
                if (token.type !== type) {
                    throw new Error(`Expected ${type} but got ${token.type}`);
                }
                return token;
            }

            parse() {
                const expr = this.parseExpression();
                this.expect('EOF');
                return expr;
            }

            parseExpression() {
                return this.parseComparison();
            }

            parseComparison() {
                let left = this.parseAddition();

                while (['LT', 'GT', 'LTE', 'GTE', 'EQ', 'NEQ'].includes(this.peek().type)) {
                    const op = this.advance();
                    const right = this.parseAddition();
                    left = new BinaryOperatorExpression(op.value, left, right);
                }

                return left;
            }

            parseAddition() {
                let left = this.parseMultiplication();

                while (this.peek().type === 'PLUS' || this.peek().type === 'MINUS') {
                    const op = this.advance();
                    const right = this.parseMultiplication();
                    left = new BinaryOperatorExpression(op.value, left, right);
                }

                return left;
            }

            parseMultiplication() {
                let left = this.parsePower();

                while (this.peek().type === 'MULTIPLY' || this.peek().type === 'DIVIDE') {
                    const op = this.advance();
                    const right = this.parsePower();
                    left = new BinaryOperatorExpression(op.value, left, right);
                }

                return left;
            }

            parsePower() {
                let left = this.parseUnary();

                if (this.peek().type === 'POWER') {
                    this.advance();
                    const right = this.parsePower(); // Right associative
                    left = new BinaryOperatorExpression('^', left, right);
                }

                return left;
            }

            parseUnary() {
                if (this.peek().type === 'MINUS') {
                    this.advance();
                    const operand = this.parseUnary();
                    return new UnaryOperatorExpression('-', operand);
                }

                if (this.peek().type === 'PLUS') {
                    this.advance();
                    return this.parseUnary();
                }

                return this.parsePrimary();
            }

            parsePrimary() {
                const token = this.peek();

                if (token.type === 'NUMBER') {
                    this.advance();
                    return new ConstantExpression(token.value);
                }

                if (token.type === 'IDENTIFIER') {
                    const id = this.advance();

                    // Check if it's a function call
                    if (this.peek().type === 'LPAREN') {
                        this.advance(); // consume (

                        // Check for multi-argument functions (case-insensitive)
                        const multiFuncs = ['if', 'dist', 'angle', 'min', 'max', 'clamp', 'lerp', 'random', 'mod', 'pow', 'atan2', 'smoothstep', 'step', 'wrap', 'bounce', 'ease', 'overlaps', 'keydown'];
                        if (multiFuncs.includes(id.value.toLowerCase())) {
                            const args = [];
                            if (this.peek().type !== 'RPAREN') {
                                args.push(this.parseExpression());
                                while (this.peek().type === 'COMMA') {
                                    this.advance(); // consume comma
                                    args.push(this.parseExpression());
                                }
                            }
                            this.expect('RPAREN');
                            return new MultiFunctionExpression(id.value.toLowerCase(), args);
                        } else {
                            // Single argument function (normalize to lowercase)
                            const arg = this.parseExpression();
                            this.expect('RPAREN');
                            return new UnaryOperatorExpression(id.value.toLowerCase(), arg);
                        }
                    }

                    // It's a variable (like 't' or 'bouncer.x')
                    return new VariableExpression(id.value);
                }

                if (token.type === 'LPAREN') {
                    this.advance();
                    const expr = this.parseExpression();
                    this.expect('RPAREN');
                    return expr;
                }

                throw new Error(`Unexpected token: ${token.type}`);
            }
        }

        function parseEquation(equationText) {
            try {
                const tokenizer = new Tokenizer(equationText);
                const tokens = tokenizer.tokenize();
                const parser = new Parser(tokens);
                const expression = parser.parse();
                return { success: true, expression, error: null };
            } catch (error) {
                return { success: false, expression: null, error: error.message };
            }
        }

        function updateObjectAtTime(obj, time, allObjects) {
            // Check cache to prevent infinite recursion
            const cacheKey = `${obj.id}_${time}`;
            if (updateCache.has(cacheKey)) {
                return updateCache.get(cacheKey);
            }

            const updated = { ...obj };
            const context = { object: updated, time, allObjects };

            // Mark this object as being computed to prevent recursion
            updateCache.set(cacheKey, updated);

            // DEBUG: Log for object_3 at early frames
            const isObject3 = obj.id === 'object_3';
            if (isObject3 && time <= 5) {
                console.log(`\n[FRAME ${time}] Updating object_3:`);
                console.log(`  Before: x=${obj.x.toFixed(2)}, y=${obj.y.toFixed(2)}, Vx=${obj.Vx}, Vy=${obj.Vy}, Ax=${obj.Ax}, Ay=${obj.Ay}`);
                console.log(`  Equations to evaluate:`, Array.from(obj.equations.keys()));
            }

            obj.equations.forEach((equation, attribute) => {
                // Add current attribute to context for better error messages
                context.currentAttribute = attribute;
                const value = evaluateEquation(equation, context);

                if (isObject3 && time <= 5) {
                    console.log(`  ${attribute} = ${value} (was ${obj[attribute]})`);
                }

                switch (attribute) {
                    case 'x': updated.x = value; break;
                    case 'y': updated.y = value; break;
                    case 'width': updated.width = value; break;
                    case 'height': updated.height = value; break;
                    case 'rotation': updated.rotation = value; break;
                    case 'red': updated.red = Math.round(Math.max(0, Math.min(255, value))); break;
                    case 'green': updated.green = Math.round(Math.max(0, Math.min(255, value))); break;
                    case 'blue': updated.blue = Math.round(Math.max(0, Math.min(255, value))); break;
                    case 'opacity': updated.opacity = Math.max(0, Math.min(100, value)); break;
                    case 'thicknessPen': updated.thicknessPen = Math.max(0.5, value); break;
                    case 'redColourPen': updated.redColourPen = Math.round(Math.max(0, Math.min(255, value))); break;
                    case 'greenColourPen': updated.greenColourPen = Math.round(Math.max(0, Math.min(255, value))); break;
                    case 'blueColourPen': updated.blueColourPen = Math.round(Math.max(0, Math.min(255, value))); break;
                    case 'opacityPen': updated.opacityPen = Math.max(0, Math.min(100, value)); break;
                    default:
                        // Support custom user-defined properties (e.g., vy, vx, ax, ay)
                        updated[attribute] = value;
                        break;
                }
            });

            if (isObject3 && time <= 5) {
                console.log(`  After: x=${updated.x.toFixed(2)}, y=${updated.y.toFixed(2)}, Vx=${updated.Vx}, Vy=${updated.Vy}, Ax=${updated.Ax}, Ay=${updated.Ay}`);
            }

            return updated;
        }

        // ==================== Canvas Renderer ====================

        class CanvasRenderer {
            constructor(canvas) {
                this.ctx = canvas.getContext('2d');
            }

            clear() {
                this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
            }

            drawGrid(spacing = 50, color = '#e0e0e0') {
                const { width, height } = this.ctx.canvas;
                this.ctx.save();
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = 1;

                for (let x = 0; x <= width; x += spacing) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, height);
                    this.ctx.stroke();
                }

                for (let y = 0; y <= height; y += spacing) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(width, y);
                    this.ctx.stroke();
                }

                this.ctx.restore();
            }

            renderTrails(trails) {
                trails.forEach(trail => {
                    if (trail.points.length < 2) return;

                    this.ctx.save();
                    this.ctx.lineCap = 'round';
                    this.ctx.lineJoin = 'round';

                    // Draw each segment with its own properties
                    for (let i = 0; i < trail.points.length - 1; i++) {
                        const p1 = trail.points[i];
                        const p2 = trail.points[i + 1];

                        // Use p2's properties (the "to" point) for the segment
                        const opacity = (p2.opacity !== undefined ? p2.opacity : 100) / 100;
                        this.ctx.strokeStyle = `rgba(${p2.color.r}, ${p2.color.g}, ${p2.color.b}, ${opacity})`;
                        this.ctx.lineWidth = p2.thickness;

                        this.ctx.beginPath();
                        this.ctx.moveTo(p1.x, p1.y);
                        this.ctx.lineTo(p2.x, p2.y);
                        this.ctx.stroke();
                    }

                    this.ctx.restore();
                });
            }

            renderObject(obj, isSelected = false) {
                this.ctx.save();
                this.ctx.translate(obj.x, obj.y);
                this.ctx.rotate((obj.rotation * Math.PI) / 180);

                const alpha = obj.opacity / 100;
                this.ctx.fillStyle = `rgba(${obj.red}, ${obj.green}, ${obj.blue}, ${alpha})`;

                if (isSelected) {
                    this.ctx.strokeStyle = '#FFD700';
                    this.ctx.lineWidth = 4;
                    this.ctx.setLineDash([5, 5]);

                    switch (obj.appearance) {
                        case 'square':
                            this.ctx.strokeRect(-obj.width/2 - 5, -obj.height/2 - 5, obj.width + 10, obj.height + 10);
                            break;
                        case 'circle':
                            this.ctx.beginPath();
                            this.ctx.ellipse(0, 0, obj.width/2 + 5, obj.height/2 + 5, 0, 0, 2 * Math.PI);
                            this.ctx.stroke();
                            break;
                        case 'triangle':
                            this.ctx.beginPath();
                            this.ctx.moveTo(0, -obj.height/2 - 8);
                            this.ctx.lineTo(obj.width/2 + 8, obj.height/2 + 8);
                            this.ctx.lineTo(-obj.width/2 - 8, obj.height/2 + 8);
                            this.ctx.closePath();
                            this.ctx.stroke();
                            break;
                        case 'star':
                        case 'pentagon':
                        case 'hexagon':
                        case 'diamond':
                        case 'ellipse':
                        case 'roundrect':
                            // Use ellipse for selection highlight
                            this.ctx.beginPath();
                            this.ctx.ellipse(0, 0, obj.width/2 + 8, obj.height/2 + 8, 0, 0, 2 * Math.PI);
                            this.ctx.stroke();
                            break;
                        case 'line':
                        case 'arrow':
                            this.ctx.beginPath();
                            this.ctx.moveTo(-obj.width/2 - 5, 0);
                            this.ctx.lineTo(obj.width/2 + 5, 0);
                            this.ctx.stroke();
                            break;
                        case 'text':
                            // Use obj.width and obj.height for consistent selection box
                            this.ctx.strokeRect(-obj.width/2 - 5, -obj.height/2 - 5, obj.width + 10, obj.height + 10);
                            break;
                    }
                    this.ctx.setLineDash([]);
                }

                switch (obj.appearance) {
                    case 'square':
                        this.ctx.fillRect(-obj.width/2, -obj.height/2, obj.width, obj.height);
                        break;
                    case 'circle':
                        this.ctx.beginPath();
                        this.ctx.ellipse(0, 0, obj.width/2, obj.height/2, 0, 0, 2 * Math.PI);
                        this.ctx.fill();
                        break;
                    case 'triangle':
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, -obj.height/2);
                        this.ctx.lineTo(obj.width/2, obj.height/2);
                        this.ctx.lineTo(-obj.width/2, obj.height/2);
                        this.ctx.closePath();
                        this.ctx.fill();
                        break;
                    case 'star': {
                        // 5-pointed star with independent width/height
                        const outerRadiusX = obj.width / 2;
                        const outerRadiusY = obj.height / 2;
                        const innerRadiusX = outerRadiusX * 0.4;
                        const innerRadiusY = outerRadiusY * 0.4;
                        this.ctx.beginPath();
                        for (let i = 0; i < 10; i++) {
                            const angle = (i * Math.PI / 5) - Math.PI / 2;
                            const radiusX = i % 2 === 0 ? outerRadiusX : innerRadiusX;
                            const radiusY = i % 2 === 0 ? outerRadiusY : innerRadiusY;
                            const x = Math.cos(angle) * radiusX;
                            const y = Math.sin(angle) * radiusY;
                            if (i === 0) this.ctx.moveTo(x, y);
                            else this.ctx.lineTo(x, y);
                        }
                        this.ctx.closePath();
                        this.ctx.fill();
                        break;
                    }
                    case 'pentagon': {
                        // Pentagon with independent width/height
                        const radiusX = obj.width / 2;
                        const radiusY = obj.height / 2;
                        this.ctx.beginPath();
                        for (let i = 0; i < 5; i++) {
                            const angle = (i * 2 * Math.PI / 5) - Math.PI / 2;
                            const x = Math.cos(angle) * radiusX;
                            const y = Math.sin(angle) * radiusY;
                            if (i === 0) this.ctx.moveTo(x, y);
                            else this.ctx.lineTo(x, y);
                        }
                        this.ctx.closePath();
                        this.ctx.fill();
                        break;
                    }
                    case 'hexagon': {
                        // Hexagon with independent width/height
                        const radiusX = obj.width / 2;
                        const radiusY = obj.height / 2;
                        this.ctx.beginPath();
                        for (let i = 0; i < 6; i++) {
                            const angle = (i * 2 * Math.PI / 6) - Math.PI / 2;
                            const x = Math.cos(angle) * radiusX;
                            const y = Math.sin(angle) * radiusY;
                            if (i === 0) this.ctx.moveTo(x, y);
                            else this.ctx.lineTo(x, y);
                        }
                        this.ctx.closePath();
                        this.ctx.fill();
                        break;
                    }
                    case 'diamond': {
                        // Diamond (rotated square)
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, -obj.height/2);  // Top
                        this.ctx.lineTo(obj.width/2, 0);     // Right
                        this.ctx.lineTo(0, obj.height/2);    // Bottom
                        this.ctx.lineTo(-obj.width/2, 0);    // Left
                        this.ctx.closePath();
                        this.ctx.fill();
                        break;
                    }
                    case 'ellipse': {
                        // Ellipse (oval)
                        this.ctx.beginPath();
                        this.ctx.ellipse(0, 0, obj.width/2, obj.height/2, 0, 0, 2 * Math.PI);
                        this.ctx.fill();
                        break;
                    }
                    case 'roundrect': {
                        // Rounded rectangle
                        const radius = Math.min(obj.width, obj.height) * 0.2;  // 20% of smallest dimension
                        this.ctx.beginPath();
                        this.ctx.moveTo(-obj.width/2 + radius, -obj.height/2);
                        this.ctx.lineTo(obj.width/2 - radius, -obj.height/2);
                        this.ctx.quadraticCurveTo(obj.width/2, -obj.height/2, obj.width/2, -obj.height/2 + radius);
                        this.ctx.lineTo(obj.width/2, obj.height/2 - radius);
                        this.ctx.quadraticCurveTo(obj.width/2, obj.height/2, obj.width/2 - radius, obj.height/2);
                        this.ctx.lineTo(-obj.width/2 + radius, obj.height/2);
                        this.ctx.quadraticCurveTo(-obj.width/2, obj.height/2, -obj.width/2, obj.height/2 - radius);
                        this.ctx.lineTo(-obj.width/2, -obj.height/2 + radius);
                        this.ctx.quadraticCurveTo(-obj.width/2, -obj.height/2, -obj.width/2 + radius, -obj.height/2);
                        this.ctx.closePath();
                        this.ctx.fill();
                        break;
                    }
                    case 'line':
                        this.ctx.strokeStyle = this.ctx.fillStyle;
                        this.ctx.lineWidth = obj.height || 3;
                        this.ctx.beginPath();
                        this.ctx.moveTo(-obj.width/2, 0);
                        this.ctx.lineTo(obj.width/2, 0);
                        this.ctx.stroke();
                        break;
                    case 'arrow':
                        this.ctx.strokeStyle = this.ctx.fillStyle;
                        this.ctx.lineWidth = obj.height || 3;
                        // Arrow shaft
                        this.ctx.beginPath();
                        this.ctx.moveTo(-obj.width/2, 0);
                        this.ctx.lineTo(obj.width/2 - 15, 0);
                        this.ctx.stroke();
                        // Arrow head
                        this.ctx.beginPath();
                        this.ctx.moveTo(obj.width/2, 0);
                        this.ctx.lineTo(obj.width/2 - 15, -10);
                        this.ctx.lineTo(obj.width/2 - 15, 10);
                        this.ctx.closePath();
                        this.ctx.fill();
                        break;
                    case 'text':
                        // Render text stretched to fit both width and height independently
                        const textToRender = obj.text || obj.name;

                        // Measure text at a standard size
                        const baseFontSize = 100;
                        this.ctx.font = `${baseFontSize}px Arial`;
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'middle';

                        const metrics = this.ctx.measureText(textToRender);
                        const textWidth = metrics.width;
                        // Approximate text height (ascent + descent)
                        const textHeight = baseFontSize;

                        // Calculate scale factors to fit the text into obj.width x obj.height
                        const scaleX = obj.width / textWidth;
                        const scaleY = obj.height / textHeight;

                        // Counter the y-flip and apply independent scaling
                        this.ctx.save();
                        this.ctx.scale(scaleX, -scaleY);  // negative scaleY to flip text right-side up
                        this.ctx.fillText(textToRender, 0, 0);
                        this.ctx.restore();
                        break;
                }

                this.ctx.restore();
            }

            renderScene(objects, trails, selectedId = null) {
                this.clear();

                // Apply coordinate transformation: y=0 at bottom, y increases upward (mathematical convention)
                this.ctx.save();
                this.ctx.translate(0, this.ctx.canvas.height);
                this.ctx.scale(1, -1);

                // Grid removed as per user request
                // this.drawGrid();
                this.renderTrails(trails);
                objects.forEach(obj => this.renderObject(obj, obj.id === selectedId));

                this.ctx.restore();
            }
        }

        // ==================== Error Reporting ====================

        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            const errorText = document.getElementById('errorText');
            errorText.textContent = message;
            errorDiv.style.display = 'block';

            // Auto-hide after 10 seconds
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 10000);
        }

        function showModelInfo(title, description) {
            const infoDiv = document.getElementById('modelInfoMessage');
            const infoTitle = document.getElementById('modelInfoTitle');
            const infoText = document.getElementById('modelInfoText');
            infoTitle.textContent = `üìö ${title}`;
            infoText.textContent = description;
            infoDiv.style.display = 'block';
        }

        // ==================== Animation Controller ====================

        class AnimationController {
            constructor(onFrame, fps = 30) {
                this.onFrame = onFrame;
                this.fps = fps;
                this.frameDuration = 1000 / fps;
                this.animationFrameId = null;
                this.lastFrameTime = 0;
                this.currentFrame = 0;
            }

            setFPS(fps) {
                this.fps = fps;
                this.frameDuration = 1000 / fps;
            }

            start() {
                if (this.animationFrameId !== null) return;
                this.lastFrameTime = performance.now();
                this.tick(this.lastFrameTime);
            }

            stop() {
                if (this.animationFrameId !== null) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                }
            }

            tick(currentTime) {
                this.animationFrameId = requestAnimationFrame((time) => this.tick(time));
                const elapsed = currentTime - this.lastFrameTime;
                if (elapsed >= this.frameDuration) {
                    this.currentFrame++;
                    this.onFrame(this.currentFrame);
                    this.lastFrameTime = currentTime - (elapsed % this.frameDuration);
                }
            }

            reset() {
                this.currentFrame = 0;
                this.lastFrameTime = performance.now();
            }

            setFrame(frame) {
                this.currentFrame = frame;
                this.onFrame(this.currentFrame);
            }

            stepForward() {
                this.currentFrame++;
                this.onFrame(this.currentFrame);
            }

            stepBackward() {
                this.currentFrame = Math.max(0, this.currentFrame - 1);
                this.onFrame(this.currentFrame);
            }

            isRunning() {
                return this.animationFrameId !== null;
            }
        }

        // ==================== Trail Manager ====================

        class TrailManager {
            constructor() {
                this.trails = new Map();
                this.lastPositions = new Map();
            }

            recordPosition(obj, frame) {
                if (!obj.penDown) {
                    this.lastPositions.delete(obj.id);
                    return;
                }

                const last = this.lastPositions.get(obj.id);

                if (!this.trails.has(obj.id)) {
                    this.trails.set(obj.id, {
                        points: []
                    });
                }

                const trail = this.trails.get(obj.id);

                // Store pen properties with each point
                const pointData = {
                    x: obj.x,
                    y: obj.y,
                    color: {
                        r: obj.redColourPen !== undefined ? obj.redColourPen : obj.red,
                        g: obj.greenColourPen !== undefined ? obj.greenColourPen : obj.green,
                        b: obj.blueColourPen !== undefined ? obj.blueColourPen : obj.blue
                    },
                    thickness: obj.thicknessPen !== undefined ? obj.thicknessPen : 2,
                    opacity: obj.opacityPen !== undefined ? obj.opacityPen : obj.opacity
                };

                if (!last || last.frame + 1 === frame) {
                    trail.points.push(pointData);
                } else if (last.frame !== frame) {
                    trail.points = [pointData];
                }

                this.lastPositions.set(obj.id, { x: obj.x, y: obj.y, frame });
            }

            clearAll() {
                this.trails.clear();
                this.lastPositions.clear();
            }

            clearObject(objectId) {
                this.trails.delete(objectId);
                this.lastPositions.delete(objectId);
            }

            getAllTrails() {
                return Array.from(this.trails.values());
            }
        }

        // ==================== History Manager (Undo/Redo) ====================

        class HistoryManager {
            constructor(maxStates = 50) {
                this.maxStates = maxStates;
                this.history = [];
                this.currentIndex = -1;
            }

            pushState(state) {
                // Remove any states after current index
                this.history = this.history.slice(0, this.currentIndex + 1);

                // Add new state
                this.history.push(this.cloneState(state));

                // Limit history size
                if (this.history.length > this.maxStates) {
                    this.history.shift();
                } else {
                    this.currentIndex++;
                }
            }

            canUndo() {
                return this.currentIndex > 0;
            }

            canRedo() {
                return this.currentIndex < this.history.length - 1;
            }

            undo() {
                if (this.canUndo()) {
                    this.currentIndex--;
                    return this.cloneState(this.history[this.currentIndex]);
                }
                return null;
            }

            redo() {
                if (this.canRedo()) {
                    this.currentIndex++;
                    return this.cloneState(this.history[this.currentIndex]);
                }
                return null;
            }

            getInfo() {
                return {
                    current: this.currentIndex + 1,
                    total: this.history.length,
                    canUndo: this.canUndo(),
                    canRedo: this.canRedo()
                };
            }

            cloneState(state) {
                return JSON.parse(JSON.stringify(state));
            }

            clear() {
                this.history = [];
                this.currentIndex = -1;
            }
        }

        // ==================== Demo Setup ====================

        let canvas, renderer, animationController, trailManager, historyManager, objects;
        let isPlaying = false;
        let selectedObjectId = null;
        let selectedObjectIds = new Set(); // Multi-select support
        let nextObjectId = 1;
        let isDragging = false;
        let dragOffsetX = 0;
        let dragOffsetY = 0;
        let isShiftPressed = false;
        let mouseX = 0;  // Current mouse X position
        let mouseY = 0;  // Current mouse Y position
        let keysPressed = new Set();  // Currently pressed keys
        let previousFrameValues = new Map();  // Store t-1 values for each object
        let keyboardShortcutsEnabled = false;  // Toggle for keyboard shortcuts (default off to avoid conflicts)
        let userVariables = new Map(); // User-defined variables
        let randomSeed = 12345; // For deterministic random
        let camera = { x: 0, y: 0, zoom: 1 }; // Camera transform
        let isPanning = false;
        let lastPanX = 0;
        let lastPanY = 0;
        let updateCache = new Map(); // Cache to prevent infinite recursion in updateObjectAtTime
        const GRID_SIZE = 25;

        function initDemo() {
            canvas = document.getElementById('canvas');
            renderer = new CanvasRenderer(canvas);
            trailManager = new TrailManager();
            historyManager = new HistoryManager(50);

            objects = new Map();

            // Demo objects
            objects.set('mover', {
                id: 'mover',
                name: 'Mover',
                x: 100, y: 200,
                width: 50, height: 50,
                rotation: 0,
                red: 255, green: 100, blue: 100,
                opacity: 100,
                appearance: 'square',
                penDown: true,
                text: '',
                thicknessPen: 2,
                redColourPen: 255,
                greenColourPen: 100,
                blueColourPen: 100,
                opacityPen: 100,
                info: 'Mover moves to the right at a constant speed by multiplying the time by 2 and adding a starting position of 100.',
                equations: new Map([
                    ['x', {
                        attribute: 'x',
                        text: 't * 2 + 100',
                        expression: new BinaryOperatorExpression('+',
                            new BinaryOperatorExpression('*', new VariableExpression('t'), new ConstantExpression(2)),
                            new ConstantExpression(100)
                        ),
                        cache: new Map()
                    }]
                ])
            });


            objects.set('spinner', {
                id: 'spinner',
                name: 'Spinner',
                x: 600, y: 200,
                width: 70, height: 40,
                rotation: 0,
                red: 100, green: 255, blue: 100,
                opacity: 100,
                appearance: 'square',
                penDown: false,
                text: '',
                thicknessPen: 2,
                redColourPen: 100,
                greenColourPen: 255,
                blueColourPen: 100,
                opacityPen: 100,
                info: 'Spinner rotates continuously by setting rotation to time multiplied by 5, spinning at 5 degrees per frame.',
                equations: new Map([
                    ['rotation', {
                        attribute: 'rotation',
                        text: 't * 5',
                        expression: new BinaryOperatorExpression('*', new VariableExpression('t'), new ConstantExpression(5)),
                        cache: new Map()
                    }]
                ])
            });

            objects.set('colorChanger', {
                id: 'colorChanger',
                name: 'ColorChanger',
                x: 200, y: 400,
                width: 80, height: 80,
                rotation: 0,
                red: 128, green: 128, blue: 255,
                opacity: 100,
                appearance: 'circle',
                penDown: false,
                text: '',
                thicknessPen: 2,
                redColourPen: 128,
                greenColourPen: 128,
                blueColourPen: 255,
                opacityPen: 100,
                info: 'ColorChanger oscillates its red color channel using a sine wave, creating a smooth color pulse by centering at 128 and varying by 127.',
                equations: new Map([
                    ['red', {
                        attribute: 'red',
                        text: '128 + sin(t * 6) * 127',
                        expression: new BinaryOperatorExpression('+',
                            new ConstantExpression(128),
                            new BinaryOperatorExpression('*',
                                new UnaryOperatorExpression('sin',
                                    new BinaryOperatorExpression('*', new VariableExpression('t'), new ConstantExpression(6))
                                ),
                                new ConstantExpression(127)
                            )
                        ),
                        cache: new Map()
                    }]
                ])
            });

            // Follower object - demonstrates object interactions
            const followerX = parseEquation('bouncer.x + 80');
            const followerY = parseEquation('bouncer.y + 0');
            const followerRot = parseEquation('angle(bouncer.x, bouncer.y, mover.x, mover.y)');

            // Debug: Log parsing results
            if (!followerX.success) console.error('Failed to parse followerX:', followerX.error);
            if (!followerY.success) console.error('Failed to parse followerY:', followerY.error);
            if (!followerRot.success) console.error('Failed to parse followerRot:', followerRot.error);

            objects.set('follower', {
                id: 'follower',
                name: 'Follower',
                x: 480, y: 300,
                width: 40, height: 40,
                rotation: 0,
                red: 255, green: 200, blue: 50,
                opacity: 100,
                appearance: 'square',
                penDown: false,
                text: '',
                thicknessPen: 2,
                redColourPen: 255,
                greenColourPen: 200,
                blueColourPen: 50,
                opacityPen: 100,
                info: 'Follower demonstrates object references by following another object\'s position and rotating to point at a third object using the angle function.',
                equations: new Map([
                    ['x', {
                        attribute: 'x',
                        text: 'bouncer.x + 80',
                        expression: followerX.success ? followerX.expression : null,
                        cache: new Map()
                    }],
                    ['y', {
                        attribute: 'y',
                        text: 'bouncer.y + 0',
                        expression: followerY.success ? followerY.expression : null,
                        cache: new Map()
                    }],
                    ['rotation', {
                        attribute: 'rotation',
                        text: 'angle(bouncer.x, bouncer.y, mover.x, mover.y)',
                        expression: followerRot.success ? followerRot.expression : null,
                        cache: new Map()
                    }]
                ])
            });

            // Conditional triangle - demonstrates conditionals and new shapes
            const triangleX = parseEquation('if(t < 100, 100 + t * 2, 300)');
            const triangleY = parseEquation('if(dist(bouncer.x, bouncer.y, 400, 500) < 150, bouncer.y - 100, 500)');
            const triangleRot = parseEquation('t * 3');

            // Debug: Log parsing results
            if (!triangleX.success) console.error('Failed to parse triangleX:', triangleX.error);
            if (!triangleY.success) console.error('Failed to parse triangleY:', triangleY.error);
            if (!triangleRot.success) console.error('Failed to parse triangleRot:', triangleRot.error);

            objects.set('triangle1', {
                id: 'triangle1',
                name: 'Smart Triangle',
                x: 100, y: 500,
                width: 50, height: 50,
                rotation: 0,
                red: 150, green: 50, blue: 200,
                opacity: 100,
                appearance: 'triangle',
                penDown: false,
                text: '',
                thicknessPen: 2,
                redColourPen: 150,
                greenColourPen: 50,
                blueColourPen: 200,
                opacityPen: 100,
                info: 'Smart Triangle uses conditional logic to change behavior over time and respond to other objects\' positions using if and dist functions.',
                equations: new Map([
                    ['x', {
                        attribute: 'x',
                        text: 'if(t < 100, 100 + t * 2, 300)',
                        expression: triangleX.success ? triangleX.expression : null,
                        cache: new Map()
                    }],
                    ['y', {
                        attribute: 'y',
                        text: 'if(dist(bouncer.x, bouncer.y, 400, 500) < 150, bouncer.y - 100, 500)',
                        expression: triangleY.success ? triangleY.expression : null,
                        cache: new Map()
                    }],
                    ['rotation', {
                        attribute: 'rotation',
                        text: 't * 3',
                        expression: triangleRot.success ? triangleRot.expression : null,
                        cache: new Map()
                    }]
                ])
            });

            // Star with collision detection and variables
            const starX = parseEquation('centerX + cos(t * speed) * radius');
            const starY = parseEquation('centerY + sin(t * speed) * radius');
            const starRed = parseEquation('if(overlaps(star, bouncer), 255, 50)');
            const starRot = parseEquation('t * 10');

            // Debug: Log parsing results
            if (!starX.success) console.error('Failed to parse starX:', starX.error);
            if (!starY.success) console.error('Failed to parse starY:', starY.error);
            if (!starRed.success) console.error('Failed to parse starRed:', starRed.error);
            if (!starRot.success) console.error('Failed to parse starRot:', starRot.error);

            objects.set('star', {
                id: 'star',
                name: 'Collision Star',
                x: 500, y: 300,
                width: 60, height: 60,
                rotation: 0,
                red: 50, green: 255, blue: 200,
                opacity: 100,
                appearance: 'star',
                penDown: false,
                text: '',
                thicknessPen: 2,
                redColourPen: 50,
                greenColourPen: 255,
                blueColourPen: 200,
                opacityPen: 100,
                info: 'Collision Star moves in a circular orbit using user variables and changes color when overlapping with another object using the overlaps function.',
                equations: new Map([
                    ['x', {
                        attribute: 'x',
                        text: 'centerX + cos(t * speed) * radius',
                        expression: starX.success ? starX.expression : null,
                        cache: new Map()
                    }],
                    ['y', {
                        attribute: 'y',
                        text: 'centerY + sin(t * speed) * radius',
                        expression: starY.success ? starY.expression : null,
                        cache: new Map()
                    }],
                    ['red', {
                        attribute: 'red',
                        text: 'if(overlaps(star, bouncer), 255, 50)',
                        expression: starRed.success ? starRed.expression : null,
                        cache: new Map()
                    }],
                    ['rotation', {
                        attribute: 'rotation',
                        text: 't * 10',
                        expression: starRot.success ? starRot.expression : null,
                        cache: new Map()
                    }]
                ])
            });

            // Pentagon with random jitter - demonstrates random() function
            const pentX = parseEquation('300 + random(-5, 5)');
            const pentY = parseEquation('150 + random(-5, 5)');
            const pentRot = parseEquation('t * 2');
            const pentGreen = parseEquation('150 + random(0, 105)');

            objects.set('pentagon1', {
                id: 'pentagon1',
                name: 'Jittery Pentagon',
                x: 300, y: 150,
                width: 55, height: 55,
                rotation: 0,
                red: 255, green: 200, blue: 100,
                opacity: 100,
                appearance: 'pentagon',
                penDown: false,
                text: '',
                thicknessPen: 2,
                redColourPen: 255,
                greenColourPen: 200,
                blueColourPen: 100,
                opacityPen: 100,
                info: 'Jittery Pentagon demonstrates the random function by adding small random offsets to its position and color, creating a jittering effect.',
                equations: new Map([
                    ['x', {
                        attribute: 'x',
                        text: '300 + random(-5, 5)',
                        expression: pentX.success ? pentX.expression : null,
                        cache: new Map()
                    }],
                    ['y', {
                        attribute: 'y',
                        text: '150 + random(-5, 5)',
                        expression: pentY.success ? pentY.expression : null,
                        cache: new Map()
                    }],
                    ['rotation', {
                        attribute: 'rotation',
                        text: 't * 2',
                        expression: pentRot.success ? pentRot.expression : null,
                        cache: new Map()
                    }],
                    ['green', {
                        attribute: 'green',
                        text: '150 + random(0, 105)',
                        expression: pentGreen.success ? pentGreen.expression : null,
                        cache: new Map()
                    }]
                ])
            });

            // Hexagon with modulo looping - demonstrates mod() function
            const hexX = parseEquation('mod(t * 5, 700) + 50');
            const hexY = parseEquation('100');
            const hexBlue = parseEquation('mod(t * 10, 255)');

            objects.set('hexagon1', {
                id: 'hexagon1',
                name: 'Looping Hexagon',
                x: 50, y: 100,
                width: 50, height: 50,
                rotation: 0,
                red: 255, green: 100, blue: 150,
                opacity: 100,
                appearance: 'hexagon',
                penDown: false,
                text: '',
                thicknessPen: 2,
                redColourPen: 255,
                greenColourPen: 100,
                blueColourPen: 150,
                opacityPen: 100,
                info: 'Looping Hexagon uses the modulo function to create a repeating horizontal motion and cycling blue color value.',
                equations: new Map([
                    ['x', {
                        attribute: 'x',
                        text: 'mod(t * 5, 700) + 50',
                        expression: hexX.success ? hexX.expression : null,
                        cache: new Map()
                    }],
                    ['y', {
                        attribute: 'y',
                        text: '100',
                        expression: hexY.success ? hexY.expression : null,
                        cache: new Map()
                    }],
                    ['blue', {
                        attribute: 'blue',
                        text: 'mod(t * 10, 255)',
                        expression: hexBlue.success ? hexBlue.expression : null,
                        cache: new Map()
                    }]
                ])
            });

            // Circle with exponential scaling - demonstrates pow() and pi constant
            const expX = parseEquation('650');
            const expY = parseEquation('450');
            const expWidth = parseEquation('20 + pow(1.05, t / 5)');
            const expRot = parseEquation('t * pi');

            objects.set('expCircle', {
                id: 'expCircle',
                name: 'Growing Circle',
                x: 650, y: 450,
                width: 40, height: 40,
                rotation: 0,
                red: 100, green: 200, blue: 255,
                opacity: 100,
                appearance: 'circle',
                penDown: false,
                text: '',
                thicknessPen: 2,
                redColourPen: 100,
                greenColourPen: 200,
                blueColourPen: 255,
                opacityPen: 100,
                info: 'Growing Circle demonstrates exponential growth using the pow function and the mathematical constant pi for rotation.',
                equations: new Map([
                    ['x', {
                        attribute: 'x',
                        text: '650',
                        expression: expX.success ? expX.expression : null,
                        cache: new Map()
                    }],
                    ['y', {
                        attribute: 'y',
                        text: '450',
                        expression: expY.success ? expY.expression : null,
                        cache: new Map()
                    }],
                    ['width', {
                        attribute: 'width',
                        text: '20 + pow(1.05, t / 5)',
                        expression: expWidth.success ? expWidth.expression : null,
                        cache: new Map()
                    }],
                    ['rotation', {
                        attribute: 'rotation',
                        text: 't * pi',
                        expression: expRot.success ? expRot.expression : null,
                        cache: new Map()
                    }]
                ])
            });

            // Smooth Ease Ellipse - demonstrates smoothstep easing
            const easeX = parseEquation('100 + smoothstep(0, 100, mod(t, 100)) * 500');
            const easeY = parseEquation('250');
            const easeRot = parseEquation('t * 3');

            objects.set('smoothEase', {
                id: 'smoothEase',
                name: 'Smooth Easer',
                x: 100, y: 250,
                width: 45, height: 30,
                rotation: 0,
                red: 150, green: 255, blue: 150,
                opacity: 100,
                appearance: 'ellipse',
                penDown: false,
                text: '',
                thicknessPen: 2,
                redColourPen: 150,
                greenColourPen: 255,
                blueColourPen: 150,
                opacityPen: 100,
                info: 'Smooth Easer demonstrates the smoothstep easing function for smooth, natural-looking motion with acceleration and deceleration.',
                equations: new Map([
                    ['x', {
                        attribute: 'x',
                        text: '100 + smoothstep(0, 100, mod(t, 100)) * 500',
                        expression: easeX.success ? easeX.expression : null,
                        cache: new Map()
                    }],
                    ['y', {
                        attribute: 'y',
                        text: '250',
                        expression: easeY.success ? easeY.expression : null,
                        cache: new Map()
                    }],
                    ['rotation', {
                        attribute: 'rotation',
                        text: 't * 3',
                        expression: easeRot.success ? easeRot.expression : null,
                        cache: new Map()
                    }]
                ])
            });

            // Bounce Rounded Rect - demonstrates bounce easing
            const bounceX = parseEquation('200');
            const bounceY = parseEquation('100 + bounce(mod(t / 60, 1)) * 400');
            const bounceHeight = parseEquation('50 + bounce(mod(t / 60, 1)) * 20');

            objects.set('bouncer', {
                id: 'bouncer',
                name: 'Bouncer',
                x: 200, y: 500,
                width: 60, height: 40,
                rotation: 0,
                red: 255, green: 180, blue: 100,
                opacity: 100,
                appearance: 'roundrect',
                penDown: false,
                text: '',
                thicknessPen: 2,
                redColourPen: 255,
                greenColourPen: 180,
                blueColourPen: 100,
                opacityPen: 100,
                info: 'Bouncer demonstrates the bounce easing function to create realistic bouncing motion with squash and stretch effects.',
                equations: new Map([
                    ['x', {
                        attribute: 'x',
                        text: '200',
                        expression: bounceX.success ? bounceX.expression : null,
                        cache: new Map()
                    }],
                    ['y', {
                        attribute: 'y',
                        text: '100 + bounce(mod(t / 60, 1)) * 400',
                        expression: bounceY.success ? bounceY.expression : null,
                        cache: new Map()
                    }],
                    ['height', {
                        attribute: 'height',
                        text: '50 + bounce(mod(t / 60, 1)) * 20',
                        expression: bounceHeight.success ? bounceHeight.expression : null,
                        cache: new Map()
                    }]
                ])
            });

            // Mouse Follower - demonstrates mouse.x and mouse.y
            const mouseFollowerX = parseEquation('mouse.x');
            const mouseFollowerY = parseEquation('mouse.y');
            const mouseFollowerRot = parseEquation('t * 8');
            const mouseFollowerSize = parseEquation('30 + sin(t * 5) * 10');

            objects.set('mouseFollower', {
                id: 'mouseFollower',
                name: 'Mouse Follower',
                x: 400, y: 300,
                width: 30, height: 30,
                rotation: 0,
                red: 255, green: 50, blue: 150,
                opacity: 80,
                appearance: 'star',
                penDown: true,
                text: '',
                thicknessPen: 1,
                redColourPen: 255,
                greenColourPen: 100,
                blueColourPen: 200,
                opacityPen: 50,
                info: 'Mouse Follower tracks the mouse cursor position using mouse.x and mouse.y, creating an interactive drawing trail with pen.',
                equations: new Map([
                    ['x', {
                        attribute: 'x',
                        text: 'mouse.x',
                        expression: mouseFollowerX.success ? mouseFollowerX.expression : null,
                        cache: new Map()
                    }],
                    ['y', {
                        attribute: 'y',
                        text: 'mouse.y',
                        expression: mouseFollowerY.success ? mouseFollowerY.expression : null,
                        cache: new Map()
                    }],
                    ['rotation', {
                        attribute: 'rotation',
                        text: 't * 8',
                        expression: mouseFollowerRot.success ? mouseFollowerRot.expression : null,
                        cache: new Map()
                    }],
                    ['width', {
                        attribute: 'width',
                        text: '30 + sin(t * 5) * 10',
                        expression: mouseFollowerSize.success ? mouseFollowerSize.expression : null,
                        cache: new Map()
                    }]
                ])
            });

            // Keyboard controlled object - demonstrates keyDown()
            const keyObjX = parseEquation('400 + keyDown(d) * 150 - keyDown(a) * 150');
            const keyObjY = parseEquation('300 + keyDown(s) * 100 - keyDown(w) * 100');

            objects.set('keyboardObj', {
                id: 'keyboardObj',
                name: 'Keyboard Control',
                x: 400, y: 300,
                width: 50, height: 50,
                rotation: 0,
                red: 100, green: 150, blue: 255,
                opacity: 100,
                appearance: 'square',
                penDown: false,
                text: '',
                thicknessPen: 3,
                redColourPen: 100,
                greenColourPen: 150,
                blueColourPen: 255,
                opacityPen: 100,
                info: 'Keyboard Control responds to keyboard input using the keyDown() function, allowing WASD movement for 4-directional control.',
                equations: new Map([
                    ['x', {
                        attribute: 'x',
                        text: '400 + keyDown(d) * 150 - keyDown(a) * 150',
                        description: 'Left/right movement with A/D keys',
                        expression: keyObjX.success ? keyObjX.expression : null,
                        cache: new Map()
                    }],
                    ['y', {
                        attribute: 'y',
                        text: '300 + keyDown(s) * 100 - keyDown(w) * 100',
                        description: 'Up/down movement with W/S keys',
                        expression: keyObjY.success ? keyObjY.expression : null,
                        cache: new Map()
                    }]
                ])
            });

            // Physics Ball - demonstrates prev.x for velocity-based motion with gravity (y-up coordinate system)
            const physicsX = parseEquation('prev.x + 2');
            const physicsY = parseEquation('if(prev.y + prev.vy < 50, 50 - (prev.y + prev.vy - 50) * 0.8, prev.y + prev.vy)');
            const physicsVy = parseEquation('if(prev.y + prev.vy < 50, prev.vy * -0.8, prev.vy - 0.5)');

            // Debug: Log parsing results
            if (!physicsX.success) console.error('Failed to parse physicsX:', physicsX.error);
            if (!physicsY.success) console.error('Failed to parse physicsY:', physicsY.error);
            if (!physicsVy.success) console.error('Failed to parse physicsVy:', physicsVy.error);

            objects.set('physicsBall', {
                id: 'physicsBall',
                name: 'Physics Ball',
                x: 100, y: 500,
                width: 40, height: 40,
                rotation: 0,
                red: 255, green: 100, blue: 50,
                opacity: 100,
                appearance: 'circle',
                penDown: true,
                text: '',
                thicknessPen: 2,
                redColourPen: 255,
                greenColourPen: 150,
                blueColourPen: 100,
                opacityPen: 100,
                info: 'Physics Ball simulates realistic physics with gravity and bouncing using prev values to track velocity, demonstrating frame-to-frame state persistence.',
                vy: 0,  // Custom property for vertical velocity
                equations: new Map([
                    ['x', {
                        attribute: 'x',
                        text: 'prev.x + 2',
                        expression: physicsX.success ? physicsX.expression : null,
                        cache: new Map()
                    }],
                    ['y', {
                        attribute: 'y',
                        text: 'if(prev.y + prev.vy < 50, 50 - (prev.y + prev.vy - 50) * 0.8, prev.y + prev.vy)',
                        expression: physicsY.success ? physicsY.expression : null,
                        cache: new Map()
                    }],
                    ['vy', {
                        attribute: 'vy',
                        text: 'if(prev.y + prev.vy < 50, prev.vy * -0.8, prev.vy - 0.5)',
                        expression: physicsVy.success ? physicsVy.expression : null,
                        cache: new Map()
                    }]
                ])
            });

            // ========== PONG GAME ==========
            // Left paddle controlled by W/S keys
            const pongLeftY = parseEquation('clamp(prev.y + keyDown(w) * PaddleSpeed - keyDown(s) * PaddleSpeed, 60, 540)');

            objects.set('pongLeft', {
                id: 'pongLeft',
                name: 'Pong Left Paddle',
                x: 50, y: 300,
                width: 15, height: 80,
                rotation: 0,
                red: 100, green: 200, blue: 255,
                opacity: 100,
                appearance: 'roundrect',
                penDown: false,
                text: '',
                thicknessPen: 2,
                redColourPen: 100,
                greenColourPen: 200,
                blueColourPen: 255,
                opacityPen: 100,
                info: 'Pong left paddle controlled by W/S keys. Uses prev.y and PaddleSpeed custom property.',
                PaddleSpeed: 5,
                equations: new Map([
                    ['y', {
                        attribute: 'y',
                        text: 'clamp(prev.y + keyDown(w) * PaddleSpeed - keyDown(s) * PaddleSpeed, 60, 540)',
                        description: 'Keyboard control with boundary clamping using prev.y',
                        expression: pongLeftY.success ? pongLeftY.expression : null,
                        cache: new Map()
                    }]
                ])
            });

            // Right paddle controlled by Up/Down arrow keys
            const pongRightY = parseEquation('clamp(prev.y + keyDown(ArrowUp) * PaddleSpeed - keyDown(ArrowDown) * PaddleSpeed, 60, 540)');

            objects.set('pongRight', {
                id: 'pongRight',
                name: 'Pong Right Paddle',
                x: 750, y: 300,
                width: 15, height: 80,
                rotation: 0,
                red: 255, green: 100, blue: 100,
                opacity: 100,
                appearance: 'roundrect',
                penDown: false,
                text: '',
                thicknessPen: 2,
                redColourPen: 255,
                greenColourPen: 100,
                blueColourPen: 100,
                opacityPen: 100,
                info: 'Pong right paddle controlled by Arrow Up/Down keys. Uses prev.y and PaddleSpeed custom property.',
                PaddleSpeed: 5,
                equations: new Map([
                    ['y', {
                        attribute: 'y',
                        text: 'clamp(prev.y + keyDown(ArrowUp) * PaddleSpeed - keyDown(ArrowDown) * PaddleSpeed, 60, 540)',
                        description: 'Keyboard control with boundary clamping using prev.y',
                        expression: pongRightY.success ? pongRightY.expression : null,
                        cache: new Map()
                    }]
                ])
            });

            // Pong ball with physics (using nested ifs instead of && and ||)
            const pongBallVx = parseEquation('if(t == 0, 3, if(prev.x + prev.vx < 35, if(overlaps(pongBall, pongLeft), abs(prev.vx) * 1.05, prev.vx), if(prev.x + prev.vx > 765, if(overlaps(pongBall, pongRight), -abs(prev.vx) * 1.05, prev.vx), if(prev.x + prev.vx < 15, 3, if(prev.x + prev.vx > 785, 3, prev.vx)))))');
            const pongBallVy = parseEquation('if(t == 0, 2, if(prev.y + prev.vy < 20, prev.vy * -1, if(prev.y + prev.vy > 580, prev.vy * -1, if(overlaps(pongBall, pongLeft), prev.vy + random(-1, 1), if(overlaps(pongBall, pongRight), prev.vy + random(-1, 1), prev.vy)))))');
            const pongBallX = parseEquation('if(prev.x + prev.vx < 35, if(overlaps(pongBall, pongLeft), 35, if(prev.x + prev.vx < 15, 400, prev.x + prev.vx)), if(prev.x + prev.vx > 765, if(overlaps(pongBall, pongRight), 765, if(prev.x + prev.vx > 785, 400, prev.x + prev.vx)), prev.x + prev.vx))');
            const pongBallY = parseEquation('if(prev.y + prev.vy < 20, clamp(prev.y, 20, 580), if(prev.y + prev.vy > 580, clamp(prev.y, 20, 580), if(prev.x + prev.vx < 15, 300, if(prev.x + prev.vx > 785, 300, prev.y + prev.vy))))');

            objects.set('pongBall', {
                id: 'pongBall',
                name: 'Pong Ball',
                x: 400, y: 300,
                width: 15, height: 15,
                rotation: 0,
                red: 255, green: 255, blue: 100,
                opacity: 100,
                appearance: 'circle',
                penDown: true,
                text: '',
                thicknessPen: 1,
                redColourPen: 200,
                greenColourPen: 200,
                blueColourPen: 200,
                opacityPen: 30,
                info: 'Pong ball with physics: bounces off paddles and walls, uses overlaps() for collision, prev.vx/vy for velocity. Resets if it goes past paddles.',
                vx: 3,  // Initial velocity
                vy: 2,
                equations: new Map([
                    ['vx', {
                        attribute: 'vx',
                        text: 'if(t == 0, 3, if(prev.x + prev.vx < 35, if(overlaps(pongBall, pongLeft), abs(prev.vx) * 1.05, prev.vx), if(prev.x + prev.vx > 765, if(overlaps(pongBall, pongRight), -abs(prev.vx) * 1.05, prev.vx), if(prev.x + prev.vx < 15, 3, if(prev.x + prev.vx > 785, 3, prev.vx)))))',
                        description: 'Horizontal velocity with bounce and speed increase',
                        expression: pongBallVx.success ? pongBallVx.expression : null,
                        cache: new Map()
                    }],
                    ['vy', {
                        attribute: 'vy',
                        text: 'if(t == 0, 2, if(prev.y + prev.vy < 20, prev.vy * -1, if(prev.y + prev.vy > 580, prev.vy * -1, if(overlaps(pongBall, pongLeft), prev.vy + random(-1, 1), if(overlaps(pongBall, pongRight), prev.vy + random(-1, 1), prev.vy)))))',
                        description: 'Vertical velocity with bounce and paddle spin effect',
                        expression: pongBallVy.success ? pongBallVy.expression : null,
                        cache: new Map()
                    }],
                    ['x', {
                        attribute: 'x',
                        text: 'if(prev.x + prev.vx < 35, if(overlaps(pongBall, pongLeft), 35, if(prev.x + prev.vx < 15, 400, prev.x + prev.vx)), if(prev.x + prev.vx > 765, if(overlaps(pongBall, pongRight), 765, if(prev.x + prev.vx > 785, 400, prev.x + prev.vx)), prev.x + prev.vx))',
                        description: 'Ball movement with paddle collision and reset',
                        expression: pongBallX.success ? pongBallX.expression : null,
                        cache: new Map()
                    }],
                    ['y', {
                        attribute: 'y',
                        text: 'if(prev.y + prev.vy < 20, clamp(prev.y, 20, 580), if(prev.y + prev.vy > 580, clamp(prev.y, 20, 580), if(prev.x + prev.vx < 15, 300, if(prev.x + prev.vx > 785, 300, prev.y + prev.vy))))',
                        description: 'Ball bounces off top and bottom walls',
                        expression: pongBallY.success ? pongBallY.expression : null,
                        cache: new Map()
                    }]
                ])
            });

            // Center line (decorative)
            objects.set('pongCenter', {
                id: 'pongCenter',
                name: 'Pong Center Line',
                x: 400, y: 300,
                width: 4, height: 600,
                rotation: 0,
                red: 100, green: 100, blue: 100,
                opacity: 30,
                appearance: 'roundrect',
                penDown: false,
                text: '',
                thicknessPen: 2,
                redColourPen: 100,
                greenColourPen: 100,
                blueColourPen: 100,
                opacityPen: 100,
                info: 'Pong center line for visual reference.',
                equations: new Map()
            });

            animationController = new AnimationController((frame) => {
                renderFrame(frame);
                updateFrameDisplay(frame);
                // Update property panel during playback if an object is selected
                if (selectedObjectId) {
                    updatePropertyPanel();
                }
            }, 30);

            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);

            // Set up some demo variables
            userVariables.set('speed', 3);
            userVariables.set('radius', 100);
            userVariables.set('centerX', 400);
            userVariables.set('centerY', 300);

            // Initialize previousFrameValues with initial object states
            objects.forEach(obj => {
                const prevValues = { ...obj };
                // Remove non-property fields
                delete prevValues.id;
                delete prevValues.name;
                delete prevValues.appearance;
                delete prevValues.penDown;
                delete prevValues.text;
                delete prevValues.equations;
                previousFrameValues.set(obj.id, prevValues);
            });

            // Save initial state
            saveHistoryState();

            updateVariablesList();
            updateObjectList();
            updatePropertyPanel();
            updateHistoryUI();
            renderFrame(0);
        }

        function handleMouseDown(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            // Convert y-coordinate to match inverted axis (y=0 at bottom, increases upward)
            const y = canvas.height - (event.clientY - rect.top);

            const objectsArray = Array.from(objects.values()).reverse();
            const currentFrame = animationController.currentFrame;

            for (const obj of objectsArray) {
                const updated = updateObjectAtTime(obj, currentFrame, objects);
                if (hitTest(x, y, updated)) {
                    selectedObjectId = obj.id;
                    updateObjectList();
                    updatePropertyPanel();
                    isDragging = true;
                    dragOffsetX = updated.x - x;
                    dragOffsetY = updated.y - y;
                    canvas.classList.add('dragging');
                    renderFrame(currentFrame);
                    return;
                }
            }

            selectedObjectId = null;
            updateObjectList();
            updatePropertyPanel();
            renderFrame(currentFrame);
        }

        function handleMouseMove(event) {
            const rect = canvas.getBoundingClientRect();
            let x = event.clientX - rect.left;
            // Convert y-coordinate to match inverted axis (y=0 at bottom, increases upward)
            let y = canvas.height - (event.clientY - rect.top);

            // Always track mouse position for mouse.x and mouse.y in equations
            mouseX = x;
            mouseY = y;

            // Force re-render if playing to update objects using mouse.x/mouse.y
            if (isPlaying) {
                renderFrame(animationController.currentFrame);
            }

            if (!isDragging || !selectedObjectId) return;

            const obj = objects.get(selectedObjectId);
            let newX = x + dragOffsetX;
            let newY = y + dragOffsetY;

            // Apply grid snap if Shift is pressed
            if (isShiftPressed) {
                newX = Math.round(newX / GRID_SIZE) * GRID_SIZE;
                newY = Math.round(newY / GRID_SIZE) * GRID_SIZE;
            }

            obj.x = newX;
            obj.y = newY;

            // Clear x and y equations when manually dragging
            // Dragging is an explicit override of position
            if (obj.equations.has('x')) {
                obj.equations.delete('x');
            }
            if (obj.equations.has('y')) {
                obj.equations.delete('y');
            }

            obj.equations.forEach(eq => eq.cache.clear());

            updatePropertyPanel();

            // During dragging, render directly without evaluating equations
            // This prevents equations from overriding the dragged position
            const trails = trailManager.getAllTrails();
            const objectsArray = Array.from(objects.values());
            renderer.renderScene(objectsArray, trails, selectedObjectId);
        }

        function handleMouseUp(event) {
            if (isDragging) {
                saveHistoryState();
            }
            isDragging = false;
            canvas.classList.remove('dragging');
        }

        function handleKeyDown(event) {
            if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') return;

            // CRITICAL: Prevent Space from activating focused buttons (e.g., Play button)
            // This must happen BEFORE any other processing
            if (event.key === ' ') {
                event.preventDefault();
            }

            // Prevent arrow keys from scrolling the page
            if (event.key === 'ArrowUp' || event.key === 'ArrowDown' || event.key === 'ArrowLeft' || event.key === 'ArrowRight') {
                event.preventDefault();
            }

            // Always track all key presses for keyDown() function in equations
            const key = event.key.toLowerCase();
            keysPressed.add(key);

            // Clear all equation caches since keyboard state changed
            let cacheCount = 0;
            objects.forEach(obj => {
                if (obj.equations) {
                    obj.equations.forEach(eq => {
                        eq.cache.clear();
                        cacheCount++;
                    });
                }
            });

            // Force re-render if playing to update objects using keyDown()
            if (isPlaying) {
                renderFrame(animationController.currentFrame);
            }

            // Always track Shift key for grid snap
            if (event.key === 'Shift') {
                isShiftPressed = true;
                document.getElementById('gridSnapIndicator').classList.add('active');
            }

            // Only process keyboard shortcuts if enabled
            if (!keyboardShortcutsEnabled) {
                return;
            }

            // Ctrl+Z for undo
            if (event.ctrlKey && event.key === 'z') {
                event.preventDefault();
                undo();
                return;
            }

            // Ctrl+Y for redo
            if (event.ctrlKey && event.key === 'y') {
                event.preventDefault();
                redo();
                return;
            }

            // Arrow keys - if object selected, nudge it; otherwise control animation
            if (event.key.startsWith('Arrow') && selectedObjectId) {
                event.preventDefault();
                nudgeSelectedObject(event.key, event.shiftKey);
                return;
            }

            switch(event.key) {
                case ' ':
                    event.preventDefault();
                    togglePlay();
                    break;
                case 'ArrowRight':
                    event.preventDefault();
                    stepForward();
                    break;
                case 'ArrowLeft':
                    event.preventDefault();
                    stepBackward();
                    break;
                case 'ArrowUp':
                case 'ArrowDown':
                    // Allow default if no object selected (handled above)
                    break;
                case 'Home':
                    event.preventDefault();
                    resetAnimation();
                    break;
                case 'Delete':
                    event.preventDefault();
                    deleteSelectedObject();
                    break;
                case 'p':
                case 'P':
                    event.preventDefault();
                    togglePen();
                    break;
                case 'c':
                case 'C':
                    event.preventDefault();
                    copySelectedObject();
                    break;
                case '[':
                    event.preventDefault();
                    sendToBack();
                    break;
                case ']':
                    event.preventDefault();
                    bringToFront();
                    break;
            }
        }

        function handleKeyUp(event) {
            // Remove from tracked keys
            const key = event.key.toLowerCase();
            keysPressed.delete(key);

            // Clear all equation caches since keyboard state changed
            objects.forEach(obj => {
                if (obj.equations) {
                    obj.equations.forEach(eq => eq.cache.clear());
                }
            });

            // Force re-render if playing to update objects using keyDown()
            if (isPlaying) {
                renderFrame(animationController.currentFrame);
            }

            if (event.key === 'Shift') {
                isShiftPressed = false;
                document.getElementById('gridSnapIndicator').classList.remove('active');
            }
        }

        function hitTest(x, y, obj) {
            const dx = x - obj.x;
            const dy = y - obj.y;
            const angle = -obj.rotation * Math.PI / 180;
            const rotatedX = dx * Math.cos(angle) - dy * Math.sin(angle);
            const rotatedY = dx * Math.sin(angle) + dy * Math.cos(angle);

            if (obj.appearance === 'square' || obj.appearance === 'roundrect') {
                return Math.abs(rotatedX) <= obj.width/2 && Math.abs(rotatedY) <= obj.height/2;
            } else if (obj.appearance === 'circle' || obj.appearance === 'ellipse') {
                const normalizedX = rotatedX / (obj.width/2);
                const normalizedY = rotatedY / (obj.height/2);
                return (normalizedX * normalizedX + normalizedY * normalizedY) <= 1;
            } else if (obj.appearance === 'triangle') {
                // Simple bounding box for triangle
                return Math.abs(rotatedX) <= obj.width/2 && Math.abs(rotatedY) <= obj.height/2;
            } else if (obj.appearance === 'star' || obj.appearance === 'pentagon' || obj.appearance === 'hexagon') {
                // Elliptical hit test for polygons with independent width/height
                const normalizedX = rotatedX / (obj.width/2);
                const normalizedY = rotatedY / (obj.height/2);
                return (normalizedX * normalizedX + normalizedY * normalizedY) <= 1;
            } else if (obj.appearance === 'line' || obj.appearance === 'arrow') {
                // Hit test for line - check if within width and height tolerance
                return Math.abs(rotatedX) <= obj.width/2 && Math.abs(rotatedY) <= 10;
            } else if (obj.appearance === 'text') {
                // Use obj.width and obj.height for consistent hit testing
                return Math.abs(rotatedX) <= obj.width/2 && Math.abs(rotatedY) <= obj.height/2;
            }
            return false;
        }

        function nudgeSelectedObject(key, shiftKey) {
            if (!selectedObjectId) return;

            const obj = objects.get(selectedObjectId);
            const amount = shiftKey ? 10 : 1;

            switch (key) {
                case 'ArrowUp':
                    obj.y -= amount;
                    break;
                case 'ArrowDown':
                    obj.y += amount;
                    break;
                case 'ArrowLeft':
                    obj.x -= amount;
                    break;
                case 'ArrowRight':
                    obj.x += amount;
                    break;
            }

            updatePropertyPanel();
            renderFrame(animationController.currentFrame);
        }

        function bringToFront() {
            if (!selectedObjectId) return;

            const obj = objects.get(selectedObjectId);
            objects.delete(selectedObjectId);
            objects.set(selectedObjectId, obj);

            saveHistoryState();
            renderFrame(animationController.currentFrame);
        }

        function sendToBack() {
            if (!selectedObjectId) return;

            const obj = objects.get(selectedObjectId);
            const allEntries = Array.from(objects.entries());
            objects.clear();

            // Add selected object first (back)
            objects.set(selectedObjectId, obj);

            // Add all others
            allEntries.forEach(([id, o]) => {
                if (id !== selectedObjectId) {
                    objects.set(id, o);
                }
            });

            saveHistoryState();
            renderFrame(animationController.currentFrame);
        }

        // ==================== Variables Management ====================

        function updateVariablesList() {
            const listEl = document.getElementById('variablesList');
            if (userVariables.size === 0) {
                listEl.innerHTML = '<div style="font-size: 11px; color: #999; font-style: italic;">No variables defined</div>';
                return;
            }

            listEl.innerHTML = '';
            userVariables.forEach((value, name) => {
                const div = document.createElement('div');
                div.style.cssText = 'display: flex; align-items: center; gap: 5px; margin: 5px 0; padding: 5px; background: white; border-radius: 4px; font-size: 12px;';
                div.innerHTML = `
                    <span style="font-weight: 600; font-family: monospace; white-space: nowrap;">${name}</span>
                    <span style="flex: 1; color: #667eea; font-family: monospace; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${value}</span>
                    <button onclick="deleteVariable('${name}')" style="padding: 2px 6px; font-size: 11px; background: #dc3545; flex-shrink: 0;">√ó</button>
                `;
                listEl.appendChild(div);
            });
        }

        function addVariable() {
            const nameInput = document.getElementById('varName');
            const valueInput = document.getElementById('varValue');
            const name = nameInput.value.trim();
            const value = parseFloat(valueInput.value);

            if (!name || isNaN(value)) {
                alert('Please enter a valid variable name and numeric value');
                return;
            }

            if (name === 't' || name.includes('.')) {
                alert('Reserved variable name. Cannot use "t" or names with dots.');
                return;
            }

            userVariables.set(name, value);
            nameInput.value = '';
            valueInput.value = '';

            // Clear all equation caches since variables changed
            objects.forEach(obj => {
                obj.equations.forEach(eq => eq.cache.clear());
            });

            updateVariablesList();
            renderFrame(animationController.currentFrame);
        }

        function deleteVariable(name) {
            userVariables.delete(name);

            // Clear all equation caches
            objects.forEach(obj => {
                obj.equations.forEach(eq => eq.cache.clear());
            });

            updateVariablesList();
            renderFrame(animationController.currentFrame);
        }

        // ==================== Object List ====================

        function updateObjectList() {
            const listEl = document.getElementById('objectList');
            listEl.innerHTML = '';

            objects.forEach(obj => {
                const li = document.createElement('li');
                li.className = 'object-item' + (obj.id === selectedObjectId ? ' selected' : '');
                li.onclick = () => selectObject(obj.id);

                // Make droppable for equation drag-and-drop
                li.ondragover = (e) => {
                    e.preventDefault();
                    li.style.background = '#e3f2fd';
                };
                li.ondragleave = () => {
                    li.style.background = '';
                };
                li.ondrop = (e) => {
                    e.preventDefault();
                    li.style.background = '';
                    handleEquationDrop(e, obj.id);
                };

                // Create miniature shape based on appearance type
                let shapeIcon = '';
                const color = `rgb(${obj.red}, ${obj.green}, ${obj.blue})`;

                switch(obj.appearance) {
                    case 'circle':
                        shapeIcon = `<span style="display: inline-block; width: 12px; height: 12px; background: ${color}; border-radius: 50%;"></span>`;
                        break;
                    case 'square':
                        shapeIcon = `<span style="display: inline-block; width: 12px; height: 12px; background: ${color};"></span>`;
                        break;
                    case 'triangle':
                        shapeIcon = `<span style="display: inline-block; color: ${color}; font-size: 12px; line-height: 12px;">‚ñ≤</span>`;
                        break;
                    case 'star':
                        shapeIcon = `<span style="display: inline-block; color: ${color}; font-size: 12px; line-height: 12px;">‚òÖ</span>`;
                        break;
                    case 'hexagon':
                        shapeIcon = `<span style="display: inline-block; color: ${color}; font-size: 12px; line-height: 12px;">‚¨°</span>`;
                        break;
                    case 'line':
                        shapeIcon = `<span style="display: inline-block; width: 12px; height: 2px; background: ${color};"></span>`;
                        break;
                    case 'arrow':
                        shapeIcon = `<span style="display: inline-block; color: ${color}; font-size: 12px; line-height: 12px;">‚Üí</span>`;
                        break;
                    case 'text':
                        shapeIcon = `<span style="display: inline-block; color: ${color}; font-size: 12px; font-weight: bold; line-height: 12px;">A</span>`;
                        break;
                    default:
                        shapeIcon = `<span style="display: inline-block; width: 12px; height: 12px; background: ${color}; border-radius: 2px;"></span>`;
                }

                li.innerHTML = `
                    ${shapeIcon}
                    <div style="flex: 1;">
                        <div class="object-name">${obj.name}</div>
                        <div class="object-type">${obj.appearance} ${obj.penDown ? '‚úèÔ∏è' : ''}</div>
                    </div>
                    <button onclick="event.stopPropagation(); showObjectInfo('${obj.id}')" style="padding: 4px 8px; font-size: 11px; background: #667eea; color: white; border: none; border-radius: 3px; cursor: pointer;" title="Show info">‚ÑπÔ∏è</button>
                `;
                listEl.appendChild(li);
            });
        }

        function showObjectInfo(id) {
            const obj = objects.get(id);
            if (!obj) return;

            let info = `Object: ${obj.name}\n`;

            // Show description if it exists
            if (obj.description) {
                info += `\nDescription:\n${obj.description}\n`;
            } else if (obj.info) {
                info += `\nDescription:\n${obj.info}\n`;
            }

            info += `\nType: ${obj.appearance}\n`;
            info += `Position: (${Math.round(obj.x)}, ${Math.round(obj.y)})\n`;
            info += `Size: ${Math.round(obj.width)} √ó ${Math.round(obj.height)}\n`;
            info += `Color: RGB(${obj.red}, ${obj.green}, ${obj.blue})\n`;
            if (obj.rotation) info += `Rotation: ${Math.round(obj.rotation)}¬∞\n`;
            if (obj.penDown) info += `Pen: ON (thickness ${obj.thicknessPen})\n`;

            // Show equations if any
            if (obj.equations.size > 0) {
                info += `\nEquations:\n`;
                obj.equations.forEach((eq, prop) => {
                    info += `  ${prop} = ${eq.text}\n`;
                });
            }

            alert(info);
        }

        function selectObject(id) {
            selectedObjectId = id;
            updateObjectList();
            updatePropertyPanel();
            renderFrame(animationController.currentFrame);
        }

        // ==================== Property Panel ====================

        function updatePropertyPanel() {
            const panel = document.getElementById('propertyPanel');

            if (!selectedObjectId) {
                panel.className = 'property-panel empty';
                panel.innerHTML = 'Select an object to edit properties';
                return;
            }

            const obj = objects.get(selectedObjectId);
            panel.className = 'property-panel';

            const rgbToHex = (r, g, b) => {
                // Handle undefined values (for objects created before pen properties)
                r = r !== undefined ? r : 0;
                g = g !== undefined ? g : 0;
                b = b !== undefined ? b : 0;
                return '#' + [r, g, b].map(x => {
                    const hex = Math.round(x).toString(16);
                    return hex.length === 1 ? '0' + hex : hex;
                }).join('');
            };

            const propertyRow = (prop, label, min, max, unit = '') => {
                const eqText = getEquationText(obj, prop);
                const hasEq = eqText !== null;
                const eqDesc = hasEq && obj.equations.has(prop) ? obj.equations.get(prop).description : '';
                // Display rotation mod 360 for better readability
                const displayValue = prop === 'rotation' ? Math.round(((obj[prop] % 360) + 360) % 360) : Math.round(obj[prop]);
                const dragHandleHtml = hasEq ? `<span style="cursor: grab; margin-right: 3px; user-select: none;" title="Drag to copy equation">‚ãÆ‚ãÆ</span>` : '';
                return `
                    <div class="property-row">
                        <label>${label}: <span class="value-display">${displayValue}${unit}</span></label>
                        ${hasEq ? `<div
                            draggable="true"
                            ondragstart="handleEquationDragStart(event, '${obj.id}', '${prop}')"
                            style="font-size: 11px; color: #667eea; margin: 3px 0; font-family: 'Courier New', monospace; cursor: grab; padding: 2px; border-radius: 3px;"
                            onmouseenter="this.style.background='#f0f0ff'"
                            onmouseleave="this.style.background=''"
                        >${dragHandleHtml}üìê ${eqText}</div>` : ''}
                        ${hasEq && eqDesc ? `<div style="font-size: 10px; color: #6c757d; margin: 2px 0 3px 0; font-style: italic;">${eqDesc}</div>` : ''}
                        <div style="display: flex; gap: 5px; align-items: center;">
                            <input type="range" min="${min}" max="${max}" value="${obj[prop]}" oninput="updateProperty('${prop}', this.value)" style="flex: 1;" ${hasEq ? 'disabled' : ''}>
                            <input type="number" min="${min}" max="${max}" value="${Math.round(obj[prop])}" onchange="updateProperty('${prop}', this.value)" style="width: 60px; padding: 4px; border: 1px solid #ccc; border-radius: 4px; text-align: center;" ${hasEq ? 'disabled' : ''}>
                            <button onclick="openEquationEditor('${prop}')" style="padding: 4px 8px; font-size: 11px;" title="Edit equation">üìê</button>
                            ${hasEq ? `<button onclick="clearEquation('${prop}')" class="danger" style="padding: 4px 8px; font-size: 11px;" title="Clear equation">‚úï</button>` : ''}
                        </div>
                    </div>
                `;
            };

            const renderCustomProperties = (obj) => {
                // List of standard properties that are already displayed
                const standardProps = new Set([
                    'x', 'y', 'width', 'height', 'rotation',
                    'red', 'green', 'blue', 'opacity',
                    'thicknessPen', 'redColourPen', 'greenColourPen', 'blueColourPen', 'opacityPen'
                ]);

                // Find custom properties (those with equations that aren't standard)
                const customProps = [];
                obj.equations.forEach((eq, prop) => {
                    if (!standardProps.has(prop)) {
                        customProps.push({ name: prop, text: eq.text || 'Legacy equation' });
                    }
                });

                if (customProps.length === 0) {
                    return '';
                }

                // Render custom properties section
                const customPropsHtml = customProps.map(({ name, text }) => {
                    const value = obj[name] !== undefined ? obj[name] : 0;
                    return `
                        <div class="property-row">
                            <label>${name}: <span class="value-display">${typeof value === 'number' ? Math.round(value * 100) / 100 : value}</span></label>
                            <div style="font-size: 11px; color: #667eea; margin: 3px 0; font-family: 'Courier New', monospace;">üìê ${text}</div>
                            <div style="display: flex; gap: 5px; align-items: center;">
                                <button onclick="openCustomEquationEditor('${name}')" style="padding: 4px 8px; font-size: 11px; flex: 1;" title="Edit equation">‚úèÔ∏è Edit Equation</button>
                                <button onclick="clearEquation('${name}')" class="danger" style="padding: 4px 8px; font-size: 11px;" title="Clear equation">‚úï</button>
                            </div>
                        </div>
                    `;
                }).join('');

                return `
                    <div class="property-group">
                        <h4>Custom Properties</h4>
                        ${customPropsHtml}
                    </div>
                `;
            };

            panel.innerHTML = `
                <div class="property-group">
                    <h4>Object</h4>
                    <div class="property-row">
                        <label>Name:</label>
                        <input type="text" value="${obj.name}" onchange="renameObject('${obj.id}', this.value)" style="width: 100%; padding: 6px; border: 1px solid #ccc; border-radius: 4px; margin-top: 5px;" />
                    </div>
                    <div class="property-row" style="margin-top: 10px;">
                        <label>Description:</label>
                        <textarea onchange="updateObjectDescription('${obj.id}', this.value)" style="width: 100%; padding: 6px; border: 1px solid #ccc; border-radius: 4px; margin-top: 5px; min-height: 60px; resize: vertical; font-family: inherit;">${obj.description || obj.info || ''}</textarea>
                    </div>
                    <div class="property-row" style="margin-top: 10px;">
                        <label>Shape:</label>
                        <select onchange="updateObjectShape('${obj.id}', this.value)" style="width: 100%; padding: 6px; border: 1px solid #ccc; border-radius: 4px; margin-top: 5px;">
                            <option value="square" ${obj.appearance === 'square' ? 'selected' : ''}>Square</option>
                            <option value="circle" ${obj.appearance === 'circle' ? 'selected' : ''}>Circle</option>
                            <option value="triangle" ${obj.appearance === 'triangle' ? 'selected' : ''}>Triangle</option>
                            <option value="star" ${obj.appearance === 'star' ? 'selected' : ''}>Star (5-pointed)</option>
                            <option value="pentagon" ${obj.appearance === 'pentagon' ? 'selected' : ''}>Pentagon</option>
                            <option value="hexagon" ${obj.appearance === 'hexagon' ? 'selected' : ''}>Hexagon</option>
                            <option value="roundrect" ${obj.appearance === 'roundrect' ? 'selected' : ''}>Rounded Rectangle</option>
                            <option value="arrow" ${obj.appearance === 'arrow' ? 'selected' : ''}>Arrow</option>
                            <option value="text" ${obj.appearance === 'text' ? 'selected' : ''}>Text/Label</option>
                        </select>
                    </div>
                    ${obj.appearance === 'text' ? `
                    <div class="property-row" style="margin-top: 10px;">
                        <label>Text Content:</label>
                        <div style="display: flex; gap: 5px; margin-top: 5px;">
                            <input type="text" value="${(obj.text || obj.name).replace(/"/g, '&quot;')}" onchange="updateObjectText('${obj.id}', this.value)" style="flex: 1; padding: 6px; border: 1px solid #ccc; border-radius: 4px; font-size: 14px;" />
                            <button onclick="openEmojiPicker('${obj.id}')" style="padding: 6px 12px; font-size: 18px; line-height: 1;" title="Insert emoji">üòÄ</button>
                        </div>
                    </div>
                    ` : ''}
                </div>

                <div class="property-group">
                    <h4>Position & Size</h4>
                    ${propertyRow('x', 'X Position', 0, 800)}
                    ${propertyRow('y', 'Y Position', 0, 600)}
                    ${propertyRow('width', 'Width', 1, 800)}
                    ${propertyRow('height', 'Height', 1, 600)}
                    ${propertyRow('rotation', 'Rotation', 0, 360, '¬∞')}
                </div>

                <div class="property-group">
                    <h4>Color</h4>

                    <div class="property-row">
                        <label>Color Picker</label>
                        <input type="color" value="${rgbToHex(obj.red, obj.green, obj.blue)}" onchange="updatePropertyColor(this.value)">
                    </div>

                    ${propertyRow('red', 'Red', 0, 255)}
                    ${propertyRow('green', 'Green', 0, 255)}
                    ${propertyRow('blue', 'Blue', 0, 255)}
                    ${propertyRow('opacity', 'Opacity', 0, 100, '%')}
                </div>

                <div class="property-group">
                    <h4>Pen Properties</h4>

                    <div class="property-row">
                        <label>Pen Color Picker</label>
                        <input type="color" value="${rgbToHex(obj.redColourPen, obj.greenColourPen, obj.blueColourPen)}" onchange="updatePropertyPenColor(this.value)">
                    </div>

                    ${propertyRow('thicknessPen', 'Pen Thickness', 0.5, 20)}
                    ${propertyRow('redColourPen', 'Pen Red', 0, 255)}
                    ${propertyRow('greenColourPen', 'Pen Green', 0, 255)}
                    ${propertyRow('blueColourPen', 'Pen Blue', 0, 255)}
                    ${propertyRow('opacityPen', 'Pen Opacity', 0, 100, '%')}
                </div>

                <div class="property-buttons">
                    <button class="secondary" onclick="togglePen()" title="Toggle pen (P)">${obj.penDown ? '‚úèÔ∏è Pen ON' : '‚úèÔ∏è Pen OFF'}</button>
                    <button class="success" onclick="copySelectedObject()" title="Copy object (C)">üìã Copy</button>
                    <button class="danger" onclick="deleteSelectedObject()" title="Delete (Del)">üóëÔ∏è Delete</button>
                </div>

                ${renderCustomProperties(obj)}

                <div class="property-group">
                    <h4>Layer Order</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <button class="secondary" onclick="bringToFront()" title="Bring to front (])" style="font-size: 12px; padding: 8px;">‚¨ÜÔ∏è Front</button>
                        <button class="secondary" onclick="sendToBack()" title="Send to back ([)" style="font-size: 12px; padding: 8px;">‚¨áÔ∏è Back</button>
                    </div>
                </div>
            `;
        }

        function updateProperty(prop, value) {
            if (!selectedObjectId) return;

            const obj = objects.get(selectedObjectId);
            const numValue = parseFloat(value);
            obj[prop] = numValue;

            // Clear equation cache for modified property
            if (obj.equations.has(prop)) {
                obj.equations.get(prop).cache.clear();
            }

            updatePropertyPanel();
            // Update object list if color property changed
            if (prop === 'red' || prop === 'green' || prop === 'blue') {
                updateObjectList();
            }
            renderFrame(animationController.currentFrame);
        }

        function updatePropertyColor(hexColor) {
            if (!selectedObjectId) return;

            const obj = objects.get(selectedObjectId);
            const r = parseInt(hexColor.substr(1, 2), 16);
            const g = parseInt(hexColor.substr(3, 2), 16);
            const b = parseInt(hexColor.substr(5, 2), 16);

            obj.red = r;
            obj.green = g;
            obj.blue = b;

            updatePropertyPanel();
            updateObjectList(); // Update icon color in object list
            renderFrame(animationController.currentFrame);
        }

        function updatePropertyPenColor(hexColor) {
            if (!selectedObjectId) return;

            const obj = objects.get(selectedObjectId);
            const r = parseInt(hexColor.substr(1, 2), 16);
            const g = parseInt(hexColor.substr(3, 2), 16);
            const b = parseInt(hexColor.substr(5, 2), 16);

            obj.redColourPen = r;
            obj.greenColourPen = g;
            obj.blueColourPen = b;

            updatePropertyPanel();
            renderFrame(animationController.currentFrame);
        }

        // ==================== Equation Management ====================

        let currentEquationProperty = null;

        // Drag-and-drop for equations
        function handleEquationDragStart(event, sourceObjectId, property) {
            const sourceObj = objects.get(sourceObjectId);
            if (!sourceObj || !sourceObj.equations.has(property)) return;

            const equation = sourceObj.equations.get(property);
            const equationData = {
                text: equation.text,
                description: equation.description || '',
                property: property
            };

            event.dataTransfer.setData('application/json', JSON.stringify(equationData));
            event.dataTransfer.effectAllowed = 'copy';
        }

        function handleEquationDrop(event, targetObjectId) {
            try {
                const equationData = JSON.parse(event.dataTransfer.getData('application/json'));
                const targetObj = objects.get(targetObjectId);

                if (!targetObj || !equationData.text) return;

                // Parse and validate the equation
                const result = parseEquation(equationData.text);
                if (!result.success) {
                    showError(`Cannot copy equation: ${result.error}`);
                    return;
                }

                // Apply equation to the target object for the same property
                targetObj.equations.set(equationData.property, {
                    attribute: equationData.property,
                    expression: result.expression,
                    text: equationData.text,
                    description: equationData.description || '',
                    cache: new Map()
                });

                saveHistoryState();
                updatePropertyPanel();
                updateObjectList();
                renderFrame(animationController.currentFrame);

                // Show success feedback
                showError(`‚úì Copied ${equationData.property} equation to ${targetObj.name}`, false);
            } catch (e) {
                console.error('Drop error:', e);
            }
        }

        function openEquationEditor(property) {
            if (!selectedObjectId) return;

            currentEquationProperty = property;
            const obj = objects.get(selectedObjectId);

            document.getElementById('equationProperty').value = property;
            document.getElementById('equationEditorModal').style.display = 'block';

            // Load existing equation if any
            if (obj.equations.has(property)) {
                const eq = obj.equations.get(property);
                document.getElementById('equationInput').value = eq.text || '';
                document.getElementById('equationDescription').value = eq.description || '';
            } else {
                document.getElementById('equationInput').value = '';
                document.getElementById('equationDescription').value = '';
            }

            validateEquation();
        }

        function closeEquationEditor() {
            document.getElementById('equationEditorModal').style.display = 'none';
            currentEquationProperty = null;
        }

        let currentEmojiPickerObjectId = null;

        function openEmojiPicker(objectId) {
            currentEmojiPickerObjectId = objectId;
            document.getElementById('emojiPickerModal').style.display = 'block';
        }

        function closeEmojiPicker() {
            document.getElementById('emojiPickerModal').style.display = 'none';
            currentEmojiPickerObjectId = null;
        }

        function insertEmoji(emoji) {
            if (!currentEmojiPickerObjectId) return;

            const obj = objects.get(currentEmojiPickerObjectId);
            if (obj) {
                obj.text = (obj.text || obj.name) + emoji;
                saveHistoryState();
                updatePropertyPanel();
                renderFrame(animationController.currentFrame);
            }
            closeEmojiPicker();
        }

        function openCustomEquationEditor(property) {
            if (!selectedObjectId) return;

            currentEquationProperty = property;
            const obj = objects.get(selectedObjectId);

            // For custom properties, we need to add them to the dropdown or handle differently
            // For now, we'll use a simple approach: set the property and open the modal
            const selectElement = document.getElementById('equationProperty');

            // Check if the property exists in the dropdown
            let optionExists = false;
            for (let option of selectElement.options) {
                if (option.value === property) {
                    optionExists = true;
                    break;
                }
            }

            // If not in dropdown, temporarily add it
            if (!optionExists) {
                const newOption = document.createElement('option');
                newOption.value = property;
                newOption.text = property + ' (Custom)';
                selectElement.add(newOption);
            }

            selectElement.value = property;
            document.getElementById('equationEditorModal').style.display = 'block';

            // Load existing equation if any
            if (obj.equations.has(property)) {
                const eq = obj.equations.get(property);
                document.getElementById('equationInput').value = eq.text || '';
            } else {
                document.getElementById('equationInput').value = '';
            }

            validateEquation();
        }

        function validateEquation() {
            const input = document.getElementById('equationInput').value.trim();
            const errorDiv = document.getElementById('equationError');
            const successDiv = document.getElementById('equationSuccess');
            const saveBtn = document.getElementById('saveEquationBtn');

            if (!input) {
                errorDiv.style.display = 'none';
                successDiv.style.display = 'none';
                saveBtn.disabled = false;
                return true;
            }

            const result = parseEquation(input);

            if (result.success) {
                errorDiv.style.display = 'none';
                successDiv.style.display = 'block';
                saveBtn.disabled = false;
                return true;
            } else {
                errorDiv.textContent = '‚úó Error: ' + result.error;
                errorDiv.style.display = 'block';
                successDiv.style.display = 'none';
                saveBtn.disabled = true;
                return false;
            }
        }

        function setEquationExample(example) {
            document.getElementById('equationInput').value = example;
            validateEquation();
        }

        function saveEquation() {
            if (!selectedObjectId || !currentEquationProperty) return;

            const input = document.getElementById('equationInput').value.trim();
            const description = document.getElementById('equationDescription').value.trim();
            const property = document.getElementById('equationProperty').value;
            const obj = objects.get(selectedObjectId);

            if (!input) {
                // Remove equation
                obj.equations.delete(property);
            } else {
                if (!validateEquation()) return;

                const result = parseEquation(input);
                if (result.success) {
                    obj.equations.set(property, {
                        attribute: property,
                        expression: result.expression,
                        text: input,
                        description: description,
                        cache: new Map()
                    });
                }
            }

            saveHistoryState();
            updatePropertyPanel();
            closeEquationEditor();
            renderFrame(animationController.currentFrame);
        }

        function clearEquation(property) {
            if (!selectedObjectId) return;

            const obj = objects.get(selectedObjectId);
            obj.equations.delete(property);

            saveHistoryState();
            updatePropertyPanel();
            renderFrame(animationController.currentFrame);
        }

        function getEquationText(obj, property) {
            if (obj.equations.has(property)) {
                return obj.equations.get(property).text || 'Legacy equation';
            }
            return null;
        }

        // ==================== History (Undo/Redo) ====================

        function saveHistoryState() {
            const state = {
                objects: serializeObjects(),
                selectedObjectId: selectedObjectId
            };
            historyManager.pushState(state);
            updateHistoryUI();
        }

        function undo() {
            const state = historyManager.undo();
            if (state) {
                restoreState(state);
                updateHistoryUI();
            }
        }

        function redo() {
            const state = historyManager.redo();
            if (state) {
                restoreState(state);
                updateHistoryUI();
            }
        }

        function restoreState(state) {
            deserializeObjects(state.objects);
            selectedObjectId = state.selectedObjectId;
            updateObjectList();
            updatePropertyPanel();
            renderFrame(animationController.currentFrame);
        }

        function updateHistoryUI() {
            const info = historyManager.getInfo();
            document.getElementById('historyInfo').textContent = `History: ${info.current} / ${info.total}`;
            document.getElementById('undoButton').disabled = !info.canUndo;
            document.getElementById('redoButton').disabled = !info.canRedo;
        }

        function serializeObjects() {
            return Array.from(objects.values()).map(obj => {
                const equations = {};
                if (obj.equations) {
                    obj.equations.forEach((eq, attr) => {
                        equations[attr] = {
                            text: eq.text || '',
                            description: eq.description || ''
                        };
                    });
                }

                return {
                    id: obj.id,
                    name: obj.name,
                    x: obj.x,
                    y: obj.y,
                    width: obj.width,
                    height: obj.height,
                    rotation: obj.rotation,
                    red: obj.red,
                    green: obj.green,
                    blue: obj.blue,
                    opacity: obj.opacity,
                    appearance: obj.appearance,
                    penDown: obj.penDown,
                    text: obj.text || '',
                    description: obj.description || obj.info || '',
                    equations: equations
                };
            });
        }

        function deserializeObjects(objectsData) {
            objects.clear();
            objectsData.forEach(objData => {
                const equationsMap = new Map();

                if (objData.equations) {
                    Object.entries(objData.equations).forEach(([attr, eqData]) => {
                        if (eqData) {
                            // Handle both old format (string) and new format (object with text and description)
                            const eqText = typeof eqData === 'string' ? eqData : eqData.text;
                            const eqDesc = typeof eqData === 'object' ? eqData.description : '';

                            if (eqText) {
                                const result = parseEquation(eqText);
                                if (result.success) {
                                    equationsMap.set(attr, {
                                        attribute: attr,
                                        expression: result.expression,
                                        text: eqText,
                                        description: eqDesc || '',
                                        cache: new Map()
                                    });
                                }
                            }
                        }
                    });
                }

                objects.set(objData.id, {
                    ...objData,
                    equations: equationsMap
                });
            });
        }

        // ==================== Object Operations ====================

        function renameObject(objectId, newName) {
            const obj = objects.get(objectId);
            if (obj && newName.trim()) {
                obj.name = newName.trim();
                saveHistoryState();
                updateObjectList();
                updatePropertyPanel();
            }
        }

        function updateObjectDescription(objectId, description) {
            const obj = objects.get(objectId);
            if (obj) {
                obj.description = description;
                saveHistoryState();
            }
        }

        function updateObjectShape(objectId, newShape) {
            const obj = objects.get(objectId);
            if (obj) {
                obj.appearance = newShape;
                saveHistoryState();
                updateObjectList();
                updatePropertyPanel();
                renderFrame(animationController.currentFrame);
            }
        }

        function updateObjectText(objectId, text) {
            const obj = objects.get(objectId);
            if (obj) {
                obj.text = text;
                saveHistoryState();
                renderFrame(animationController.currentFrame);
            }
        }

        function copySelectedObject() {
            if (!selectedObjectId) return;

            const obj = objects.get(selectedObjectId);
            const id = 'obj' + nextObjectId++;

            // Deep copy equations
            const copiedEquations = new Map();
            obj.equations.forEach((eq, attr) => {
                copiedEquations.set(attr, {
                    attribute: eq.attribute,
                    text: eq.text,
                    expression: eq.expression,
                    cache: new Map()
                });
            });

            const newObj = {
                ...obj,
                id: id,
                name: obj.name + ' Copy',
                x: obj.x + 40,
                y: obj.y + 40,
                equations: copiedEquations
            };

            objects.set(id, newObj);
            selectedObjectId = id;

            saveHistoryState();
            updateObjectList();
            updatePropertyPanel();
            renderFrame(animationController.currentFrame);
        }

        function deleteSelectedObject() {
            if (!selectedObjectId) return;
            if (objects.size <= 1) {
                alert('Cannot delete the last object!');
                return;
            }

            trailManager.clearObject(selectedObjectId);
            objects.delete(selectedObjectId);
            selectedObjectId = null;

            saveHistoryState();
            updateObjectList();
            updatePropertyPanel();
            renderFrame(animationController.currentFrame);
        }

        function clearAllObjects() {
            if (objects.size === 0) return;

            const confirmed = confirm(`Are you sure you want to delete all ${objects.size} object(s)? This cannot be undone.`);
            if (!confirmed) return;

            // Clear all trails
            trailManager.clearAll();

            // Clear all objects
            objects.clear();
            selectedObjectId = null;

            saveHistoryState();
            updateObjectList();
            updatePropertyPanel();
            renderFrame(animationController.currentFrame);
        }

        function togglePen() {
            if (!selectedObjectId) return;
            const obj = objects.get(selectedObjectId);
            obj.penDown = !obj.penDown;
            if (!obj.penDown) {
                trailManager.clearObject(obj.id);
            }
            updateObjectList();
            updatePropertyPanel();
            renderFrame(animationController.currentFrame);
        }

        function toggleCreateForm() {
            const form = document.getElementById('createObjectForm');
            form.style.display = form.style.display === 'none' ? 'block' : 'none';
        }

        function createObject() {
            const name = document.getElementById('newObjectName').value || 'Object';
            const shape = document.getElementById('newObjectShape').value;
            const x = parseInt(document.getElementById('newObjectX').value) || 400;
            const y = parseInt(document.getElementById('newObjectY').value) || 300;
            const size = parseInt(document.getElementById('newObjectSize').value) || 60;
            const text = document.getElementById('newObjectText').value || 'Hello';

            const id = 'obj' + nextObjectId++;

            const newObj = {
                id: id,
                name: name,
                x: x,
                y: y,
                width: size,
                height: size,
                rotation: 0,
                red: Math.floor(Math.random() * 256),
                green: Math.floor(Math.random() * 256),
                blue: Math.floor(Math.random() * 256),
                opacity: 100,
                appearance: shape,
                penDown: false,
                text: shape === 'text' ? text : '',
                thicknessPen: 2,
                redColourPen: Math.floor(Math.random() * 256),
                greenColourPen: Math.floor(Math.random() * 256),
                blueColourPen: Math.floor(Math.random() * 256),
                opacityPen: 100,
                equations: new Map(),
                description: ''
            };

            objects.set(id, newObj);
            selectedObjectId = id;

            saveHistoryState();
            updateObjectList();
            updatePropertyPanel();
            renderFrame(animationController.currentFrame);
            toggleCreateForm();
        }

        // ==================== Rendering ====================

        function renderFrame(frame) {
            // Clear update cache for this frame to allow fresh calculations
            updateCache.clear();

            const objectsArray = Array.from(objects.values());
            const updatedObjects = objectsArray.map(obj => {
                const updated = updateObjectAtTime(obj, frame, objects);
                if (updated.penDown) {
                    trailManager.recordPosition(updated, frame);
                }
                return updated;
            });

            // Update the objects Map with current frame values (for property panel display)
            updatedObjects.forEach(updated => {
                const original = objects.get(updated.id);
                if (original) {
                    // Update all property values but keep equations
                    Object.keys(updated).forEach(key => {
                        if (key !== 'equations' && key !== 'id' && key !== 'name' && key !== 'appearance') {
                            original[key] = updated[key];
                        }
                    });
                }
            });

            // Store current frame values for use as prev in next frame (t-1 support)
            updatedObjects.forEach(obj => {
                // Store all properties, including custom user-defined ones
                const prevValues = { ...obj };
                // Remove non-property fields that shouldn't be in prev
                delete prevValues.id;
                delete prevValues.name;
                delete prevValues.appearance;
                delete prevValues.penDown;
                delete prevValues.text;
                delete prevValues.equations;
                previousFrameValues.set(obj.id, prevValues);

                // DEBUG: Log what's stored for object_3
                if (obj.id === 'object_3' && frame <= 5) {
                    console.log(`[PREV FRAME ${frame}] Stored for object_3:`, {
                        x: prevValues.x?.toFixed(2),
                        y: prevValues.y?.toFixed(2),
                        Vx: prevValues.Vx,
                        Vy: prevValues.Vy,
                        Ax: prevValues.Ax,
                        Ay: prevValues.Ay
                    });
                }
            });

            const trails = trailManager.getAllTrails();
            renderer.renderScene(updatedObjects, trails, selectedObjectId);
        }

        function updateFrameDisplay(frame) {
            document.getElementById('frameInput').value = frame;
            document.getElementById('frameSlider').value = frame;
        }

        function updateSpeed(value) {
            const fps = parseInt(value);
            animationController.setFPS(fps);
            document.getElementById('speedDisplay').textContent = `${fps} fps`;
        }

        // ==================== Animation Controls ====================

        function togglePlay() {
            isPlaying = !isPlaying;
            const button = document.getElementById('playButton');

            if (isPlaying) {
                button.textContent = '‚è∏ Pause';
                button.className = 'pause';
                animationController.start();
            } else {
                button.textContent = '‚ñ∂ Play';
                button.className = 'play';
                animationController.stop();
                // Update object list to reflect any color changes from equations
                updateObjectList();
            }
        }

        function toggleKeyboardShortcuts(enabled) {
            keyboardShortcutsEnabled = enabled;
        }

        function resetAnimation() {
            isPlaying = false;
            document.getElementById('playButton').textContent = '‚ñ∂ Play';
            document.getElementById('playButton').className = 'play';
            animationController.stop();
            animationController.reset();
            trailManager.clearAll();
            renderFrame(0);
            updateFrameDisplay(0);
            updateObjectList();
        }

        function stepForward() {
            isPlaying = false;
            document.getElementById('playButton').textContent = '‚ñ∂ Play';
            document.getElementById('playButton').className = 'play';
            animationController.stop();
            animationController.stepForward();
        }

        function stepBackward() {
            isPlaying = false;
            document.getElementById('playButton').textContent = '‚ñ∂ Play';
            document.getElementById('playButton').className = 'play';
            animationController.stop();
            animationController.stepBackward();
        }

        function setFrame(value) {
            const frame = parseInt(value, 10);
            isPlaying = false;
            document.getElementById('playButton').textContent = '‚ñ∂ Play';
            document.getElementById('playButton').className = 'play';
            animationController.stop();
            animationController.setFrame(frame);
        }

        function clearAllTrails() {
            trailManager.clearAll();
            renderFrame(animationController.currentFrame);
        }

        // ==================== Persistence ====================

        function saveToLocalStorage() {
            try {
                const data = serializeProject();
                localStorage.setItem('mopix_project', data);
                alert('Project saved to browser!');
            } catch (e) {
                alert('Error saving: ' + e.message);
            }
        }

        function loadFromLocalStorage() {
            try {
                const data = localStorage.getItem('mopix_project');
                if (!data) {
                    alert('No saved project found!');
                    return;
                }
                deserializeProject(data);
                alert('Project loaded!');
            } catch (e) {
                alert('Error loading: ' + e.message);
            }
        }

        function exportToFile() {
            const data = serializeProject();
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'mopix_project.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function importFromFile() {
            document.getElementById('fileInput').click();
        }

        function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    deserializeProject(e.target.result);
                    alert('Project imported!');
                } catch (err) {
                    alert('Error importing: ' + err.message);
                }
            };
            reader.readAsText(file);
        }

        function serializeProject() {
            const variablesObj = {};
            userVariables.forEach((value, name) => {
                variablesObj[name] = value;
            });

            const data = {
                version: '3.0',
                currentFrame: animationController.currentFrame,
                variables: variablesObj,
                objects: serializeObjects()
            };
            return JSON.stringify(data, null, 2);
        }

        function deserializeProject(jsonString) {
            const data = JSON.parse(jsonString);
            deserializeObjects(data.objects);

            // Load variables
            userVariables.clear();
            if (data.variables) {
                Object.entries(data.variables).forEach(([name, value]) => {
                    userVariables.set(name, value);
                });
            }

            if (data.currentFrame !== undefined) {
                animationController.setFrame(data.currentFrame);
            }

            trailManager.clearAll();
            selectedObjectId = null;
            historyManager.clear();
            saveHistoryState();

            updateVariablesList();
            updateObjectList();
            updatePropertyPanel();
            updateHistoryUI();
            renderFrame(animationController.currentFrame);
        }

        // ==================== Sample Models ====================

        const sampleModels = [
            {
                id: 'rotating-rectangle',
                name: 'Rotating Rectangle',
                description: 'A simple model demonstrating basic equations and continuous rotation.',
                create: () => {
                    clearAll();
                    createSampleObject('rect', 'square', 400, 300, 100, 60, 100, 150, 255, {
                        rotation: { text: 't * 3', description: 'Rotates 3 degrees per frame' }
                    }, 'A simple rotating rectangle.\\n\\nEquation: rotation = t √ó 3\\n\\nThis demonstrates MoPiX\'s core feature: controlling object properties with algebraic expressions. The rectangle spins continuously at 3 degrees per frame by multiplying the time variable (t) by 3.');
                }
            },
            {
                id: 'growing-rectangle',
                name: 'Growing Rectangle',
                description: 'Demonstrates controlling multiple properties independently with different equations.',
                create: () => {
                    clearAll();
                    createSampleObject('rect', 'square', 340.7, 212.5, 10, 10, 255, 100, 100, {
                        width: { text: 't * 2', description: 'Grows 2 pixels per frame' },
                        height: { text: 't', description: 'Grows 1 pixel per frame' }
                    }, 'A rectangle that grows over time.\\n\\nEquations:\\nwidth = t √ó 2\\nheight = t\\n\\nThis showcases how MoPiX lets you control multiple properties simultaneously with independent equations. The width grows twice as fast as the height, creating non-uniform expansion.');
                }
            },
            {
                id: 'rotating-ellipse',
                name: 'Rotating Ellipse',
                description: 'A semi-transparent ellipse that rotates.',
                create: () => {
                    clearAll();
                    createSampleObject('ellipse', 'ellipse', 379.75, 321.5, 200, 100, 100, 100, 100, {
                        rotation: { text: 't * 3', description: 'Rotates 3 degrees per frame' }
                    }, 'A semi-transparent rotating ellipse.\\n\\nEquation: rotation = t √ó 3\\n\\nThis ellipse rotates at 3 degrees per frame. The opacity allows you to see through it.');
                    objects.get('ellipse').opacity = 50;
                }
            },
            {
                id: 'three-rotating-rectangles',
                name: 'Three Rotating Rectangles',
                description: 'Demonstrates trigonometric functions (sin) for smooth color oscillation and multiple objects.',
                create: () => {
                    clearAll();
                    createSampleObject('rect1', 'square', 250, 300, 80, 50, 255, 100, 100, {
                        rotation: { text: 't * 5', description: 'Fast rotation at 5 degrees/frame' },
                        red: { text: '128 + sin(t * 5) * 127', description: 'Oscillates red from 1-255 using sine wave' }
                    }, 'Fast rotating rectangle with color change.\\n\\nEquations:\\nrotation = t √ó 5\\nred = 128 + sin(t √ó 5) √ó 127\\n\\nUses sin() function to smoothly oscillate the red color between 1 and 255.');
                    createSampleObject('rect2', 'square', 400, 300, 80, 50, 100, 255, 100, {
                        rotation: { text: 't * 3', description: 'Medium rotation at 3 degrees/frame' },
                        green: { text: '128 + sin(t * 3) * 127', description: 'Oscillates green from 1-255 using sine wave' }
                    }, 'Medium rotating rectangle with color change.\\n\\nEquations:\\nrotation = t √ó 3\\ngreen = 128 + sin(t √ó 3) √ó 127\\n\\nDemonstrates how different frequencies create different animation speeds.');
                    createSampleObject('rect3', 'square', 550, 300, 80, 50, 100, 100, 255, {
                        rotation: { text: 't * 1.5', description: 'Slow rotation at 1.5 degrees/frame' },
                        blue: { text: '128 + sin(t * 1.5) * 127', description: 'Oscillates blue from 1-255 using sine wave' }
                    }, 'Slow rotating rectangle with color change.\\n\\nEquations:\\nrotation = t √ó 1.5\\nblue = 128 + sin(t √ó 1.5) √ó 127\\n\\nShows MoPiX\'s ability to manage multiple independent objects simultaneously.');
                }
            },
            {
                id: 'bouncing-balls-average',
                name: 'Average of Bouncing Balls',
                description: 'Showcases object references, physics simulation with prev values, and pen trails for graphing.',
                create: () => {
                    clearAll();

                    // Ball 1 (object_9) - right side with physics
                    createSampleObject('object_9', 'circle', 677.75, 400, 40, 40, 100, 0, 100, {
                        // Acceleration
                        Ay: { text: '-0.098', description: 'Gravity acceleration (downward)' },
                        Ax: { text: '0', description: 'No horizontal acceleration' },

                        // Velocity with predictive collision detection (like Four Graphs)
                        Vx: { text: 'if(t == 0, 3, if(prev.x + prev.Vx <= 0, prev.Vx * -1, if(prev.x + prev.Vx >= 800, prev.Vx * -1, prev.Vx + Ax)))', description: 'Horizontal velocity with wall bounce detection' },
                        Vy: { text: 'if(t == 0, 0, if(prev.y + prev.Vy <= 20, if(prev.Vy < 0, prev.Vy * -1, prev.Vy + Ay), prev.Vy + Ay))', description: 'Vertical velocity with ground bounce detection' },

                        // Position
                        x: { text: 'prev.x + Vx', description: 'Update X position using horizontal velocity' },
                        y: { text: 'prev.y + Vy', description: 'Update Y position using vertical velocity' }
                    }, 'First bouncing ball with full physics simulation.\\n\\nEquations use:\\n- Custom properties (Vx, Vy, Ax, Ay)\\n- prev values for frame-to-frame continuity\\n- if() conditionals for collision detection\\n\\nThis demonstrates advanced MoPiX features for realistic physics.');

                    // Ball 2 (object_4) - left side with physics
                    createSampleObject('object_4', 'circle', 149.75, 300, 40, 40, 100, 0, 0, {
                        // Acceleration
                        Ay: { text: '-0.098', description: 'Gravity acceleration (downward)' },
                        Ax: { text: '0', description: 'No horizontal acceleration' },

                        // Velocity with predictive collision detection (like Four Graphs)
                        Vx: { text: 'if(t == 0, 3, if(prev.x + prev.Vx <= 0, prev.Vx * -1, if(prev.x + prev.Vx >= 800, prev.Vx * -1, prev.Vx + Ax)))', description: 'Horizontal velocity with wall bounce detection' },
                        Vy: { text: 'if(t == 0, 0, if(prev.y + prev.Vy <= 20, if(prev.Vy < 0, prev.Vy * -1, prev.Vy + Ay), prev.Vy + Ay))', description: 'Vertical velocity with ground bounce detection' },

                        // Position
                        x: { text: 'prev.x + Vx', description: 'Update X position using horizontal velocity' },
                        y: { text: 'prev.y + Vy', description: 'Update Y position using vertical velocity' }
                    }, 'Second bouncing ball with physics.');

                    // Average position tracker (object_6)
                    createSampleObject('object_6', 'circle', 413.75, 350, 15, 15, 0, 50, 50, {
                        x: { text: '(object_4.x + object_9.x) / 2', description: 'Average X position of both balls' },
                        y: { text: '(object_4.y + object_9.y) / 2', description: 'Average Y position of both balls' }
                    }, 'Tracks the average position of both balls.\\n\\nEquations:\\nx = (object_4.x + object_9.x) / 2\\ny = (object_4.y + object_9.y) / 2\\n\\nDemonstrates MoPiX\'s powerful OBJECT REFERENCE feature - objects can reference other objects\' properties! The pen trail feature visualizes the path.');
                    objects.get('object_6').penDown = true;
                    objects.get('object_6').thicknessPen = 4;

                    // Set pen colors
                    objects.get('object_6').redColourPen = 50;
                    objects.get('object_6').greenColourPen = 50;
                    objects.get('object_6').blueColourPen = 50;
                }
            },
            {
                id: 'rectangle-three-cycles',
                name: 'Rectangle with Three Cycles',
                description: 'Demonstrates controlling multiple properties with different periodic frequencies using trigonometry.',
                create: () => {
                    clearAll();
                    createSampleObject('rect', 'square', 227.75, 241.5, 100, 200, 128, 128, 128, {
                        width: { text: '50 * sin(t) + 50', description: 'Oscillates width (1x frequency)' },
                        green: { text: '50 * sin(2 * t) + 50', description: 'Oscillates green channel (2x frequency)' },
                        rotation: { text: '50 * sin(3 * t) + 50', description: 'Oscillates rotation (3x frequency)' }
                    }, 'A rectangle with three independent cycles.\\n\\nEquations:\\nwidth = 50 √ó sin(t) + 50\\ngreen = 50 √ó sin(2t) + 50\\nrotation = 50 √ó sin(3t) + 50\\n\\nShows how MoPiX handles multiple simultaneous periodic behaviors with sine waves at different frequencies (1x, 2x, 3x), creating complex emergent patterns.');
                }
            },
            {
                id: 'falling-upward',
                name: 'Falling Upward',
                description: 'An exercise in negative gravity.',
                create: () => {
                    clearAll();
                    createSampleObject('ball', 'circle', 305.75, 100, 40, 40, 255, 200, 100, {
                        y: { text: '100 + 0.049 * t * t', description: 'Quadratic motion with upward acceleration' }
                    }, 'A ball that falls upward!\\n\\nEquation: y = 100 + 0.049 √ó t¬≤\\n\\nThis uses the physics equation for motion under constant acceleration. With positive upward acceleration (Ay = 0.098), the ball accelerates upward, moving faster as time goes on.');
                }
            },
            {
                id: 'two-animated-objects-graphs',
                name: 'Two Animated Objects with Graphs',
                description: 'Demonstrates pen trail graphing to visualize property changes over time for multiple objects.',
                create: () => {
                    clearAll();
                    // First animated object (rectangle)
                    createSampleObject('object_1', 'square', 247.75, 244.5, 100, 100, 128, 128, 128, {
                        width: { text: '50 * sin(t) + 50', description: 'Oscillates width (1x frequency)' },
                        green: { text: '50 * sin(2 * t) + 50', description: 'Oscillates green channel (2x frequency)' },
                        rotation: { text: '50 * sin(4 * t) + 50', description: 'Oscillates rotation (4x frequency)' },
                        height: { text: '50 * sin(0.5 * t) + 50', description: 'Oscillates height (0.5x frequency)' },
                        red: { text: '50 * sin(t) + 50', description: 'Oscillates red channel (1x frequency)' }
                    }, 'First animated object with multiple cycles.');

                    // Second animated object (circle)
                    createSampleObject('object_4', 'circle', 420.75, 243.5, 100, 100, 128, 128, 128, {
                        width: { text: '50 * sin(t) + 50', description: 'Oscillates width (1x frequency)' },
                        green: { text: '50 * sin(2 * t) + 50', description: 'Oscillates green channel (2x frequency)' },
                        rotation: { text: '50 * sin(2 * t) + 50', description: 'Oscillates rotation (2x frequency)' },
                        height: { text: '50 * sin(3 * t) + 50', description: 'Oscillates height (3x frequency)' },
                        red: { text: '50 * sin(t) + 50', description: 'Oscillates red channel (1x frequency)' },
                        blue: { text: '50 * sin(3 * t) + 50', description: 'Oscillates blue channel (3x frequency)' }
                    }, 'Second animated object with different cycles.');

                    // Graph objects with pens
                    createSampleObject('object_12', 'circle', 141, 392, 5, 5, 0, 100, 0, {
                        x: { text: 't', description: 'Time as X coordinate' },
                        y: { text: '(50 * sin(4 * t) + 50) / 4 + 400', description: 'Graphs object_1 rotation over time' }
                    }, 'Graph of object_1 rotation.');
                    objects.get('object_12').penDown = true;
                    objects.get('object_12').greenColourPen = 100;
                    objects.get('object_12').thicknessPen = 4;

                    createSampleObject('object_5', 'circle', 324, 386.55, 5, 5, 0, 0, 100, {
                        x: { text: 't', description: 'Time as X coordinate' },
                        y: { text: '(50 * sin(2 * t) + 50) / 4 + 400', description: 'Graphs object_4 rotation over time' }
                    }, 'Graph of object_4 rotation.');
                    objects.get('object_5').penDown = true;
                    objects.get('object_5').blueColourPen = 100;
                    objects.get('object_5').thicknessPen = 4;
                }
            },
            {
                id: 'three-rotating-rectangles-colour',
                name: 'Three Rotating Rectangles (Color Cycles)',
                description: 'Three rectangles with different rotation speeds and color oscillations.',
                create: () => {
                    clearAll();
                    // Rectangle 1 - fastest (5x)
                    createSampleObject('object_107', 'square', 338.75, 340.45, 200, 100, 50, 50, 50, {
                        rotation: { text: 't * 5', description: 'Fast rotation at 5 degrees per frame' },
                        blue: { text: '50 + 50 * sin(t * 0.3)', description: 'Oscillates blue channel slowly' }
                    }, 'Fast rotating rectangle with blue oscillation.');
                    objects.get('object_107').opacity = 50;

                    // Rectangle 2 - medium (3x)
                    createSampleObject('object_105', 'square', 180.75, 340.45, 200, 100, 50, 50, 50, {
                        rotation: { text: 't * 3', description: 'Medium rotation at 3 degrees per frame' },
                        red: { text: '50 + 50 * sin(t * 0.3)', description: 'Oscillates red channel slowly' }
                    }, 'Medium rotating rectangle with red oscillation.');
                    objects.get('object_105').opacity = 50;

                    // Rectangle 3 - fastest (7x)
                    createSampleObject('object_118', 'square', 494.75, 340.45, 200, 100, 50, 50, 50, {
                        rotation: { text: 't * 7', description: 'Very fast rotation at 7 degrees per frame' },
                        green: { text: '50 + 50 * sin(t * 0.3)', description: 'Oscillates green channel slowly' }
                    }, 'Very fast rotating rectangle with green oscillation.');
                    objects.get('object_118').opacity = 50;
                }
            },
            {
                id: 'four-graphs',
                name: 'Four Graphs',
                description: 'Advanced demo: real-time graphing of X position, Y position, and velocities using object references and pen trails.',
                create: () => {
                    clearAll();
                    // Bouncing ball with full physics simulation
                    createSampleObject('object_3', 'circle', 20.75, 337.7, 40, 40, 100, 100, 255, {
                        // Acceleration (constant)
                        Ay: { text: '-0.098', description: 'Gravity acceleration (downward)' },
                        Ax: { text: '0', description: 'No horizontal acceleration' },

                        // Velocity updates: initial values at t=0, then formulas
                        // Vx: initial=3, then bounce off walls at x=0 or x=799
                        Vx: { text: 'if(t == 0, 3, if(prev.x + prev.Vx <= 0, prev.Vx * -1, if(prev.x + prev.Vx >= 799, prev.Vx * -1, prev.Vx + Ax)))', description: 'Horizontal velocity with wall bounce' },
                        // Vy: initial=0, then bounce off ground at y=20 when moving downward
                        Vy: { text: 'if(t == 0, 0, if(prev.y + prev.Vy <= 20, if(prev.Vy < 0, prev.Vy * -1, prev.Vy + Ay), prev.Vy + Ay))', description: 'Vertical velocity with ground bounce' },

                        // Position updates
                        x: { text: 'prev.x + Vx', description: 'Update X position using velocity' },
                        y: { text: 'prev.y + Vy', description: 'Update Y position using velocity' }
                    }, 'Bouncing ball with full physics simulation.\\n\\nEquations use:\\n- Ax=0, Ay=-0.098 (gravity)\\n- Vx/Vy with conditional wall/ground bounces\\n- prev values for continuity\\n- x = prev.x + Vx (position update)\\n\\nFour small objects with pens enabled graph this ball\'s X, Y, Vx, and Vy in real-time, demonstrating MoPiX\'s graphing capability through object references!');

                    // Graph 1: X position (blue)
                    createSampleObject('object_5', 'circle', 103.75, 280.45, 5, 5, 0, 0, 100, {
                        x: { text: 't', description: 'Time as X coordinate' },
                        y: { text: 'object_3.x / 10 + 400', description: 'Graphs X position scaled and offset' }
                    }, 'Graph of object_3 X position.');
                    objects.get('object_5').penDown = true;
                    objects.get('object_5').blueColourPen = 100;
                    objects.get('object_5').thicknessPen = 4;

                    // Graph 2: Y position (red)
                    createSampleObject('object_4', 'circle', 189.75, 413.45, 5, 5, 100, 0, 0, {
                        x: { text: 't', description: 'Time as X coordinate' },
                        y: { text: 'object_3.y / 10 + 400', description: 'Graphs Y position scaled and offset' }
                    }, 'Graph of object_3 Y position.');
                    objects.get('object_4').penDown = true;
                    objects.get('object_4').redColourPen = 100;
                    objects.get('object_4').thicknessPen = 4;

                    // Graph 3: Vx (horizontal velocity - purple/mixed)
                    createSampleObject('object_7', 'circle', 242, 314.3, 5, 5, 50, 50, 0, {
                        x: { text: 't', description: 'Time as X coordinate' },
                        y: { text: 'object_3.Vx / 1 + 400', description: 'Graphs horizontal velocity with offset' }
                    }, 'Graph of object_3 X velocity (constant at 3, reverses at walls).');
                    objects.get('object_7').penDown = true;
                    objects.get('object_7').redColourPen = 50;
                    objects.get('object_7').blueColourPen = 50;
                    objects.get('object_7').thicknessPen = 4;

                    // Graph 4: Vy (vertical velocity - green)
                    createSampleObject('object_6', 'circle', 387, 314.2, 5, 5, 0, 100, 0, {
                        x: { text: 't', description: 'Time as X coordinate' },
                        y: { text: 'object_3.Vy / 1 + 400', description: 'Graphs vertical velocity with offset' }
                    }, 'Graph of object_3 Y velocity (changes with gravity and bounces).');
                    objects.get('object_6').penDown = true;
                    objects.get('object_6').greenColourPen = 100;
                    objects.get('object_6').thicknessPen = 4;
                }
            },
            {
                id: 'pong-game',
                name: 'Pong Game',
                description: 'Interactive Pong game controlled by keyboard. Use W/S for left paddle, Up/Down arrows for right paddle.',
                create: () => {
                    clearAll();

                    // Left paddle controlled by W/S keys
                    createSampleObject('pongLeft', 'roundrect', 50, 300, 15, 80, 100, 200, 255, {
                        y: { text: 'clamp(prev.y + keyDown(w) * PaddleSpeed - keyDown(s) * PaddleSpeed, 60, 540)', description: 'Y position controlled by W/S keys with clamping' }
                    }, 'Pong left paddle controlled by W/S keys. Uses prev.y and PaddleSpeed custom property.');
                    objects.get('pongLeft').PaddleSpeed = 5;

                    // Right paddle controlled by arrow keys
                    createSampleObject('pongRight', 'roundrect', 750, 300, 15, 80, 255, 100, 100, {
                        y: { text: 'clamp(prev.y + keyDown(ArrowUp) * PaddleSpeed - keyDown(ArrowDown) * PaddleSpeed, 60, 540)', description: 'Y position controlled by arrow keys with clamping' }
                    }, 'Pong right paddle controlled by Up/Down arrow keys.');
                    objects.get('pongRight').PaddleSpeed = 5;

                    // Ball with complex physics (using nested ifs instead of && and ||)
                    createSampleObject('pongBall', 'circle', 400, 300, 15, 15, 255, 255, 100, {
                        vx: { text: 'if(t == 0, 3, if(prev.x + prev.vx < 35, if(overlaps(pongBall, pongLeft), abs(prev.vx) * 1.05, prev.vx), if(prev.x + prev.vx > 765, if(overlaps(pongBall, pongRight), -abs(prev.vx) * 1.05, prev.vx), if(prev.x + prev.vx < 15, 3, if(prev.x + prev.vx > 785, 3, prev.vx)))))', description: 'Horizontal velocity with paddle collision and reset' },
                        vy: { text: 'if(t == 0, 2, if(prev.y + prev.vy < 20, prev.vy * -1, if(prev.y + prev.vy > 580, prev.vy * -1, if(overlaps(pongBall, pongLeft), prev.vy + random(-1, 1), if(overlaps(pongBall, pongRight), prev.vy + random(-1, 1), prev.vy)))))', description: 'Vertical velocity with wall bounce and spin' },
                        x: { text: 'if(prev.x + prev.vx < 35, if(overlaps(pongBall, pongLeft), 35, if(prev.x + prev.vx < 15, 400, prev.x + prev.vx)), if(prev.x + prev.vx > 765, if(overlaps(pongBall, pongRight), 765, if(prev.x + prev.vx > 785, 400, prev.x + prev.vx)), prev.x + prev.vx))', description: 'X position with collision detection and reset' },
                        y: { text: 'if(prev.y + prev.vy < 20, clamp(prev.y, 20, 580), if(prev.y + prev.vy > 580, clamp(prev.y, 20, 580), if(prev.x + prev.vx < 15, 300, if(prev.x + prev.vx > 785, 300, prev.y + prev.vy))))', description: 'Y position with boundary clamping and reset' }
                    }, 'Pong ball with collision detection, paddle bouncing, and reset on score.\\n\\nEquations use:\\n- overlaps() function to detect paddle collisions\\n- prev values for velocity and position\\n- Nested if() conditionals for bouncing and scoring\\n- abs() for velocity direction\\n- random() for paddle spin effect\\n\\nThis demonstrates MoPiX\'s ability to create interactive games with keyboard control and physics!');

                    // Set ball initial velocity and enable pen trail
                    objects.get('pongBall').vx = 3;
                    objects.get('pongBall').vy = 2;
                    objects.get('pongBall').penDown = true;
                    objects.get('pongBall').thicknessPen = 1;
                    objects.get('pongBall').redColourPen = 200;
                    objects.get('pongBall').greenColourPen = 200;
                    objects.get('pongBall').blueColourPen = 200;
                    objects.get('pongBall').opacityPen = 30;

                    // Center line (decorative)
                    createSampleObject('pongCenter', 'roundrect', 400, 300, 4, 600, 100, 100, 100, {}, 'Pong center line for visual reference.');
                    objects.get('pongCenter').opacity = 30;
                }
            }
        ];

        function createSampleObject(id, shape, x, y, width, height, red, green, blue, equations, info) {
            const obj = {
                id: id,
                name: id,
                x: x,
                y: y,
                width: width,
                height: height,
                rotation: 0,
                red: red,
                green: green,
                blue: blue,
                opacity: 100,
                appearance: shape,
                equations: new Map(),
                penDown: false,
                thicknessPen: 2,
                redColourPen: 0,
                greenColourPen: 0,
                blueColourPen: 0,
                opacityPen: 100,
                // Physics properties for velocity and acceleration
                Vx: 0,
                Vy: 0,
                Ax: 0,
                Ay: 0,
                info: info || ''
            };

            // Parse and add equations
            for (const [prop, exprData] of Object.entries(equations)) {
                // Support both simple string and {text, description} format
                const expr = typeof exprData === 'string' ? exprData : exprData.text;
                const description = typeof exprData === 'object' ? (exprData.description || '') : '';

                const result = parseEquation(expr);
                if (result.success) {
                    obj.equations.set(prop, {
                        attribute: prop,
                        expression: result.expression,
                        text: expr,  // Store the original equation text
                        description: description,
                        cache: new Map()
                    });
                } else {
                    console.error(`Error parsing equation for ${prop}:`, result.error);
                }
            }

            objects.set(id, obj);
        }

        function clearAll() {
            objects.clear();
            userVariables.clear();
            trailManager.clearAll();
            selectedObjectId = null;
            animationController.reset();
            historyManager.clear();
            updateObjectList();
            updateVariablesList();
            updatePropertyPanel();
            updateHistoryUI();
            initializePreviousFrameValues();  // Initialize before rendering
            renderFrame(0);
        }

        function initializePreviousFrameValues() {
            // Initialize previousFrameValues with current object states
            // This is critical for prev.x, prev.y to work at frame 0
            previousFrameValues.clear();
            objects.forEach(obj => {
                const prevValues = { ...obj };
                // Remove non-property fields
                delete prevValues.id;
                delete prevValues.name;
                delete prevValues.appearance;
                delete prevValues.penDown;
                delete prevValues.text;
                delete prevValues.equations;
                previousFrameValues.set(obj.id, prevValues);
            });
        }

        function showSampleModels() {
            const dialog = document.getElementById('sampleModelsDialog');
            const list = document.getElementById('sampleModelsList');

            list.innerHTML = '';
            sampleModels.forEach(model => {
                const item = document.createElement('div');
                item.style.cssText = 'padding: 15px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; background-color: #fff;';
                item.innerHTML = `
                    <h4 style="margin: 0 0 8px 0; color: #1976D2;">${model.name}</h4>
                    <p style="margin: 0; color: #666; font-size: 14px;">${model.description}</p>
                `;
                item.onmouseenter = () => item.style.backgroundColor = '#f5f5f5';
                item.onmouseleave = () => item.style.backgroundColor = '#fff';
                item.onclick = () => loadSampleModel(model.id);
                list.appendChild(item);
            });

            dialog.style.display = 'block';
        }

        function closeSampleModels() {
            document.getElementById('sampleModelsDialog').style.display = 'none';
        }

        function loadSampleModel(modelId) {
            const model = sampleModels.find(m => m.id === modelId);
            if (!model) return;

            // Stop animation
            if (animationController.isPlaying) {
                togglePlay();
            }

            // Load the model
            model.create();

            // Initialize previousFrameValues with the loaded objects
            initializePreviousFrameValues();

            // Save state and update UI
            saveHistoryState();
            updateObjectList();
            updateVariablesList();
            updatePropertyPanel();
            renderFrame(0);

            // Show model description
            showModelInfo(model.name, model.description);

            closeSampleModels();
        }

        window.addEventListener('load', initDemo);
    </script>
</body>
</html>
