<!DOCTYPE html>
<html lang="en" class="h-full bg-slate-900">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>micro:bit MicroPython Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .fira-code {
            font-family: 'Fira Code', monospace;
        }
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1e293b;
        }
        ::-webkit-scrollbar-thumb {
            background: #475569;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }
        .error-highlight { background-color: #7f1d1d; color: #fecaca; padding: 2px 4px; border-radius: 3px; font-weight: bold; }
        .error-border { border-left: 3px solid #ef4444; padding-left: 8px; }
    </style>
</head>
<body class="h-full text-slate-200 antialiased">
    <div id="app" class="flex flex-col h-screen p-4 md:p-6 lg:p-8 gap-6 max-w-7xl mx-auto">
        <!-- Header -->
        <header class="flex-shrink-0">
            <h1 class="text-2xl md:text-3xl font-bold text-white tracking-tight">
                micro:bit <span class="text-sky-400">MicroPython</span> Editor
            </h1>
            <p class="text-slate-400 mt-1">
                Write MicroPython code, connect your micro:bit via Web Serial, and run it directly from your browser.
            </p>
        </header>

        <!-- Main Content -->
        <main class="flex-grow flex flex-col lg:flex-row gap-6 min-h-0">

            <!-- Code Editor -->
            <div class="flex-1 flex flex-col min-h-0">
                <label for="code-editor" class="text-sm font-medium text-slate-300 mb-2">Code Editor</label>
                <div class="flex-1 bg-slate-800 rounded-lg shadow-inner overflow-hidden">
                    <textarea id="code-editor" class="w-full h-full p-4 bg-transparent text-slate-200 resize-none outline-none fira-code text-sm leading-relaxed" spellcheck="false"># Example starter program
from microbit import *

while True:
    display.scroll("Hello")
    sleep(800)
</textarea>
                </div>
            </div>

            <!-- Controls and Output -->
            <div class="lg:w-1/3 flex flex-col gap-6">
                <!-- Controls -->
                <div class="bg-slate-800 p-4 rounded-lg shadow-lg">
                    <h2 class="text-lg font-semibold text-white mb-4">Controls</h2>
                    <div class="flex items-center justify-between mb-4">
                        <span class="text-sm font-medium text-slate-400">Status:</span>
                        <div id="status-indicator" class="flex items-center gap-2 px-3 py-1 rounded-full bg-slate-700">
                            <div id="status-dot" class="w-2 h-2 rounded-full bg-red-500 animate-pulse"></div>
                            <span id="status-text" class="text-sm font-medium text-slate-300">Disconnected</span>
                        </div>
                    </div>
                    <div class="grid grid-cols-1 gap-3">
                        <button id="ai-chat-button" class="w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200 flex items-center justify-center gap-2">
                            âœ¨ AI Code Gen
                        </button>
                        <button id="connect-button" class="w-full bg-sky-600 hover:bg-sky-500 disabled:bg-slate-600 disabled:cursor-not-allowed text-white font-bold py-2 px-4 rounded-md transition-colors duration-200 flex items-center justify-center gap-2">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M3.5 5.5a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2a.5.5 0 0 1 .5-.5m3 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2a.5.5 0 0 1 .5-.5m3 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2a.5.5 0 0 1 .5-.5m-6 4.5a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2a.5.5 0 0 1 .5-.5m3 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2a.5.5 0 0 1 .5-.5m3 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2a.5.5 0 0 1 .5-.5"/><path d="M2 1a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V3a2 2 0 0 0-2-2zM1 3a1 1 0 0 1 1-1h12a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1z"/></svg>
                            Connect micro:bit
                        </button>
                        <button id="run-button" disabled class="w-full bg-green-600 hover:bg-green-500 disabled:bg-slate-600 disabled:cursor-not-allowed text-white font-bold py-2 px-4 rounded-md transition-colors duration-200 flex items-center justify-center gap-2">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M11.596 8.697l-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/></svg>
                            Run Code
                        </button>
                        <button id="stop-button" disabled class="w-full bg-amber-600 hover:bg-amber-500 disabled:bg-slate-600 disabled:cursor-not-allowed text-white font-bold py-2 px-4 rounded-md transition-colors duration-200 flex items-center justify-center gap-2">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M5 3.5h6A1.5 1.5 0 0 1 12.5 5v6a1.5 1.5 0 0 1-1.5 1.5H5A1.5 1.5 0 0 1 3.5 11V5A1.5 1.5 0 0 1 5 3.5z"/></svg>
                            Stop Program
                        </button>
                        <button id="toggle-data-logging" disabled class="w-full bg-emerald-600 hover:bg-emerald-500 disabled:bg-slate-600 disabled:cursor-not-allowed text-white font-bold py-2 px-4 rounded-md transition-colors duration-200 flex items-center justify-center gap-2">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M9.5 13a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm0-5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm0-5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z"/></svg>
                            Start Data Logging
                        </button>
                        <button id="copy-data-button" disabled class="w-full bg-cyan-600 hover:bg-cyan-500 disabled:bg-slate-600 disabled:cursor-not-allowed text-white font-bold py-2 px-4 rounded-md transition-colors duration-200 flex items-center justify-center gap-2">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/><path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/></svg>
                            Copy Data
                        </button>
                        <button id="disconnect-button" disabled class="w-full bg-red-600 hover:bg-red-500 disabled:bg-slate-600 disabled:cursor-not-allowed text-white font-bold py-2 px-4 rounded-md transition-colors duration-200 flex items-center justify-center gap-2">
                             <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-lg" viewBox="0 0 16 16"><path d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8z"/></svg>
                            Disconnect
                        </button>
                    </div>
                </div>

                <!-- Output Terminal -->
                <div class="flex-1 flex flex-col min-h-0 bg-slate-800 p-4 rounded-lg shadow-lg">
                    <div class="flex-shrink-0 flex justify-between items-center mb-2">
                        <h2 class="text-lg font-semibold text-white">Device Output</h2>
                         <div class="flex items-center gap-4">
                            <button id="fix-with-ai-button" class="hidden text-xs bg-amber-600 hover:bg-amber-500 text-white font-semibold py-1 px-3 rounded-md">Fix with AI</button>
                            <button id="clear-output-button" class="text-xs text-slate-400 hover:text-sky-400">Clear</button>
                        </div>
                    </div>
                    <div class="flex-1 bg-black rounded-md overflow-y-auto">
                        <pre id="output" class="p-3 text-xs fira-code text-slate-300 whitespace-pre-wrap break-words"></pre>
                    </div>
                </div>
            </div>
        </main>

        <!-- Web Serial Support Message -->
        <div id="serial-support-msg" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50">
             <div class="bg-slate-800 rounded-lg p-8 max-w-md text-center shadow-2xl">
                <h2 class="text-2xl font-bold text-red-500 mb-4">Browser Not Supported</h2>
                <p class="text-slate-300">This application requires the <b>Web Serial API</b>, which is not supported by your current browser. Please use a recent version of Google Chrome, Microsoft Edge, or Opera on a desktop computer.</p>
            </div>
        </div>

        <!-- Notification Toast -->
        <div id="notification-toast" class="hidden fixed top-6 right-6 bg-green-600 text-white px-6 py-4 rounded-lg shadow-2xl z-50 max-w-md">
            <div class="flex items-center gap-3">
                <div class="flex-shrink-0">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                    </svg>
                </div>
                <div id="notification-message" class="font-medium"></div>
            </div>
        </div>
        
        <!-- Error Modal -->
        <div id="error-modal" class="hidden fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center p-4 z-50">
            <div class="bg-slate-800 w-full max-w-md rounded-xl shadow-2xl flex flex-col">
                <header class="flex items-center justify-between p-4 border-b border-slate-700">
                    <h2 class="text-xl font-bold text-red-400">Code Error Detected</h2>
                    <button id="error-modal-close" class="text-slate-400 hover:text-white text-3xl leading-none">Ã—</button>
                </header>
                <div class="p-4">
                    <div class="bg-red-900 bg-opacity-30 border border-red-500 rounded-lg p-3 mb-4">
                        <h3 class="text-red-300 font-semibold mb-2">Error Message:</h3>
                        <pre id="error-display" class="text-red-200 text-sm whitespace-pre-wrap font-mono"></pre>
                    </div>
                    <p class="text-slate-300 text-sm mb-4">
                        Your micro:bit code encountered an error. Would you like AI assistance to diagnose and fix the problem?
                    </p>
                    <div class="flex gap-3">
                        <button id="ai-fix-button" class="flex-1 bg-blue-600 hover:bg-blue-500 text-white font-bold py-2 px-4 rounded-md transition-colors">
                            Get AI Help
                        </button>
                        <button id="dismiss-error-button" class="flex-1 bg-slate-600 hover:bg-slate-500 text-white font-bold py-2 px-4 rounded-md transition-colors">
                            Dismiss
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- AI Chat Modal -->
        <div id="ai-chat-modal" class="hidden fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center p-4 z-40">
            <div class="bg-slate-800 w-full max-w-2xl h-[80vh] rounded-xl shadow-2xl flex flex-col">
                <header class="flex items-center justify-between p-4 border-b border-slate-700 gap-4">
                    <div class="flex items-center gap-3">
                        <h2 class="text-xl font-bold text-white">AI Code Gen</h2>
                        <span id="ai-status-badge" class="px-2 py-0.5 text-xs font-semibold rounded-full bg-slate-700 text-slate-300">Not Ready</span>
                    </div>
                    <div class="flex items-center gap-3 flex-wrap">
                        <button id="download-history-button" class="text-xs bg-green-600 hover:bg-green-500 text-white font-semibold py-2 px-3 rounded-md transition-colors whitespace-nowrap">
                            ðŸ“¥ Download History
                        </button>
                        <div class="flex items-center gap-2">
                            <label for="ai-provider-select" class="text-sm font-medium text-slate-300 whitespace-nowrap">Provider:</label>
                            <select id="ai-provider-select" class="bg-slate-700 text-slate-200 rounded-md px-2 py-1 text-sm outline-none focus:ring-2 focus:ring-blue-500">
                                <option value="nano">Gemini Nano (On-Device)</option>
                                <option value="gemini">Gemini (Cloud)</option>
                                <option value="claude">Claude (Cloud)</option>
                                <option value="chatgpt">ChatGPT (Cloud)</option>
                            </select>
                        </div>
                        <button id="ai-modal-close-button" class="text-slate-400 hover:text-white text-3xl leading-none">Ã—</button>
                    </div>
                </header>
                 <div id="ai-settings-area" class="p-4 border-b border-slate-700">
                    <div id="api-key-group" class="hidden w-full">
                        <label for="api-key-input" id="api-key-label" class="text-sm font-medium text-slate-300 mb-1 block">API Key:</label>
                        <div class="flex gap-2">
                            <input type="password" id="api-key-input" placeholder="Enter your API key" class="flex-1 bg-slate-900 text-slate-200 rounded-md px-3 py-1.5 outline-none focus:ring-2 focus:ring-blue-500 text-sm">
                            <button id="save-api-key-button" class="bg-green-600 hover:bg-green-500 text-white font-bold px-4 py-1.5 rounded-md text-sm">Save</button>
                        </div>
                    </div>
                </div>
                <div id="ai-chat-history" class="flex-1 p-4 overflow-y-auto space-y-4">
                    <!-- Chat messages will be appended here -->
                </div>
                <footer class="p-4 border-t border-slate-700">
                    <div class="mb-3">
                        <div class="flex items-center gap-4 mb-2">
                            <span class="text-sm font-medium text-slate-300">Mode:</span>
                            <label class="flex items-center gap-2 cursor-pointer">
                                <input type="radio" name="ai-mode" value="code" id="code-mode" class="text-blue-600" checked>
                                <span class="text-sm text-slate-200">Generate Code</span>
                            </label>
                            <label class="flex items-center gap-2 cursor-pointer">
                                <input type="radio" name="ai-mode" value="question" id="question-mode" class="text-blue-600">
                                <span class="text-sm text-slate-200">Ask Question</span>
                            </label>
                        </div>
                        <div id="mode-description" class="text-xs text-slate-400">
                            Generate MicroPython code for your micro:bit
                        </div>
                    </div>
                    <form id="ai-prompt-form" class="flex gap-3">
                        <input type="text" id="ai-prompt-input" placeholder="e.g., show a beating heart on the display" class="flex-1 bg-slate-700 text-slate-200 rounded-md px-3 py-2 outline-none focus:ring-2 focus:ring-blue-500" required>
                        <button type="button" id="voice-input-button" class="bg-purple-600 hover:bg-purple-500 disabled:bg-slate-600 text-white font-bold px-3 py-2 rounded-md transition-colors" title="Voice input">
                            ðŸŽ¤
                        </button>
                        <button type="submit" id="ai-prompt-send" class="bg-blue-600 hover:bg-blue-500 disabled:bg-slate-600 text-white font-bold px-4 py-2 rounded-md transition-colors">Send</button>
                    </form>
                </footer>
            </div>
        </div>

    </div>

    <script type="module">
        // --- DOM Elements ---
        const connectButton = document.getElementById('connect-button');
        const disconnectButton = document.getElementById('disconnect-button');
        const runButton = document.getElementById('run-button');
        const stopButton = document.getElementById('stop-button');
        const clearOutputButton = document.getElementById('clear-output-button');
        const codeEditor = document.getElementById('code-editor');
        const output = document.getElementById('output');
        const statusIndicator = document.getElementById('status-indicator');
        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');
        const serialSupportMsg = document.getElementById('serial-support-msg');
        const fixWithAiButton = document.getElementById('fix-with-ai-button');
        const toggleDataLoggingButton = document.getElementById('toggle-data-logging');
        const copyDataButton = document.getElementById('copy-data-button');

        // --- Error Modal DOM Elements ---
        const errorModal = document.getElementById('error-modal');
        const errorModalClose = document.getElementById('error-modal-close');
        const errorDisplay = document.getElementById('error-display');
        const aiFixButton = document.getElementById('ai-fix-button');
        const dismissErrorButton = document.getElementById('dismiss-error-button');
        
        const notificationToast = document.getElementById('notification-toast');
        const notificationMessage = document.getElementById('notification-message');

        // --- AI Chat DOM Elements ---
        const aiChatButton = document.getElementById('ai-chat-button');
        const aiChatModal = document.getElementById('ai-chat-modal');
        const aiModalCloseButton = document.getElementById('ai-modal-close-button');
        const aiStatusBadge = document.getElementById('ai-status-badge');
        const aiChatHistory = document.getElementById('ai-chat-history');
        const aiPromptForm = document.getElementById('ai-prompt-form');
        const aiPromptInput = document.getElementById('ai-prompt-input');
        const aiPromptSend = document.getElementById('ai-prompt-send');
        const aiProviderSelect = document.getElementById('ai-provider-select');
        const apiKeyGroup = document.getElementById('api-key-group');
        const apiKeyInput = document.getElementById('api-key-input');
        const saveApiKeyButton = document.getElementById('save-api-key-button');
        const apiKeyLabel = document.getElementById('api-key-label');
        const downloadHistoryButton = document.getElementById('download-history-button');
        const codeModeRadio = document.getElementById('code-mode');
        const questionModeRadio = document.getElementById('question-mode');
        const modeDescription = document.getElementById('mode-description');
        const voiceInputButton = document.getElementById('voice-input-button');

        // --- Web Serial State ---
        let port = null;
        let reader = null;
        let writer = null;
        const textEncoder = new TextEncoder();

        // --- AI State ---
        let aiSession = null;
        let aiStatus = 'uninitialized';
        let selectedProvider = 'nano';
        let apiKey = '';
        let lastRunCode = '';
        let isStopping = false;
        let conversationHistory = [];
        let fullChatHistory = [];
        let currentErrorData = null;

        // --- Speech Recognition State ---
        let recognition = null;
        let isListening = false;

        // --- Data Logging State ---
        let isDataLogging = false;
        let loggedData = [];
        let dataStartTime = null;
        let dataBuffer = ''; // Buffer for incomplete lines

        const SYSTEM_PROMPT = "You are an expert in MicroPython programming for the BBC micro:bit. When asked to generate code, provide concise, complete, and correct MicroPython code snippets enclosed in markdown code blocks (```python ... ```). When asked questions about micro:bit programming, provide clear explanations and examples. Always consider conversation history for context. Pay attention to data types - convert numbers to strings using str() before passing to functions like display.scroll(). IMPORTANT: Never use f-string syntax like f'text {variable}' as the micro:bit runs older MicroPython that doesn't support it. Use string concatenation with str() + 'text' + str() instead.";
        const NANO_SYSTEM_PROMPT = `You are a micro:bit MicroPython expert. 

FOR CODE GENERATION:
Generate ONLY micro:bit compatible code using the microbit library.

CRITICAL RULES FOR MICRO:BIT:
1. ALWAYS start with: from microbit import *
2. NEVER use: import machine, import time, or any other imports
3. Use sleep(milliseconds) NOT time.sleep()
4. Use temperature() function directly - it returns degrees Celsius as integer
5. Use display.scroll(str(value)) to show text on LED matrix
6. Use display.show(Image.HEART) for icons
7. NEVER use f-strings like f"text {variable}" - use str() and + instead
8. NEVER use print(f"...") - use print(str(x) + "," + str(y)) format

MICRO:BIT SPECIFIC FUNCTIONS (use these ONLY):
- Temperature sensor: temperature() - returns integer degrees Celsius
- Accelerometer: accelerometer.get_x(), accelerometer.get_y(), accelerometer.get_z()
- Compass: compass.heading() 
- Buttons: button_a.is_pressed(), button_b.is_pressed()
- Display: display.scroll("text"), display.show(Image.HEART)
- Sleep: sleep(1000) for 1 second delay
- Pins: pin0.read_analog(), pin0.write_digital(1)

NEVER use machine.ADC, machine.Pin, or any low-level hardware access!
NEVER use f-strings - the micro:bit runs old MicroPython that doesn't support them!

FOR QUESTIONS:
Provide clear, helpful explanations about micro:bit programming. Use examples when helpful.

EXAMPLE TEMPERATURE CODE:
\`\`\`python
from microbit import *

while True:
    temp = temperature()
    display.scroll(str(temp) + "C")
    sleep(1000)
\`\`\`

EXAMPLE SENSOR DATA CODE:
\`\`\`python
from microbit import *

while True:
    x = accelerometer.get_x()
    y = accelerometer.get_y()
    z = accelerometer.get_z()
    print(str(x) + "," + str(y) + "," + str(z))
    sleep(100)
\`\`\`

Always use str() + "," + str() format, NEVER f-strings!`;

        const SYSTEM_PROMPT_FOR_MODE = (provider, isCodeMode) => {
            if (provider === 'nano') {
                return NANO_SYSTEM_PROMPT;
            }
            return SYSTEM_PROMPT;
        };

        // --- Speech Recognition Functions ---
        const initializeSpeechRecognition = () => {
            // Check for speech recognition support
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                voiceInputButton.style.display = 'none';
                log('Speech recognition not supported in this browser.', 'info');
                return false;
            }

            // Check if we're on HTTPS or localhost (required for speech recognition)
            if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
                voiceInputButton.style.display = 'none';
                log('Speech recognition requires HTTPS or localhost.', 'info');
                return false;
            }

            try {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                recognition = new SpeechRecognition();
                
                recognition.continuous = false;
                recognition.interimResults = false;
                recognition.lang = 'en-US';
                recognition.maxAlternatives = 1;

                recognition.onstart = () => {
                    isListening = true;
                    voiceInputButton.textContent = 'ðŸ”´';
                    voiceInputButton.title = 'Listening... Click to stop';
                    voiceInputButton.classList.remove('bg-purple-600', 'hover:bg-purple-500');
                    voiceInputButton.classList.add('bg-red-600', 'hover:bg-red-500', 'animate-pulse');
                    log('ðŸŽ¤ Listening for speech...', 'info');
                };

                recognition.onresult = (event) => {
                    const transcript = event.results[0][0].transcript;
                    const confidence = event.results[0][0].confidence;
                    aiPromptInput.value = transcript;
                    log(`ðŸŽ¤ Speech recognized: "${transcript}" (confidence: ${Math.round(confidence * 100)}%)`, 'success');
                };

                recognition.onend = () => {
                    isListening = false;
                    voiceInputButton.textContent = 'ðŸŽ¤';
                    voiceInputButton.title = 'Voice input';
                    voiceInputButton.classList.remove('bg-red-600', 'hover:bg-red-500', 'animate-pulse');
                    voiceInputButton.classList.add('bg-purple-600', 'hover:bg-purple-500');
                    log('ðŸŽ¤ Speech recognition ended.', 'info');
                };

                recognition.onerror = (event) => {
                    isListening = false;
                    voiceInputButton.textContent = 'ðŸŽ¤';
                    voiceInputButton.title = 'Voice input';
                    voiceInputButton.classList.remove('bg-red-600', 'hover:bg-red-500', 'animate-pulse');
                    voiceInputButton.classList.add('bg-purple-600', 'hover:bg-purple-500');
                    
                    switch(event.error) {
                        case 'not-allowed':
                            log('ðŸŽ¤ Microphone access denied. Please allow microphone access and try again.', 'error');
                            break;
                        case 'no-speech':
                            log('ðŸŽ¤ No speech detected. Try speaking closer to the microphone.', 'info');
                            break;
                        case 'audio-capture':
                            log('ðŸŽ¤ No microphone found. Please check your microphone connection.', 'error');
                            break;
                        case 'network':
                            log('ðŸŽ¤ Network error during speech recognition.', 'error');
                            break;
                        default:
                            log(`ðŸŽ¤ Speech recognition error: ${event.error}`, 'error');
                    }
                };

                log('ðŸŽ¤ Speech recognition initialized successfully.', 'success');
                return true;
            } catch (error) {
                voiceInputButton.style.display = 'none';
                log(`ðŸŽ¤ Failed to initialize speech recognition: ${error.message}`, 'error');
                return false;
            }
        }

        // --- Data Logging Functions ---
        const toggleDataLogging = () => {
            if (isDataLogging) {
                // Stop logging
                isDataLogging = false;
                dataBuffer = ''; // Clear any remaining buffer
                toggleDataLoggingButton.textContent = 'ðŸ“Š Start Data Logging';
                toggleDataLoggingButton.classList.remove('bg-red-600', 'hover:bg-red-500');
                toggleDataLoggingButton.classList.add('bg-emerald-600', 'hover:bg-emerald-500');
                
                const duration = dataStartTime ? (Date.now() - dataStartTime) / 1000 : 0;
                const message = `Data logging stopped. Captured ${loggedData.length} data points over ${duration.toFixed(1)} seconds.`;
                log(`ðŸ“Š ${message}`, 'success');
                showNotification(message, 'success');  // Add this line
            } else {
                // Start logging
                isDataLogging = true;
                loggedData = [];
                dataBuffer = ''; // Clear buffer
                dataStartTime = Date.now();
                toggleDataLoggingButton.textContent = 'ðŸ”´ Stop Logging';
                toggleDataLoggingButton.classList.remove('bg-emerald-600', 'hover:bg-emerald-500');
                toggleDataLoggingButton.classList.add('bg-red-600', 'hover:bg-red-500');
                
                log('ðŸ“Š Data logging started. Complete lines will be captured.', 'info');
            }
        };

        const copyDataToClipboard = async () => {
            if (loggedData.length === 0) {
                log('ðŸ“‹ No data to copy. Start data logging first.', 'info');
                showNotification('No data to copy - start logging first', 'warning');
                return;
            }
        
            try {
                // Format data as CSV
                const csvHeader = 'Timestamp,Relative_Time_ms,Data\n';
                const csvData = loggedData.map(entry => {
                    const timestamp = new Date(entry.timestamp).toISOString();
                    return `"${timestamp}",${entry.relativeTime},"${entry.data.replace(/"/g, '""')}"`;
                }).join('\n');
                
                const fullCsv = csvHeader + csvData;
                
                // Copy to clipboard
                await navigator.clipboard.writeText(fullCsv);
                
                const message = `${loggedData.length} data points copied to clipboard as CSV`;
                log(`ðŸ“‹ ${message}`, 'success');
                showNotification(message, 'success');
                
            } catch (error) {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                const csvHeader = 'Timestamp,Relative_Time_ms,Data\n';
                const csvData = loggedData.map(entry => {
                    const timestamp = new Date(entry.timestamp).toISOString();
                    return `"${timestamp}",${entry.relativeTime},"${entry.data.replace(/"/g, '""')}"`;
                }).join('\n');
                
                textArea.value = csvHeader + csvData;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                
                const message = `${loggedData.length} data points copied to clipboard`;
                log(`ðŸ“‹ ${message}`, 'success');
                showNotification(message, 'success');
            }
        };

        const toggleVoiceInput = () => {
            console.log('Voice input button clicked, isListening:', isListening, 'recognition:', !!recognition);
            
            if (!recognition) {
                log('ðŸŽ¤ Speech recognition not available. Please use a supported browser (Chrome, Edge, Safari) on HTTPS.', 'error');
                return;
            }

            try {
                if (isListening) {
                    log('ðŸŽ¤ Stopping speech recognition...', 'info');
                    recognition.stop();
                } else {
                    log('ðŸŽ¤ Starting speech recognition...', 'info');
                    recognition.start();
                }
            } catch (error) {
                log(`ðŸŽ¤ Error toggling speech recognition: ${error.message}`, 'error');
            }
        };

        // --- UI Update Functions ---
        const log = (message, type = 'info') => {
            const color = type === 'error' ? 'text-red-400' : type === 'success' ? 'text-green-400' : 'text-sky-400';
            output.innerHTML += `<span class="${color}">> ${message}\n</span>`;
            output.scrollTop = output.scrollHeight;
        };
        
        const logDeviceData = (data) => {
            // More specific error detection - only catch actual programming errors
            const hasError = !isStopping && (
                data.includes('SyntaxError') || 
                data.includes('NameError') || 
                data.includes('TypeError') || 
                data.includes('ValueError') ||
                data.includes('AttributeError') ||
                data.includes('IndentationError') ||
                data.includes('ImportError') ||
                (data.includes('Traceback') && 
                 !data.includes('KeyboardInterrupt') && 
                 (data.includes('SyntaxError') || data.includes('NameError') || data.includes('TypeError') || data.includes('ValueError')))
            );
            
            // If data logging is enabled, buffer and process complete lines
            if (isDataLogging && !hasError) {
                // Add incoming data to buffer
                dataBuffer += data;
                
                // Process complete lines (ending with \n or \r\n)
                const lines = dataBuffer.split(/\r?\n/);
                
                // Keep the last incomplete line in buffer
                dataBuffer = lines.pop() || '';
                
                // Process each complete line
                lines.forEach(line => {
                    const cleanLine = line.replace(/^>\s*/, '').replace(/>>>\s*/, '').trim();
                    
                    // Only log actual data (skip empty lines, prompts, system messages, errors)
                    if (cleanLine && 
                        !cleanLine.includes('MicroPython') && 
                        !cleanLine.includes('Type "help()"') &&
                        !cleanLine.includes('>>>') &&
                        !cleanLine.includes('paste mode') &&
                        !cleanLine.includes('soft reboot') &&
                        !cleanLine.includes('Traceback') &&
                        !cleanLine.includes('KeyboardInterrupt') &&
                        !cleanLine.includes('Error:') &&
                        !cleanLine.includes('Exception:')) {
                        
                        const timestamp = Date.now();
                        const relativeTime = dataStartTime ? timestamp - dataStartTime : 0;
                        
                        loggedData.push({
                            timestamp: timestamp,
                            relativeTime: relativeTime,
                            data: cleanLine
                        });
                    }
                });
            }
            
            if (hasError) {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error-border';
                errorDiv.textContent = data;
                output.appendChild(errorDiv);
                
                const errorMatch = data.match(/(.*Error:.*|.*Exception:.*)/);
                const cleanError = errorMatch ? errorMatch[1].trim() : data.trim();
                
                currentErrorData = {
                    fullOutput: output.textContent,
                    errorMessage: cleanError,
                    code: lastRunCode || codeEditor.value
                };
                
                errorDisplay.textContent = cleanError;
                errorModal.classList.remove('hidden');
            } else {
                output.textContent += data;
            }
            
            output.scrollTop = output.scrollHeight;
        };

        const updateUIForConnection = () => {
            statusText.textContent = 'Connected';
            statusDot.classList.remove('bg-red-500', 'animate-pulse');
            statusDot.classList.add('bg-green-500');
            connectButton.disabled = true;
            disconnectButton.disabled = false;
            runButton.disabled = false;
            stopButton.disabled = false;
            toggleDataLoggingButton.disabled = false;
            copyDataButton.disabled = false;
            log('micro:bit connected successfully!', 'success');
        };

        const updateUIForDisconnection = () => {
            statusText.textContent = 'Disconnected';
            statusDot.classList.remove('bg-green-500');
            statusDot.classList.add('bg-red-500', 'animate-pulse');
            connectButton.disabled = false;
            disconnectButton.disabled = true;
            runButton.disabled = true;
            stopButton.disabled = true;
            toggleDataLoggingButton.disabled = true;
            copyDataButton.disabled = true;
            
            // Stop data logging if disconnected
            if (isDataLogging) {
                toggleDataLogging();
            }
        };

        // --- Web Serial Core Functions ---
        async function connect() {
            try {
                if (!('serial' in navigator)) {
                    serialSupportMsg.classList.remove('hidden');
                    throw new Error('Web Serial API not available');
                }
                log('Requesting serial port...');
                port = await navigator.serial.requestPort({
                    filters: [{ usbVendorId: 0x0d28 }]
                });

                log('Opening port at 115200 baud...');
                await port.open({ 
                    baudRate: 115200,
                    dataBits: 8,
                    stopBits: 1,
                    parity: 'none',
                    flowControl: 'none'
                });

                startReadLoop();
                writer = port.writable.getWriter();
                updateUIForConnection();

                navigator.serial.addEventListener('disconnect', (e) => {
                    if (e.port === port) {
                        log('Device was disconnected.', 'error');
                        disconnect();
                    }
                });

            } catch (err) {
                if (err.message.includes('Failed to open serial port')) {
                    log('Connection failed: The serial port is already in use.', 'error');
                    log('Please close any other program using the micro:bit (e.g., Mu, Thonny) and try again.', 'info');
                } else {
                    log(`Connection failed: ${err.message}`, 'error');
                }
                await disconnect();
            }
        }

        async function disconnect() {
            try {
                // Stop the read loop and release reader
                if (reader) { 
                    try {
                        await reader.cancel();
                    } catch (e) {
                        console.error("Error canceling reader:", e);
                    }
                    reader = null;
                }
                
                // Release writer lock
                if (writer) { 
                    try {
                        writer.releaseLock();
                    } catch (e) {
                        console.error("Error releasing writer:", e);
                    }
                    writer = null;
                }
                
                // Give a small delay to ensure locks are fully released
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // Close the port
                if (port) { 
                    try {
                        await port.close();
                    } catch (e) {
                        console.error("Error closing port:", e);
                    }
                    port = null;
                }
            } catch (err) { 
                console.error("Error during disconnect:", err); 
            } finally { 
                updateUIForDisconnection(); 
                log('Disconnected.'); 
            }
        }

        async function startReadLoop() {
            try {
                const readerStream = port.readable.pipeThrough(new TextDecoderStream());
                reader = readerStream.getReader();
                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;
                    if (value) logDeviceData(value);
                }
            } catch (err) {
                if (!err.message.includes('The user aborted a request.')) { log(`Read error: ${err.message}`, 'error'); }
            }
        }

        async function sendString(str) {
            if (!writer) return;
            const data = textEncoder.encode(str);
            await writer.write(data);
        }

        const sleep = (ms) => new Promise(r => setTimeout(r, ms));

        async function runCode() {
            if (!port) { log('Cannot run code, device not connected.', 'error'); return; }
            
            const code = codeEditor.value;
            if (!code.trim()) {
                log('No code to run', 'error');
                return;
            }

            fixWithAiButton.classList.add('hidden');
            lastRunCode = code;
            
            const formattedCode = code.replace(/\r\n/g, '\n').replace(/\r/g, '\n').replace(/\n/g, '\r\n');
            log('Entering paste mode...');
            try {
                await sendString('\x03'); await sleep(120);
                await sendString('\x05'); await sleep(80);
                log('Sending code...');
                await sendString(formattedCode); await sleep(80);
                log('Executing...');
                await sendString('\x04'); await sleep(150);
                await sendString('\x02');
            } catch (err) { log(`Failed to run code: ${err.message}`, 'error'); await disconnect(); }
        }

        async function stopCode() {
            if (!port) {
                log('Not connected.', 'error');
                return;
            }
            isStopping = true;
            log('Stopping program and resetting REPL...');
            try {
                await sendString('\x03');
                await sleep(100);
                await sendString('\x02');
                log('Stop signal sent. Device should be ready.', 'info');
            } catch (err) {
                log(`Failed to send stop signal: ${err.message}`, 'error');
                await disconnect();
            } finally {
                setTimeout(() => { isStopping = false; }, 500);
            }
        }

        // --- Error Modal Functions ---
        const closeErrorModal = () => {
            errorModal.classList.add('hidden');
            currentErrorData = null;
        };

        const sendErrorToAI = async () => {
            if (!currentErrorData) return;
            
            const fixPrompt = `I'm having trouble with my micro:bit MicroPython code. Here's what happened:

ORIGINAL CODE:
\`\`\`python
${currentErrorData.code}
\`\`\`

ERROR OUTPUT:
\`\`\`
${currentErrorData.fullOutput.split('\n').slice(-20).join('\n')}
\`\`\`

Please analyze this error and provide a corrected version of the code. Focus on:
1. What caused the error
2. How to fix it  
3. A complete working version of the code

Remember this is for BBC micro:bit, so use micro:bit specific functions like temperature(), display.scroll(), sleep(), etc.`;

            closeErrorModal();
            aiChatModal.classList.remove('hidden');
            
            codeModeRadio.checked = true;
            updateModeUI();
            
            if (aiStatus === 'uninitialized') { 
                loadAISettings(); 
                setTimeout(() => {
                    if (aiStatus === 'ready') {
                        submitAIPrompt(fixPrompt);
                    } else {
                        aiPromptInput.value = "Help me fix this micro:bit error";
                        addMessageToChat('ai', 'AI is initializing. I have the error details and will help you fix it once ready.');
                    }
                }, 500);
            } else if (aiStatus === 'ready') {
                submitAIPrompt(fixPrompt);
            } else {
                aiPromptInput.value = "Help me fix this micro:bit error";
                addMessageToChat('ai', 'Please ensure AI is configured and ready, then ask for help with your error.');
            }
        };

        // --- AI Chat Functions ---
        const updateAIStatus = (newStatus, message) => {
            aiStatus = newStatus;
            aiStatusBadge.textContent = message;
            aiStatusBadge.className = 'px-2 py-0.5 text-xs font-semibold rounded-full ';
            switch (newStatus) {
                case 'ready':
                    aiStatusBadge.classList.add('bg-green-700', 'text-green-200');
                    aiPromptInput.disabled = false;
                    aiPromptSend.disabled = false;
                    break;
                case 'initializing': case 'busy':
                    aiStatusBadge.classList.add('bg-yellow-700', 'text-yellow-200');
                    aiPromptInput.disabled = true;
                    aiPromptSend.disabled = true;
                    break;
                case 'unavailable':
                    aiStatusBadge.classList.add('bg-red-700', 'text-red-200');
                    aiPromptInput.disabled = true;
                    aiPromptSend.disabled = true;
                    break;
            }
        };
        
        const addMessageToChat = (sender, content) => {
            const messageDiv = document.createElement('div');
            const contentDiv = document.createElement('div');
            
            if (sender === 'user') {
                messageDiv.className = "flex justify-end";
                contentDiv.className = "bg-blue-600 text-white p-3 rounded-lg max-w-xs md:max-w-md word-wrap break-words";
                contentDiv.innerHTML = content.replace(/\n/g, '<br>');
            } else {
                messageDiv.className = "flex justify-start";
                contentDiv.className = "bg-slate-700 text-slate-200 p-3 rounded-lg max-w-xs md:max-w-md word-wrap break-words prose prose-invert prose-sm max-w-none";
                contentDiv.innerHTML = renderMarkdown(content);
            }
            
            // Add proper word wrapping styles
            contentDiv.style.wordWrap = 'break-word';
            contentDiv.style.wordBreak = 'break-word';
            contentDiv.style.overflowWrap = 'break-word';
            contentDiv.style.hyphens = 'auto';
            
            messageDiv.appendChild(contentDiv);
            aiChatHistory.appendChild(messageDiv);
            aiChatHistory.scrollTop = aiChatHistory.scrollHeight;
            return contentDiv;
        };
        
        const renderMarkdown = (text) => {
            return text
                // Headers
                .replace(/^### (.*$)/gim, '<h3 class="text-lg font-semibold text-slate-100 mt-4 mb-2">$1</h3>')
                .replace(/^## (.*$)/gim, '<h2 class="text-xl font-semibold text-slate-100 mt-4 mb-2">$1</h2>')
                .replace(/^# (.*$)/gim, '<h1 class="text-2xl font-bold text-slate-100 mt-4 mb-2">$1</h1>')
                
                // Code blocks (must come before inline code)
                .replace(/```python\n([\s\S]*?)\n```/g, '<div class="bg-slate-900 border border-slate-600 rounded-md p-3 my-3 overflow-x-auto"><pre class="text-green-400 text-sm font-mono whitespace-pre-wrap">$1</pre></div>')
                .replace(/```([\s\S]*?)```/g, '<div class="bg-slate-900 border border-slate-600 rounded-md p-3 my-3 overflow-x-auto"><pre class="text-slate-300 text-sm font-mono whitespace-pre-wrap">$1</pre></div>')
                
                // Inline code
                .replace(/`([^`]+)`/g, '<code class="bg-slate-800 text-green-400 px-1 py-0.5 rounded text-sm font-mono">$1</code>')
                
                // Bold and italic
                .replace(/\*\*([^*]+)\*\*/g, '<strong class="font-semibold text-slate-100">$1</strong>')
                .replace(/\*([^*]+)\*/g, '<em class="italic text-slate-200">$1</em>')
                
                // Unordered lists
                .replace(/^\- (.+$)/gim, '<li class="ml-4 mb-1">â€¢ $1</li>')
                .replace(/^(\d+)\. (.+$)/gim, '<li class="ml-4 mb-1">$1. $2</li>')
                
                // Wrap consecutive list items
                .replace(/(<li[^>]*>.*<\/li>\s*)+/gs, '<ul class="my-2 space-y-1">$&</ul>')
                
                // Line breaks
                .replace(/\n\n/g, '</p><p class="mb-2">')
                .replace(/\n/g, '<br>')
                
                // Wrap in paragraphs if not already wrapped
                .replace(/^(?!<[hul])/gm, '<p class="mb-2">')
                .replace(/(?![>])$/gm, '</p>')
                
                // Clean up extra paragraph tags
                .replace(/<p class="mb-2"><\/p>/g, '')
                .replace(/<p class="mb-2">(<[hul])/g, '$1')
                .replace(/(<\/[hul][^>]*>)<\/p>/g, '$1');
        };
        const initializeAIProvider = async (provider) => {
            aiSession = null;
            conversationHistory = [];
            updateAIStatus('initializing', 'Initializing...');
            if (provider === 'nano') {
                try {
                    if (typeof LanguageModel === 'undefined') {
                        const isChrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
                        
                        if (!isChrome) {
                            throw new Error("Gemini Nano is only available in Chrome. Please use Chrome browser or switch to a cloud AI provider (Gemini, Claude, or ChatGPT) in the dropdown above.");
                        } else {
                            throw new Error("LanguageModel API not available. Try enabling chrome://flags/#prompt-api-for-gemini-nano in Chrome, then restart your browser.");
                        }
                    }
                    const availability = await LanguageModel.availability();
                    
                    if (availability === "after-download") {
                        updateAIStatus('initializing', 'Downloading...');
                        addMessageToChat('ai', 'Gemini Nano needs to be downloaded (several GB). This is a one-time download. The download will start automatically - please wait...');
                        // Trigger download by attempting to create session
                        aiSession = await LanguageModel.create({ initialPrompts: [{ role: 'system', content: NANO_SYSTEM_PROMPT }] });
                        updateAIStatus('ready', 'Ready');
                        addMessageToChat('ai', 'Gemini Nano is ready with micro:bit expertise. What would you like to create?');
                    } else if (availability === "readily" || availability === "available") {
                        aiSession = await LanguageModel.create({ initialPrompts: [{ role: 'system', content: NANO_SYSTEM_PROMPT }] });
                        updateAIStatus('ready', 'Ready');
                        addMessageToChat('ai', 'Gemini Nano is ready with micro:bit expertise. What would you like to create?');
                    } else {
                        throw new Error(`Nano model not ready. Status: ${availability}. Please try again later or use a cloud provider.`);
                    }
                } catch (error) {
                    updateAIStatus('unavailable', 'Error');
                    addMessageToChat('ai', `<b>Error:</b> ${error.message}`);
                }
            } else {
                if (apiKey) {
                    updateAIStatus('ready', 'Ready');
                    addMessageToChat('ai', `Ready to use ${provider.charAt(0).toUpperCase() + provider.slice(1)}. What would you like to create?`);
                } else {
                    updateAIStatus('unavailable', 'API Key Needed');
                    addMessageToChat('ai', `Please enter and save your API key for ${provider.charAt(0).toUpperCase() + provider.slice(1)}.`);
                }
            }
        };
        
        async function getAICode(prompt, provider, key, isCodeMode = true) {
             updateAIStatus('busy', 'Generating...');
             try {
                const systemPrompt = SYSTEM_PROMPT_FOR_MODE(provider, isCodeMode);
                
                if (provider === 'nano') {
                    if (!aiSession) throw new Error("Gemini Nano session not initialized.");
                    let fullPrompt = prompt;
                    const modeContext = isCodeMode ? 
                        "\n\nIMPORTANT: This is for BBC micro:bit CODE GENERATION. Use ONLY micro:bit functions:" :
                        "\n\nIMPORTANT: This is a QUESTION about micro:bit programming. Provide a helpful explanation.";
                    
                    if (conversationHistory.length > 0) {
                        const historyContext = conversationHistory.map(msg => 
                            `${msg.role}: ${msg.content}`
                        ).join('\n');
                        fullPrompt = `Previous conversation:\n${historyContext}\n\nCurrent request: ${prompt}${modeContext}
- from microbit import * (required first line for code)  
- temperature() for temperature sensor
- display.scroll(str(value)) to show text
- sleep(milliseconds) for delays
- NO machine, time, or other imports
- NO machine.ADC or machine.Pin
- Use the built-in temperature() function that returns degrees Celsius
- NEVER use f-strings like f"text {var}" - use str(var) + "text" instead`;
                    } else {
                        fullPrompt = `${prompt}${modeContext}
- from microbit import * (required first line for code)  
- temperature() for temperature sensor
- display.scroll(str(value)) to show text
- sleep(milliseconds) for delays
- NO machine, time, or other imports
- NO machine.ADC or machine.Pin
- Use the built-in temperature() function that returns degrees Celsius
- NEVER use f-strings like f"text {var}" - use str(var) + "text" instead`;
                    }
                    const stream = aiSession.promptStreaming(fullPrompt);
                    let fullResponse = "";
                    for await (const chunk of stream) { fullResponse += chunk; }
                    return fullResponse;
                }
                
                let url, headers, body;
                switch (provider) {
                    case 'gemini':
                        url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${key}`;
                        headers = { 'Content-Type': 'application/json' };
                        const geminiHistory = conversationHistory.length > 0 ? 
                            conversationHistory.map(msg => ({ 
                                parts: [{ text: msg.content }], 
                                role: msg.role === 'assistant' ? 'model' : 'user'
                            })) : [];
                        body = {
                            contents: [
                                ...geminiHistory,
                                { parts: [{ text: prompt }], role: 'user' }
                            ],
                            systemInstruction: { parts: [{ text: systemPrompt }] }
                        };
                        break;
                    case 'claude':
                        url = 'https://api.anthropic.com/v1/messages';
                        headers = { 
                            'x-api-key': key, 
                            'anthropic-version': '2023-06-01', 
                            'content-type': 'application/json',
                            'anthropic-dangerous-direct-browser-access': 'true'
                        };
                        const claudeMessages = conversationHistory.length > 0 ?
                            [...conversationHistory, { role: 'user', content: prompt }] :
                            [{ role: 'user', content: prompt }];
                        body = { 
                            model: 'claude-3-5-sonnet-20240620', 
                            max_tokens: 1024, 
                            system: systemPrompt, 
                            messages: claudeMessages 
                        };
                        break;
                    case 'chatgpt':
                        url = 'https://api.openai.com/v1/chat/completions';
                        headers = { 'Authorization': `Bearer ${key}`, 'Content-Type': 'application/json' };
                        const chatGPTMessages = [
                            { role: 'system', content: systemPrompt },
                            ...conversationHistory,
                            { role: 'user', content: prompt }
                        ];
                        body = { 
                            model: 'gpt-4', 
                            messages: chatGPTMessages 
                        };
                        break;
                    default:
                        throw new Error("Unknown AI provider.");
                }

                const response = await fetch(url, { method: 'POST', headers, body: JSON.stringify(body) });
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API request failed with status ${response.status}: ${errorText}`);
                }
                
                const data = await response.json();
                
                switch (provider) {
                    case 'gemini': return data.candidates[0].content.parts[0].text;
                    case 'claude': return data.content[0].text;
                    case 'chatgpt': return data.choices[0].message.content;
                }

            } catch(error) {
                console.error("AI Generation Error:", error);
                 if (provider === 'chatgpt' && error.message.includes('401')) {
                    throw new Error("The provided OpenAI API key is incorrect or invalid. Please check your key at platform.openai.com and save it again.");
                }
                 if (provider === 'claude' && error instanceof TypeError) {
                    throw new Error("Failed to fetch. This is likely a CORS error. The Anthropic API is not designed to be called directly from a browser and requires a server-side proxy, which cannot be implemented in this app.");
                }
                throw error;
            }
        }

        const updateModeUI = () => {
            const isCodeMode = codeModeRadio.checked;
            if (isCodeMode) {
                modeDescription.textContent = "Generate MicroPython code for your micro:bit";
                aiPromptInput.placeholder = "e.g., show a beating heart on the display";
            } else {
                modeDescription.textContent = "Ask questions about micro:bit programming, get explanations";
                aiPromptInput.placeholder = "e.g., how does the temperature sensor work?";
            }
        };

        async function submitAIPrompt(prompt) {
            if (!prompt || aiStatus !== 'ready') return;
            
            const timestamp = new Date().toISOString();
            const isCodeMode = codeModeRadio.checked;
            
            addMessageToChat('user', prompt);
            console.log('User Prompt:', prompt, 'Mode:', isCodeMode ? 'code' : 'question');
            aiPromptInput.value = '';
            
            fullChatHistory.push({
                timestamp: timestamp,
                provider: selectedProvider,
                role: 'user',
                content: prompt,
                mode: isCodeMode ? 'code' : 'question'
            });
            
            try {
                const responseText = await getAICode(prompt, selectedProvider, apiKey, isCodeMode);
                console.log('AI Response:', responseText);
                
                fullChatHistory.push({
                    timestamp: new Date().toISOString(),
                    provider: selectedProvider,
                    role: 'assistant',
                    content: responseText,
                    mode: isCodeMode ? 'code' : 'question'
                });
                
                conversationHistory.push({ role: 'user', content: prompt });
                conversationHistory.push({ role: 'assistant', content: responseText });
                
                if (conversationHistory.length > 20) {
                    conversationHistory = conversationHistory.slice(-20);
                }
                
                if (isCodeMode) {
                    const codeBlockRegex = /```python\n([\s\S]*?)\n```/;
                    const match = responseText.match(codeBlockRegex);

                    if (match && match[1]) {
                        const code = match[1];
                        codeEditor.value = code;
                        aiChatModal.classList.add('hidden');
                        log('AI-generated code inserted into the editor.', 'info');
                    } else {
                        addMessageToChat('ai', responseText || "Sorry, I couldn't generate a valid code snippet for that request.");
                    }
                } else {
                    addMessageToChat('ai', responseText || "Sorry, I couldn't provide an answer to that question.");
                }
            } catch (error) {
                addMessageToChat('ai', `<b>Error:</b> ${error.message}`);
            } finally {
                updateAIStatus('ready', 'Ready');
            }
        }
        const showNotification = (message, type = 'success', duration = 4000) => {
            notificationMessage.textContent = message;
            
            // Set colors based on type
            notificationToast.className = 'fixed top-6 right-6 px-6 py-4 rounded-lg shadow-2xl z-50 max-w-md transition-all duration-300 transform';
            switch (type) {
                case 'success':
                    notificationToast.classList.add('bg-green-600', 'text-white');
                    break;
                case 'error':
                    notificationToast.classList.add('bg-red-600', 'text-white');
                    break;
                case 'info':
                    notificationToast.classList.add('bg-blue-600', 'text-white');
                    break;
                case 'warning':
                    notificationToast.classList.add('bg-amber-600', 'text-white');
                    break;
                default:
                    notificationToast.classList.add('bg-slate-600', 'text-white');
            }
            
            // Show the notification
            notificationToast.classList.remove('hidden', 'translate-x-full', 'opacity-0');
            notificationToast.classList.add('translate-x-0', 'opacity-100');
            
            // Hide after duration
            setTimeout(() => {
                notificationToast.classList.remove('translate-x-0', 'opacity-100');
                notificationToast.classList.add('translate-x-full', 'opacity-0');
                setTimeout(() => {
                    notificationToast.classList.add('hidden');
                }, 300);
            }, duration);
        };

        function downloadChatHistory() {
            if (fullChatHistory.length === 0) {
                log('No chat history to download.', 'info');
                return;
            }
        
            const htmlContent = `
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>micro:bit AI Chat History</title>
            <style>
                body { font-family: system-ui, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; background: #f8fafc; line-height: 1.6; }
                .header { background: #1e293b; color: white; padding: 20px; border-radius: 10px; margin-bottom: 20px; }
                .chat-entry { background: white; margin: 15px 0; padding: 20px; border-radius: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
                .user { border-left: 4px solid #3b82f6; }
                .assistant { border-left: 4px solid #10b981; }
                .meta { font-size: 12px; color: #64748b; margin-bottom: 12px; font-weight: 600; }
                .content { color: #1f2937; }
                .content h1 { font-size: 1.5em; font-weight: bold; margin: 1em 0 0.5em 0; color: #111827; }
                .content h2 { font-size: 1.3em; font-weight: bold; margin: 1em 0 0.5em 0; color: #374151; }
                .content h3 { font-size: 1.1em; font-weight: bold; margin: 1em 0 0.5em 0; color: #4b5563; }
                .content strong { font-weight: 600; color: #111827; }
                .content em { font-style: italic; color: #374151; }
                .content code { background: #f3f4f6; color: #059669; padding: 2px 6px; border-radius: 4px; font-family: 'Courier New', Monaco, monospace; font-size: 0.9em; }
                .content .code-block { background: #1f2937; color: #e5e7eb; padding: 16px; border-radius: 8px; margin: 16px 0; overflow-x: auto; font-family: 'Courier New', Monaco, monospace; font-size: 0.9em; line-height: 1.5; white-space: pre-wrap; }
                .content .python-code { color: #10b981; }
                .content ul { margin: 12px 0; padding-left: 0; }
                .content li { margin: 6px 0; padding-left: 20px; position: relative; }
                .content li::before { content: "â€¢"; color: #6b7280; font-weight: bold; position: absolute; left: 0; }
                .content p { margin: 12px 0; }
                .provider-badge { display: inline-block; background: #e5e7eb; color: #374151; padding: 3px 8px; border-radius: 12px; font-size: 11px; font-weight: bold; text-transform: uppercase; }
                .stats { background: #dbeafe; padding: 20px; border-radius: 8px; margin-bottom: 20px; }
                .stats h3 { margin-top: 0; color: #1e40af; }
            </style>
        </head>
        <body>
            <div class="header">
                <h1>ðŸ¤– micro:bit AI Chat History</h1>
                <p>Generated on ${new Date().toLocaleString()}</p>
            </div>
            
            <div class="stats">
                <h3>Session Statistics</h3>
                <p><strong>Total Messages:</strong> ${fullChatHistory.length}</p>
                <p><strong>User Messages:</strong> ${fullChatHistory.filter(m => m.role === 'user').length}</p>
                <p><strong>AI Responses:</strong> ${fullChatHistory.filter(m => m.role === 'assistant').length}</p>
                <p><strong>Providers Used:</strong> ${[...new Set(fullChatHistory.map(m => m.provider))].join(', ')}</p>
                <p><strong>Session Start:</strong> ${fullChatHistory.length > 0 ? new Date(fullChatHistory[0].timestamp).toLocaleString() : 'N/A'}</p>
                <p><strong>Session End:</strong> ${fullChatHistory.length > 0 ? new Date(fullChatHistory[fullChatHistory.length - 1].timestamp).toLocaleString() : 'N/A'}</p>
            </div>
        
            ${fullChatHistory.map(entry => {
                const roleClass = entry.role;
                const roleName = entry.role === 'user' ? 'ðŸ‘¤ You' : 'ðŸ¤– AI';
                const time = new Date(entry.timestamp).toLocaleString();
                
                let content;
                if (entry.role === 'assistant') {
                    // Use the same renderMarkdown function as in the app
                    content = renderMarkdown(entry.content);
                } else {
                    // User messages - simple HTML escaping and line breaks
                    content = entry.content
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(/\n/g, '<br>');
                }
                
                return `
                <div class="chat-entry ${roleClass}">
                    <div class="meta">
                        ${roleName} 
                        <span class="provider-badge">${entry.provider}</span>
                        <span style="float: right;">${time}</span>
                    </div>
                    <div class="content">${content}</div>
                </div>`;
            }).join('')}
        
            <div style="margin-top: 40px; text-align: center; color: #64748b; font-size: 12px;">
                <p>Generated by micro:bit MicroPython Editor</p>
            </div>
        </body>
        </html>`;
        
            const blob = new Blob([htmlContent], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `microbit-ai-chat-history-${new Date().toISOString().split('T')[0]}.html`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            log('Chat history downloaded successfully!', 'success');
        }
        const loadAISettings = () => {
            selectedProvider = localStorage.getItem('ai_provider') || 'nano';
            apiKey = localStorage.getItem(`ai_key_${selectedProvider}`) || '';
            aiProviderSelect.value = selectedProvider;
            apiKeyInput.value = apiKey;
            updateAIProviderUI();
        };

        const saveAISettings = () => {
            selectedProvider = aiProviderSelect.value;
            apiKey = apiKeyInput.value.trim();
            localStorage.setItem('ai_provider', selectedProvider);
            if (selectedProvider !== 'nano') {
                localStorage.setItem(`ai_key_${selectedProvider}`, apiKey);
            }
            addMessageToChat('ai', 'Settings saved.');
            initializeAIProvider(selectedProvider);
        };
        
        const updateAIProviderUI = () => {
            selectedProvider = aiProviderSelect.value;
            localStorage.setItem('ai_provider', selectedProvider);
            aiChatHistory.innerHTML = '';
            conversationHistory = [];
            if (selectedProvider === 'nano') {
                apiKeyGroup.classList.add('hidden');
                initializeAIProvider('nano');
            } else {
                apiKeyLabel.textContent = `${selectedProvider.charAt(0).toUpperCase() + selectedProvider.slice(1)} API Key:`;
                apiKeyGroup.classList.remove('hidden');
                apiKey = localStorage.getItem(`ai_key_${selectedProvider}`) || '';
                apiKeyInput.value = apiKey;
                initializeAIProvider(selectedProvider);
            }
        };

        const initializeApp = () => {
            updateUIForDisconnection();
            selectedProvider = localStorage.getItem('ai_provider') || 'nano';
            aiProviderSelect.value = selectedProvider;
            
            // Initialize speech recognition if available
            const speechAvailable = initializeSpeechRecognition();
            if (!speechAvailable) {
                log('Speech recognition not available in this browser.', 'info');
            }
        };

        // Event Listeners
        if (!('serial' in navigator)) { serialSupportMsg.classList.remove('hidden'); }
        
        connectButton.addEventListener('click', connect);
        disconnectButton.addEventListener('click', disconnect);
        runButton.addEventListener('click', runCode);
        stopButton.addEventListener('click', stopCode);
        toggleDataLoggingButton.addEventListener('click', toggleDataLogging);
        copyDataButton.addEventListener('click', copyDataToClipboard);
        clearOutputButton.addEventListener('click', () => { 
            output.innerHTML = ''; 
            fixWithAiButton.classList.add('hidden');
        });

        errorModalClose.addEventListener('click', closeErrorModal);
        dismissErrorButton.addEventListener('click', closeErrorModal);
        aiFixButton.addEventListener('click', sendErrorToAI);

        aiChatButton.addEventListener('click', () => {
            aiChatModal.classList.remove('hidden');
            if (aiStatus === 'uninitialized') { loadAISettings(); }
        });
        aiModalCloseButton.addEventListener('click', () => { aiChatModal.classList.add('hidden'); });
        aiProviderSelect.addEventListener('change', updateAIProviderUI);
        saveApiKeyButton.addEventListener('click', saveAISettings);
        downloadHistoryButton.addEventListener('click', downloadChatHistory);
        
        codeModeRadio.addEventListener('change', updateModeUI);
        questionModeRadio.addEventListener('change', updateModeUI);
        voiceInputButton.addEventListener('click', toggleVoiceInput);
        
        aiPromptForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            submitAIPrompt(aiPromptInput.value.trim());
        });

        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    if (!runButton.disabled) {
                        runCode();
                    }
                }
            }
        });

        initializeApp();

    </script>
</body>
</html>