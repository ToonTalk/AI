<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Rainbow Bubble Pop</title>
  <link rel="stylesheet" href="style.css">
  <style>
    body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; }
    #canvas { width: 100%; height: 100%; display: block; cursor: pointer; }
    #overlay { position: fixed; bottom: 1rem; left: 50%; transform: translateX(-50%); background: rgba(255,255,255,0.8); color: #4a3d99; padding: 0.5rem 1rem; border-radius: 8px; font-size: 1rem; text-align: center; }
  </style>
</head>
<body>
  <a class="back" href="index.html">‚Üê Back</a>
  <canvas id="canvas"></canvas>
  <div id="overlay">Pop the colourful bubbles to play their notes!</div>
  <script>
  (function() {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let width, height;
    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
    }
    window.addEventListener('resize', resize);
    resize();

    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();
    function beep(freq, dur = 0.25) {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.value = freq;
      gain.gain.setValueAtTime(0.12, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
      osc.connect(gain).connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + dur);
    }

    class Bubble {
      constructor() {
        this.reset();
      }
      reset() {
        this.radius = 20 + Math.random() * 20;
        this.x = Math.random() * width;
        this.y = height + Math.random() * height;
        this.vx = (Math.random() - 0.5) * 20;
        this.vy = - (30 + Math.random() * 40);
        this.hue = Math.random() * 360;
        this.popping = false;
        this.popProgress = 0;
      }
      update(dt) {
        if (!this.popping) {
          this.x += this.vx * dt;
          this.y += this.vy * dt;
          // bounce horizontally
          if (this.x - this.radius < 0) { this.x = this.radius; this.vx *= -1; }
          if (this.x + this.radius > width) { this.x = width - this.radius; this.vx *= -1; }
          // reset if gone
          if (this.y + this.radius < 0) {
            this.reset();
          }
        } else {
          this.popProgress += dt * 3;
          if (this.popProgress >= 1) {
            this.reset();
          }
        }
      }
      draw() {
        ctx.save();
        ctx.globalAlpha = 0.6;
        if (!this.popping) {
          const gradient = ctx.createRadialGradient(this.x, this.y, this.radius * 0.2, this.x, this.y, this.radius);
          gradient.addColorStop(0, `hsla(${this.hue},80%,80%,0.8)`);
          gradient.addColorStop(1, `hsla(${this.hue},80%,60%,0.2)`);
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fill();
        } else {
          // popping animation: expanding ring
          const r = this.radius * (1 + this.popProgress);
          const alpha = 1 - this.popProgress;
          ctx.strokeStyle = `hsla(${this.hue},80%,70%,${alpha})`;
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.arc(this.x, this.y, r, 0, Math.PI * 2);
          ctx.stroke();
        }
        ctx.restore();
      }
    }

    const bubbles = [];
    for (let i = 0; i < 15; i++) {
      bubbles.push(new Bubble());
    }

    canvas.addEventListener('click', (e) => {
      audioCtx.resume();
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      // find bubble under click
      for (const b of bubbles) {
        if (!b.popping) {
          const dx = b.x - x;
          const dy = b.y - y;
          if (Math.hypot(dx, dy) < b.radius) {
            b.popping = true;
            b.popProgress = 0;
            const freq = 300 + (80 - b.radius) * 5;
            beep(freq);
            break;
          }
        }
      }
    });

    let last = performance.now();
    function animate(now) {
      const dt = (now - last) / 1000;
      last = now;
      ctx.clearRect(0, 0, width, height);
      for (const b of bubbles) {
        b.update(dt);
        b.draw();
      }
      requestAnimationFrame(animate);
    }
    animate(last);
  })();
  </script>
</body>
</html>