<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Metaversal Expressionism</title>
  <style>
    html, body { margin:0; height:100%; background:#01050b; overflow:hidden; }
    canvas { display:block; }
  </style>
</head>
<body>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
window.addEventListener('resize', resize); resize();

// Grid lines
function drawGrid() {
  ctx.strokeStyle = 'rgba(50, 80, 110, 0.3)';
  ctx.lineWidth = 1;
  const spacing = 40;
  for (let x=0; x<canvas.width; x+=spacing) {
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x, canvas.height); ctx.stroke();
  }
  for (let y=0; y<canvas.height; y+=spacing) {
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width, y); ctx.stroke();
  }
}

// Expressionistic stroke class: a path of points drawn with expressive color and fade
class Stroke {
  constructor() {
    this.reset();
  }
  reset() {
    this.points = [];
    // random starting position
    this.x = Math.random()*canvas.width;
    this.y = Math.random()*canvas.height;
    // random angle and speed
    this.angle = Math.random() * Math.PI*2;
    this.speed = 1 + Math.random() * 2;
    // color
    this.hue = Math.random()*360;
    this.life = 0;
    this.maxLife = 200 + Math.random()*100;
  }
  update() {
    // create new point
    this.points.push({x: this.x, y: this.y});
    // random wander
    this.angle += (Math.random()-0.5) * 0.3;
    this.x += Math.cos(this.angle) * this.speed;
    this.y += Math.sin(this.angle) * this.speed;
    // bound check
    if (this.x < 0) this.x = canvas.width;
    if (this.x > canvas.width) this.x = 0;
    if (this.y < 0) this.y = canvas.height;
    if (this.y > canvas.height) this.y = 0;
    this.life++;
    if (this.life > this.maxLife) this.reset();
    // limit points to keep memory small
    if (this.points.length > 60) this.points.shift();
  }
  draw() {
    ctx.lineWidth = 6;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    ctx.strokeStyle = `hsla(${this.hue}, 80%, 65%, 0.7)`;
    ctx.beginPath();
    for (let i=0; i<this.points.length; i++) {
      const p = this.points[i];
      if (i === 0) ctx.moveTo(p.x, p.y);
      else ctx.lineTo(p.x, p.y);
    }
    ctx.stroke();
  }
}

const strokes = [];
for (let i=0; i<10; i++) strokes.push(new Stroke());

function animate() {
  // draw slight translucent overlay for trailing effect
  ctx.fillStyle = 'rgba(1,5,11,0.1)';
  ctx.fillRect(0,0,canvas.width, canvas.height);
  drawGrid();
  strokes.forEach(s => { s.update(); s.draw(); });
  requestAnimationFrame(animate);
}
// initial fill
ctx.fillStyle = '#01050b';
ctx.fillRect(0,0,canvas.width, canvas.height);
drawGrid();
animate();
</script>
</body>
</html>