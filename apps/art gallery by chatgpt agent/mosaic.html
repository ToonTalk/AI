<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Tidal Memory Mosaic</title>
  <link rel="stylesheet" href="style.css">
  <style>
    body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; background: radial-gradient(circle, #021017 0%, #01060f 100%); }
    #canvas { width: 100%; height: 100%; display: block; cursor: pointer; }
    #overlay { position: fixed; bottom: 1rem; left: 50%; transform: translateX(-50%); color: #fff; background: rgba(0,0,0,0.6); padding: 0.5rem 1rem; border-radius: 8px; font-size: 1rem; text-align: center; }
    a.back { position: fixed; top: 1rem; left: 1rem; color: #ffcf6b; text-decoration: none; font-size: 1.2rem; }
  </style>
</head>
<body>
  <a class="back" href="index.html">‚Üê Back</a>
  <canvas id="canvas"></canvas>
  <div id="overlay">Click a tile to add a memory. Your words will briefly appear and sound a tone based on its column.</div>
  <script>
  (function() {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let width, height;
    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
      initGrid();
    }
    window.addEventListener('resize', resize);
    // grid dimensions
    let cols = 10;
    let rows = 6;
    const cells = [];
    function initGrid() {
      cells.length = 0;
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          cells.push({ phase: Math.random() * Math.PI * 2, memory: '', showUntil: 0 });
        }
      }
    }
    initGrid();

    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();
    function beep(freq, dur = 0.25) {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.value = freq;
      gain.gain.setValueAtTime(0.12, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
      osc.connect(gain).connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + dur);
    }

    canvas.addEventListener('click', (e) => {
      audioCtx.resume();
      const rect = canvas.getBoundingClientRect();
      const xPos = e.clientX - rect.left;
      const yPos = e.clientY - rect.top;
      const cellW = width / cols;
      const cellH = height / rows;
      const cx = Math.floor(xPos / cellW);
      const cy = Math.floor(yPos / cellH);
      const index = cy * cols + cx;
      const memory = prompt('Enter a memory or thought:');
      if (memory && memory.trim()) {
        cells[index].memory = memory.trim();
        cells[index].showUntil = performance.now() + 5000;
        // column based frequency: map column to scale
        const freq = 200 + cx * 40;
        beep(freq);
      }
    });

    function animate(now) {
      const cellW = width / cols;
      const cellH = height / rows;
      ctx.clearRect(0, 0, width, height);
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          const idx = y * cols + x;
          const cell = cells[idx];
          const phase = cell.phase;
          const t = now / 1000;
          const value = Math.sin(t * 1.5 + phase) * 0.5 + 0.5;
          const hue = 180 + value * 40;
          const sat = 50 + value * 20;
          const light = 30 + value * 30;
          ctx.fillStyle = `hsl(${hue},${sat}%,${light}%)`;
          ctx.fillRect(x * cellW, y * cellH, cellW, cellH);
          if (cell.memory && cell.showUntil > now) {
            const fade = Math.min(1, (cell.showUntil - now) / 5000);
            ctx.fillStyle = `rgba(255,255,255,${fade})`;
            ctx.font = `${Math.min(cellH * 0.3, 18)}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(cell.memory, x * cellW + cellW / 2, y * cellH + cellH / 2);
          }
        }
      }
      requestAnimationFrame(animate);
    }
    resize();
    requestAnimationFrame(animate);
  })();
  </script>
</body>
</html>