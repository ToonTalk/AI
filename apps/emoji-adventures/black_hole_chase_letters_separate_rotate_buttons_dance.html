<!DOCTYPE html>
<html>
    <head>
        <title>Emoji Adventures: Play and Interact with Emojis</title>
        <style>

            .emoji {
                position: fixed;
                pointer-events: none;
                /* Ignore mouse events on emojis */
                transition: font-size 0.5s;
                /* Smooth transition for size change */
            }

            #emojiContainer {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                z-index: 1; /* Lower than buttons */
            }
            
            #buttonContainer {
                position: fixed;
                left: 20px;
                display: flex;
                flex-direction: column;
                align-items: flex-start;
                z-index: 20; /* Ensure it's higher than the emoji container */
            }
            
            #microphoneContainer, #blackHoleContainer, #dancingContainer, #chaseContainer, #randomContainer, #helpButton {
                font-size: 6vh; /* Adjust the size based on viewport height */
                position: relative; /* This is crucial for correct positioning of the stop sign */
                z-index: 10; /* Ensures buttons are above emojis */
            }
            
            .stopSign {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                display: block; /* Changed from flex to block */
                pointer-events: none; /* The stop sign won't block click events */
                z-index: 10; /* Ensures buttons are above emojis */
            }
            
            .stopSign svg {
                width: 100%;
                height: auto; /* Adjust height to maintain aspect ratio */
            }

            #microphoneButton, #helpButton, #blackHoleButton, #chaseButton, #dancingButton, #smallerButton, #biggerButton, #fasterButton, #slowerButton, #randomButton {
                font-size: 6vh; 
                cursor: pointer;
                position: relative;
                z-index: 10; /* Ensures buttons are above emojis */
            }

        </style>
    </head>
    <body>
        <div id="feedbackDisplay" style="font-size: 4vh; text-align: center; display: none;"></div>
        <div id="buttonContainer">
            <div id="microphoneContainer">
                <div id="microphoneButton">üé§</div>
                <div class="stopSign" style="display: none;">
                    <svg viewBox="0 0 50 50">
                        <circle cx="25" cy="25" r="23" stroke="red" stroke-width="4" fill="none" />
                        <line x1="10" y1="10" x2="40" y2="40" stroke="red" stroke-width="4" />
                    </svg>
                </div>
            </div>

            <div id="blackHoleContainer">
                <div id="blackHoleButton">üåÄ</div>
                <div id="stopSignBlackHole" class="stopSign" style="display: none;">
                    <svg width="50" height="50" viewBox="0 0 50 50">
                        <circle cx="25" cy="25" r="23" stroke="red" stroke-width="4" fill="none" />
                        <line x1="10" y1="10" x2="40" y2="40" stroke="red" stroke-width="4" />
                    </svg> 
                </div>
            </div>
            <div id="dancingContainer">
                <div id="dancingButton">üíÉ</div> <!-- or use üï∫ for Man Dancing -->
                <div class="stopSign" style="display: none;"> 
                    <svg width="50" height="50" viewBox="0 0 50 50">
                        <circle cx="25" cy="25" r="23" stroke="red" stroke-width="4" fill="none" />
                        <line x1="10" y1="10" x2="40" y2="40" stroke="red" stroke-width="4" />
                    </svg>
                </div>
            </div>
            <div id="chaseContainer">
                <div id="chaseButton">üèÉ</div>
                <div class="stopSign" style="display: none;">
                    <svg width="50" height="50" viewBox="0 0 50 50">
                        <circle cx="25" cy="25" r="23" stroke="red" stroke-width="4" fill="none" />
                        <line x1="10" y1="10" x2="40" y2="40" stroke="red" stroke-width="4" />
                    </svg> 
                </div>
            </div>
            <div id="slowerButton">üê¢</div>
            <div id="fasterButton">üêé</div>
            <div id="smallerButton">üêú</div>
            <div id="biggerButton">üêò</div>
            <div id="randomContainer">
                <div id="randomButton">üé≤</div>
                <div class="stopSign" style="display: flex;"> <!-- Initially visible -->
                    <svg width="50" height="50" viewBox="0 0 50 50">
                        <circle cx="25" cy="25" r="23" stroke="red" stroke-width="4" fill="none" />
                        <line x1="10" y1="10" x2="40" y2="40" stroke="red" stroke-width="4" />
                    </svg>
                </div>
            </div>
            <div id="helpButton">‚ùì</div> 
        </div>
        <div id="emojiContainer"></div>
        <script src='emoji_dict.js'></script>
        <script src='ascii_letters.js'></script>
        <script>
            let useModel;

            let emojiDescriptions = [];
            // Array to store emoji descriptions
            let emojiDescriptionsEmbeddings;
            // Variable to store precomputed embeddings

            async function loadUSEModel() {
                // Function to dynamically load a script
                function loadScript(url) {
                    return new Promise((resolve, reject) => {
                        const script = document.createElement('script');
                        script.src = url;
                        script.onload = resolve;
                        script.onerror = reject;
                        document.head.appendChild(script);
                    });
                }
            
                try {
                    // Load TensorFlow.js
                    await loadScript('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs');
                    // Load Universal Sentence Encoder
                    await loadScript('https://cdn.jsdelivr.net/npm/@tensorflow-models/universal-sentence-encoder');
            
                    // TensorFlow.js and USE are now loaded and can be used
                    useModel = await use.load();
            
                    // Populate emojiDescriptions array from emojiDict
                    emojiDescriptions = Object.keys(emojiDict);
            
                    // Compute and store embeddings for all emoji descriptions
                    emojiDescriptionsEmbeddings = await useModel.embed(emojiDescriptions);
                    onUSEModelLoaded();
                } catch (error) {
                    console.error('Error loading scripts:', error);
                }
            }

            function speak(text) {
                if (false && 'speechSynthesis' in window) {
                    const voices = window.speechSynthesis.getVoices();
                    if (voices.length > 0) {
                        const msg = new SpeechSynthesisUtterance(text);
                        msg.voice = voices.find(voice => voice.lang === 'en-US') || voices[0];
                        window.speechSynthesis.speak(msg);
                    } else {
                        const sentences = text.split('. '); // Split text into sentences
                        displayFeedback(sentences); // Display text if no voices are available
                    }
                } else {
                    const sentences = text.split('. '); // Split text into sentences
                    displayFeedback(sentences); // Display text if speech synthesis is not supported
                }
            }

            function onUSEModelLoaded() {
                const message = "I can now understand almost anything you say."
                speak(message);
                displayFeedback(message);
            }

            async function findClosestEmojiDescription(userInput) {
                const userInputEmbedding = await useModel.embed([userInput]);
            
                // Compute cosine proximity between user input and all emoji descriptions
                const cosineProximities = tf.metrics.cosineProximity(userInputEmbedding, emojiDescriptionsEmbeddings);
            
                // Temporary variable for the argMin tensor
                const closestEmojiTensor = cosineProximities.argMin();
                const closestEmojiIndex = (await closestEmojiTensor.data())[0];
            
                // Dispose tensors to free memory
                userInputEmbedding.dispose();
                cosineProximities.dispose();
                closestEmojiTensor.dispose(); // Dispose the argMin tensor
            
                return emojiDescriptions[closestEmojiIndex];
            }

            let emojiSpeed = 2; // Default speed for emoji movement
            let gravityStrength = 1000; // Default strength for gravity
            let emojiSize = 50;
            let currentEmoji = "";
            let mouseDown = false;
            let listening = false;
            const recognition = new webkitSpeechRecognition();
            recognition.continuous = true;
            recognition.lang = 'en-US';
            recognition.interimResults = true;
            recognition.maxAlternatives = 1;

            function createEmojiElement(x, y, emoji) {
                let emojiElement = document.createElement('div');
                emojiElement.classList.add('emoji');
                emojiElement.textContent = emoji || currentEmoji || Object.values(emojiDict)[Math.floor(Math.random() * Object.values(emojiDict).length)];
                emojiElement.style.left = x + 'px';
                emojiElement.style.top = y + 'px';
                emojiElement.style.fontSize = emojiSize + 'px';
                emojiElement.velocity = {
                    x: 0,
                    y: 0
                };
                const emojiContainer = document.getElementById('emojiContainer');
                emojiContainer.appendChild(emojiElement);
                return emojiElement;
            }

            function showFeedbackEmoji(emoji) {
                let feedbackEmoji = document.createElement('div');
                feedbackEmoji.textContent = emoji;
                feedbackEmoji.style.position = 'fixed';
                feedbackEmoji.style.left = '50%';
                feedbackEmoji.style.top = '50%';
                feedbackEmoji.style.transform = 'translate(-50%, -50%)';
                feedbackEmoji.style.fontSize = '100px';
                feedbackEmoji.style.zIndex = '1000';
                document.body.appendChild(feedbackEmoji);
                setTimeout(() => feedbackEmoji.remove(), 2000);
                // Remove after 2 seconds
            }

            recognition.onresult = function(event) {
                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) {
                        const command = event.results[i][0].transcript.trim().toLowerCase();

                        // Skip processing if the command is an empty string
                        if (!command) {
                            continue;
                            // Skip to the next loop iteration
                        }

                        console.log("Spoken:", command);
                        displayFeedback(command); 

                        if (command.startsWith('spell ')) {
                            const wordsToSpell = command.substring(6); // Extract the words after "spell "
                            spellWords(wordsToSpell);
                            updateSpellMode();
                        } else if (command.includes('dance')) {
                            dance();
                            toggleStopSign('dancingContainer');
                        } else if (command.includes('black hole')) {
                            blackHoleActive = !blackHoleActive;
                            updateBlackHoleMode();
                            toggleStopSign('blackHoleContainer');
                        } else if (command.includes('chase')) {
                            toggleChaseMode();
                            toggleStopSign('chaseContainer');
                        } else if (command.includes('random')) {
                            toggleRandom();
                        } else if (command.includes('bigger')) {
                            emojiSize *= 1.5;
                        } else if (command.includes('smaller')) {
                            emojiSize *= 2/3;
                        } else if (command.includes('faster')) {
                            emojiSpeed *= 1.5; // Increase speed by 50%
                            gravityStrength *= 1.5; // Increase gravity strength by 50%
                        } else if (command.includes('slower')) {
                            emojiSpeed *= 2/3; // Decrease speed by 33%
                            gravityStrength *= 2/3; // Decrease gravity strength by 33%
                        } else if (emojiDict[command]) {
                            currentEmoji = emojiDict[command];
                            showFeedbackEmoji(currentEmoji);
                        } else if (useModel) {
                            // If USE model is loaded and no exact match is found
                            findClosestEmojiDescription(command).then(closestEmojiDescription => {
                                if (closestEmojiDescription && emojiDict[closestEmojiDescription]) {
                                    currentEmoji = emojiDict[closestEmojiDescription];
                                    showFeedbackEmoji(currentEmoji);
                                    console.log("->", closestEmojiDescription);
                                }
                            });
                        }
                    }
                }

            };

            recognition.onend = function() {
                console.log("Speech recognition service disconnected");
                if (listening) {
                    // Assuming 'listening' is a flag indicating whether recognition should be active
                    recognition.start();
                }
            };

            recognition.onerror = function(event) {
                console.error("Speech recognition error", event.error);
                // Optionally restart recognition or handle differently based on the error
            };

            document.addEventListener('click', function(e) {
                createEmojiElement(e.clientX, e.clientY);
            });

            document.addEventListener('touchstart', function(e) {
                if (!e.touches.length)
                    return;
                let touch = e.touches[0];
                createEmojiElement(touch.clientX, touch.clientY);
            });

            function createBlackHole() {
                let blackHole = document.createElement('div');
                blackHole.id = 'blackHole';
                blackHole.style.width = '50px';
                blackHole.style.height = '50px';
                blackHole.style.borderRadius = '50%';
                blackHole.style.backgroundColor = 'black';
                blackHole.style.position = 'fixed';
                blackHole.style.display = 'none';
                // Initially hidden
                document.body.appendChild(blackHole);
                return blackHole;
            }

            let blackHole = createBlackHole();
            let blackHoleActive = false;

            // Function to move the black hole
            function moveBlackHole(x, y) {
                blackHole.style.left = x + 'px';
                blackHole.style.top = y + 'px';
                blackHole.style.display = 'block';
            }

            // Event listeners for mouse and touch movement
            document.addEventListener('mousemove', function(e) {
                if (blackHoleActive) {
                    moveBlackHole(e.clientX, e.clientY);
                }
            });

            document.addEventListener('touchmove', function(e) {
                if (blackHoleActive && e.touches.length) {
                    let touch = e.touches[0];
                    moveBlackHole(touch.clientX, touch.clientY);
                }
            });

            let isChaseMode = false;

            function updateChaseMode() {
                let emojis = document.querySelectorAll('.emoji');
                let chasers = new Map();
                
                // Determine chasers for each emoji
                emojis.forEach(emoji => {
                    chasers.set(emoji, []);
                });

                // Determine chasers for each emoji
                emojis.forEach(emoji => {
                    const target = emojiTargets.get(emoji);
                    if (target && !target.isRemoved) {
                        const targetChasers = chasers.get(target);
                        if (targetChasers) {
                            targetChasers.push(emoji);
                        }
                    }
                });
                
               let processedCount = 0;
               const maxUpdateTime = 16; // milliseconds
               const startTime = performance.now();
                
               while (processedCount < emojis.length) {
                   if (performance.now() - startTime > maxUpdateTime) {
                      break; // Exit the loop if maximum update time is exceeded
                    }
                
                    // Pick a random emoji
                    const randomIndex = Math.floor(Math.random() * emojis.length);
                    const emoji = emojis[randomIndex];
                
                    let target = emojiTargets.get(emoji);

                    // Check if the target is still valid
                    if (!target || target.isRemoved) {
                        assignNewTarget(emoji);
                        // Assign a new target
                        target = emojiTargets.get(emoji);
                        // Update the target reference
                    }
    
                    if (target && !target.isRemoved) {
                        // Calculate distance to the target
                        const dx = target.offsetLeft - emoji.offsetLeft;
                        const dy = target.offsetTop - emoji.offsetTop;
                        const distance = Math.sqrt(dx * dx + dy * dy);
    
                        // Remove target and assign a new one if distance is small enough
                        if (distance < 10) {
                            // Threshold for reaching the target
                            target.remove();
                            target.isRemoved = true;
                            assignNewTarget(emoji);
                            // Assign a new target
                        } else {
                            // Calculate attraction towards the target
                            let dx = target.offsetLeft - emoji.offsetLeft;
                            let dy = target.offsetTop - emoji.offsetTop;
                            let distance = Math.sqrt(dx * dx + dy * dy);
                            let attraction = {
                                x: dx / distance,
                                y: dy / distance
                            };
    
                            // Calculate repulsion from chasers
                            let repulsion = {
                                x: 0,
                                y: 0
                            };
                            chasers.get(emoji).forEach(chaser => {
                                let rdx = emoji.offsetLeft - chaser.offsetLeft;
                                let rdy = emoji.offsetTop - chaser.offsetTop;
                                let rDistance = Math.sqrt(rdx * rdx + rdy * rdy);
                                rDistance = Math.max(rDistance, 1);
                                // Avoid division by zero
                                repulsion.x += rdx / rDistance;
                                repulsion.y += rdy / rDistance;
                            });
    
                            // Combine attraction and repulsion
                            const speed = emojiSpeed; // Use the global emojiSpeed variable
                            let vx = (attraction.x + repulsion.x) * speed;
                            let vy = (attraction.y + repulsion.y) * speed;
    
                            const windowWidth = window.innerWidth;
                            const windowHeight = window.innerHeight;
    
                            // Calculate new position with boundaries
                            let newX = emoji.offsetLeft + vx;
                            let newY = emoji.offsetTop + vy;
    
                            // Only rotate the emoji if it is moving
                            if (vx !== 0 || vy !== 0) {
                                // Calculate the angle of motion
                                const angle = Math.atan2(vy, vx) * 180 / Math.PI + 90;
                                
                                // Rotate the emoji to face the direction of motion
                                emoji.style.transform = `rotate(${angle}deg)`;
                            }
    
                            // Boundary checks and adjustments
                            if (newX < 0) {
                                newX = 0;
                                vx = -vx;
                                // Reverse horizontal velocity
                            } else if (newX + emoji.offsetWidth > windowWidth) {
                                newX = windowWidth - emoji.offsetWidth;
                                vx = -vx;
                                // Reverse horizontal velocity
                            }
    
                            if (newY < 0) {
                                newY = 0;
                                vy = -vy;
                                // Reverse vertical velocity
                            } else if (newY + emoji.offsetHeight > windowHeight) {
                                newY = windowHeight - emoji.offsetHeight;
                                vy = -vy;
                                // Reverse vertical velocity
                            }
    
                            // Update position with boundaries
                            emoji.style.left = newX + 'px';
                            emoji.style.top = newY + 'px';
                        }
                
                        processedCount++;
                    }
               }

               if (isChaseMode) {
                   requestAnimationFrame(updateChaseMode);
               }
            }

            function moveEmojiTowardsTarget(emoji, target) {
                const speed = emojiSpeed;
            
                // Current position of the emoji
                const emojiX = parseFloat(emoji.style.left);
                const emojiY = parseFloat(emoji.style.top);
            
                // Target position
                const targetX = parseFloat(target.style.left);
                const targetY = parseFloat(target.style.top);
            
                // Calculate distance to target
                const dx = targetX - emojiX;
                const dy = targetY - emojiY;
                const distance = Math.sqrt(dx * dx + dy * dy);
            
                // If the emoji is close enough to the target, stop moving
                if (distance < 1) {
                    return;
                }
            
                // Calculate movement vector
                const vx = (dx / distance) * speed;
                const vy = (dy / distance) * speed;

                // Only rotate the emoji if it is moving
                if (vx !== 0 || vy !== 0) {
                    // Calculate the angle of motion and adjust by 90 degrees
                    const angle = Math.atan2(vy, vx) * 180 / Math.PI + 90;
            
                    // Rotate the emoji to face the direction of motion
                    emoji.style.transform = `rotate(${angle}deg)`;
                }
            
                // Update emoji position
                emoji.style.left = (emojiX + vx) + 'px';
                emoji.style.top = (emojiY + vy) + 'px';

                // console.log(`Target for emoji at x: ${emoji.style.left}, y: ${emoji.style.top} is x: ${target.style.left}, y: ${target.style.top}`);

            }

            function updateBlackHoleMode() {
                let emojis = document.querySelectorAll('.emoji');
                // Check if the emoji collection is empty
                if (!emojis.length || !blackHoleActive) {
                    blackHoleActive = false;
                    blackHole.style.display = 'none';
            
                    const stopSignBlackHole = document.getElementById('stopSignBlackHole');
                    if (stopSignBlackHole) {
                        stopSignBlackHole.style.display = 'none';
                    }
            
                    return; // Exit the function early
                } else {
                    blackHole.style.display = 'block';
                }
            
                const blackHoleRadius = 25;
                const blackHoleRadiusSquared = blackHoleRadius * blackHoleRadius; // Pre-calculate the squared radius
                const blackHoleCenterX = parseFloat(blackHole.style.left) + blackHoleRadius;
                const blackHoleCenterY = parseFloat(blackHole.style.top) + blackHoleRadius;
            
                let processedCount = 0;
                const maxUpdateTime = 33; // milliseconds
                const startTime = performance.now();
                
                // Convert NodeList to Array
                let emojiArray = Array.from(emojis);
            
                while (processedCount < emojiArray.length) {
                    if (performance.now() - startTime > maxUpdateTime) {
                        // console.log(processedCount, emojiArray.length);
                        break; // Exit the function early if maximum update time is exceeded
                    }
                
                    // Pick a random emoji from the array
                    const randomIndex = Math.floor(Math.random() * emojiArray.length);
                    const emoji = emojiArray[randomIndex];
                
                    const emojiCenterX = emoji.offsetLeft + emoji.offsetWidth / 2;
                    const emojiCenterY = emoji.offsetTop + emoji.offsetHeight / 2;
                
                    let dx = blackHoleCenterX - emojiCenterX;
                    let dy = blackHoleCenterY - emojiCenterY;
                    let distanceSquared = dx * dx + dy * dy; // Use squared distance

                    if (distanceSquared < blackHoleRadiusSquared) {
                        emoji.remove();
                        emojiArray.splice(randomIndex, 1); // Remove the emoji from the array
                    } else if (distanceSquared > 0) {
                        // Update velocity
                        let strength = gravityStrength / distanceSquared;
                        const distance = Math.sqrt(distanceSquared); // Use actual distance
                        emoji.velocity.x += strength * dx / distance; 
                        emoji.velocity.y += strength * dy / distance;
                    } else {
                        emoji.velocity = { x: 0, y: 0 };
                    }
                
                    emoji.style.left = (emoji.offsetLeft + emoji.velocity.x) + 'px';
                    emoji.style.top = (emoji.offsetTop + emoji.velocity.y) + 'px';

                    processedCount++;
                }
            
                if (blackHoleActive) {
                    requestAnimationFrame(updateBlackHoleMode);
                }
            }

            function updateSpellMode() {
                const emojis = document.querySelectorAll('.emoji');
                let allReached = true;
            
                emojis.forEach(emoji => {
                    const target = emojiTargets.get(emoji);
                    if (target) {
                        moveEmojiTowardsTarget(emoji, target);
                        if (!hasReachedTarget(emoji)) {
                            allReached = false;
                        }
                    }
                });
            
                if (allReached) {
                    exitLetterMode();
                } else {
                    requestAnimationFrame(updateSpellMode);
                }
            }

            function hasReachedTarget(emoji) {
                const target = emojiTargets.get(emoji);
                if (!target) {
                    return false; // No target assigned
                }
            
                const threshold = 5; // Pixels, adjust based on how close they need to get
            
                // Get current position of emoji
                const emojiX = parseFloat(emoji.style.left);
                const emojiY = parseFloat(emoji.style.top);
            
                // Get target position
                const targetX = parseFloat(target.style.left);
                const targetY = parseFloat(target.style.top);
            
                // Calculate distance to target
                const dx = targetX - emojiX;
                const dy = targetY - emojiY;
                const distance = Math.sqrt(dx * dx + dy * dy);
            
                // return distance <= threshold;
                const reached =  distance <= threshold;
                // console.log(`Emoji has reached target: ${reached}`);
                return reached;                
            }

            function exitLetterMode() {           
                // Select and remove all invisible emojis
                const invisibleEmojis = document.querySelectorAll('.invisible-emoji'); 
                invisibleEmojis.forEach(emoji => emoji.remove());
            
                // Clear targets from visible emojis
                const visibleEmojis = document.querySelectorAll('.emoji');
                visibleEmojis.forEach(emoji => emojiTargets.delete(emoji));
            }

            let emojiTargets = new Map();
            // Map each emoji to its target

            function toggleChaseMode() {
                isChaseMode = !isChaseMode;
                if (isChaseMode) {
                    assignEmojiTargets();
                    updateChaseMode();
                } else {
                    emojiTargets.clear();
                }
            }

            function assignEmojiTargets() {
                const emojis = document.querySelectorAll('.emoji');
                emojis.forEach(emoji => {
                    assignNewTarget(emoji);
                });
            }

            function assignNewTarget(emoji) {
                const emojis = Array.from(document.querySelectorAll('.emoji'));
                const currentEmojiChar = emoji.textContent;
                const differentCharEmojis = emojis.filter(e => e.textContent !== currentEmojiChar && !e.isRemoved);

                let newTarget;

                if (differentCharEmojis.length > 0) {
                    // Choose a random target from emojis with a different character
                    newTarget = differentCharEmojis[Math.floor(Math.random() * differentCharEmojis.length)];
                } else {
                    // If no different character emojis are available, choose any other random emoji
                    const otherEmojis = emojis.filter(e => e !== emoji && !e.isRemoved);
                    if (otherEmojis.length > 0) {
                        newTarget = otherEmojis[Math.floor(Math.random() * otherEmojis.length)];
                    }
                }

                if (newTarget) {
                    emojiTargets.set(emoji, newTarget);
                } else {
                    // No valid targets available
                    emojiTargets.delete(emoji);
                }
            }

            function createInvisibleEmoji(x, y, emojiSize) {
                const invisibleEmoji = document.createElement('div');
                invisibleEmoji.style.left = `${x}px`;
                invisibleEmoji.style.top = `${y}px`;
                invisibleEmoji.style.position = 'absolute';
                invisibleEmoji.style.visibility = 'hidden';
                invisibleEmoji.style.width = `${emojiSize}px`;
                invisibleEmoji.style.height = `${emojiSize}px`;
                invisibleEmoji.classList.add('invisible-emoji');
                document.body.appendChild(invisibleEmoji);

                return invisibleEmoji;
            }

           function spellWords(words) {
                const letters = words.toUpperCase(); // Convert to uppercase, but keep spaces
                let offset = 150; // Start a bit to the right of the buttons, adjust as needed
                let allInvisibleEmojis = [];
            
                letters.split('').forEach(letter => {
                    if (letter === ' ') {
                        offset += emojiSize * 2;
                    } else {
                        const letterInvisibleEmojis = formLetter(letter, offset);
                        allInvisibleEmojis = allInvisibleEmojis.concat(letterInvisibleEmojis);
                        offset += getLetterWidth(letter) + emojiSize; // Add space after each letter
                    }
                });
            
                // After creating all invisible emojis, assign them as targets
                assignTargetsToVisibleEmojis(allInvisibleEmojis);
            }
              
           function formLetter(letter, xOffset = 0) {
                const art = asciiArtLetters[letter];
                if (!art) return [];
            
                let yOffset = window.innerHeight / 2 - (art.length * emojiSize) / 2; // Center vertically
                const invisibleEmojis = [];
            
                // Create invisible emojis for each character in the ASCII art
                art.forEach((line, y) => {
                    line.split('').forEach((char, x) => {
                        if (char !== ' ') {
                            const xPosition = xOffset + x * emojiSize;
                            const yPosition = yOffset + y * emojiSize;
                            // console.log(`Creating invisible emoji for letter '${letter}' at x: ${xPosition}, y: ${yPosition}`);
                            const invisibleEmoji = createInvisibleEmoji(xPosition, yPosition, emojiSize);
                            invisibleEmojis.push(invisibleEmoji);
                        }
                    });
                });
            
                return invisibleEmojis;
            }
            
            function assignTargetsToVisibleEmojis(invisibleEmojis) {
                const visibleEmojis = document.querySelectorAll('.emoji');
                if (invisibleEmojis.length > 0) {
                    visibleEmojis.forEach(emoji => {
                        const randomIndex = Math.floor(Math.random() * invisibleEmojis.length);
                        emojiTargets.set(emoji, invisibleEmojis[randomIndex]);
                        // console.log(`Emoji at (${emoji.style.left}, ${emoji.style.top}) assigned target at (${invisibleEmojis[randomIndex].style.left}, ${invisibleEmojis[randomIndex].style.top})`);
                    });
                }
            }

            function getLetterWidth(letter) {
                const art = asciiArtLetters[letter];
                if (!art) return 0;
            
                const maxWidthInChars = Math.max(...art.map(line => line.length)); // Max width in characters
                return maxWidthInChars * emojiSize; // Convert to pixels
            }

            function displayFeedback(text, index = 0) {
                const feedbackDisplay = document.getElementById('feedbackDisplay');
            
                if (Array.isArray(text)) {
                    // If text is an array, display each element in sequence
                    if (index < text.length) {
                        feedbackDisplay.innerText = text[index];
                        feedbackDisplay.style.display = 'block';
            
                        setTimeout(() => {
                            feedbackDisplay.style.display = 'none';
                            displayFeedback(text, index + 1); // Display next sentence
                        }, 6000); // Adjust time as needed
                    }
                } else {
                    // If text is a string, display it directly
                    feedbackDisplay.innerText = text;
                    feedbackDisplay.style.display = 'block';
            
                    setTimeout(() => {
                        feedbackDisplay.style.display = 'none';
                    }, 5000); // Adjust time as needed for single string
                }
            }
  
            let isPlaying;
            let audioCtx;
            let analyser;
            let lastDroppedAudio = null; // Store the ArrayBuffer of the last dropped file
            
            // Function to start playing audio
            let isDancing = false;
            let currentSource = null; // To keep track of the current audio source
            
            function playAudio(arrayBuffer) {
                if (!audioCtx) {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    analyser = audioCtx.createAnalyser();
                    BUFFER_SIZE = analyser.frequencyBinCount;
                    audioData = new Uint8Array(BUFFER_SIZE);
                }
                isPlaying = true;
                audioCtx.decodeAudioData(arrayBuffer)
                    .then(audioBuffer => {
                        if (currentSource) {
                            currentSource.disconnect(); // Disconnect the current source if any
                        }
                        currentSource = audioCtx.createBufferSource();
                        currentSource.buffer = audioBuffer;
                        currentSource.connect(analyser);
                        currentSource.connect(audioCtx.destination);
                        currentSource.start();
                        currentSource.onended = () => {
                            isPlaying = false;
                            isDancing = false; // Update dance state when music ends
                        };
                    });
                requestAnimationFrame(animateEmojis);
            }
            
            function stopMusic() {
                if (currentSource) {
                    currentSource.stop();
                    isPlaying = false;
                }
            }

            function dance() {
                if (!isDancing) {
                    if (listening) {
                        // Microphone is on, switch to dancing to microphone input
                        danceToMicrophone();
                    } else {
                        // Microphone is off, play dropped audio or default audio
                        if (lastDroppedAudio) {
                            playAudio(lastDroppedAudio);
                        } else {
                            fetch('https://toontalk.github.io/AI/apps/pix4kids/ellis sisi song.mp3')
                                .then(response => response.arrayBuffer())
                                .then(arrayBuffer => playAudio(arrayBuffer));
                        }
                        isDancing = true;
                    }
                } else {
                    // Stop dancing
                    stopMusic();
                    isDancing = false;
                    if (listening) {
                        // If microphone was used for dancing, restart speech recognition
                        restartSpeechRecognition();
                    }
                }
            }

            function getMicrophoneInput() {
                navigator.mediaDevices.getUserMedia({ audio: true, video: false })
                    .then(stream => {
                        if (!audioCtx) {
                            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                            analyser = audioCtx.createAnalyser();
                            BUFFER_SIZE = analyser.frequencyBinCount;
                            audioData = new Uint8Array(BUFFER_SIZE); 
                        }
            
                        const microphone = audioCtx.createMediaStreamSource(stream);
                        microphone.connect(analyser);
            
                        isPlaying = true; // Set isPlaying to true for microphone input
                        requestAnimationFrame(animateEmojis);
                    })
                    .catch(err => {
                        console.error('Error accessing the microphone', err);
                    });
            }

            function danceToMicrophone() {
                if (!isDancing) {
                    if (listening) {
                        recognition.stop();
                        listening = false;
                    }
                    getMicrophoneInput();
                    isDancing = true;
                } else {
                    // Stop dancing to microphone
                    isPlaying = false; // Set isPlaying to false when stopping microphone input
                    isDancing = false;
                    restartSpeechRecognition();
                }
            }
            
            function restartSpeechRecognition() {
                if (!listening) {
                    recognition.start();
                    listening = true;
                }
            }

            let isModelLoaded = false;
            
            function toggleMicrophone() {
                if (!listening) {
                    if (!isModelLoaded) {
                        isModelLoaded = true;
                        loadUSEModel(); 
                    }
                    if (isDancing) {
                        // Stop dancing if it's active
                        danceToMicrophone(); // This will toggle off the dancing
                    }
                    restartSpeechRecognition();
                } else {
                    recognition.stop();
                    listening = false;
                }
            }
            
            // Prevent default dragover behavior
            document.addEventListener('dragover', function(event) {
                event.preventDefault();
                event.stopPropagation();
            });
            
            // Add event listener for file drop
            document.addEventListener('drop', function(event) {
                event.preventDefault();
                event.stopPropagation();
            
                if (event.dataTransfer.files.length > 0) {
                    let file = event.dataTransfer.files[0];
                    if (file.type === "audio/mpeg" || file.type === "audio/mp3") {
                        let reader = new FileReader();
                        reader.onload = function(e) {
                            lastDroppedAudio = e.target.result; // Store the ArrayBuffer of the dropped file
                        };
                        reader.readAsArrayBuffer(file);
                    }
                }
            });

            let beatThreshold = 0; // Starting value, will be updated dynamically
            const EMOJI_MOVEMENT_AMOUNT = 1; // Pixels to move up or down
            const ROTATION_AMOUNT = 10; // Degrees to rotate

            const MAX_VALUES_LIST_SIZE = 50; // Size of the list to store max values
            let maxValuesList = [];

            function calculateMedian(values) {
                const sortedValues = values.slice().sort((a, b) => a - b);
                const middleIndex = Math.floor(sortedValues.length / 2);
            
                if (sortedValues.length % 2 === 0) {
                    return (sortedValues[middleIndex - 1] + sortedValues[middleIndex]) / 2;
                } else {
                    return sortedValues[middleIndex];
                }
            }

            let previousEnergy = 0;
            let energyThreshold = 0;
            let BUFFER_SIZE;
            let audioData;

            function calculateEnergy(data) {
                let sum = 0;
                for (let i = 0; i < data.length; i++) {
                    sum += data[i] * data[i]; // Energy is the square of amplitude
                }
                return sum / data.length;
            }
            
            function updateThreshold(currentEnergy) {
                if (maxValuesList.length >= MAX_VALUES_LIST_SIZE) {
                    maxValuesList.shift(); // Remove the oldest value
                }
                maxValuesList.push(currentEnergy); // Add the new energy value
            
                // Update the energy threshold to be the median of maxValuesList
                energyThreshold = calculateMedian(maxValuesList);
                
            }
            
            function detectBeat() {
                analyser.getByteFrequencyData(audioData);
                let currentEnergy = calculateEnergy(audioData);
                updateThreshold(currentEnergy);
                let beatDetected = currentEnergy > energyThreshold; 

                return beatDetected;
            }

            function animateEmojis() {
                if (!isPlaying) {
                    return; // Stop animation if music is not playing
                }
            
                let beatDetected = detectBeat();
                
                // Animate emojis based on beat detection
 
                // Select all emojis
                let emojis = document.querySelectorAll('.emoji');
                    
                emojis.forEach(emoji => {
                    let currentTop = parseInt(emoji.style.top, 10) || 0; // Get current top position, default to 0 if not set
                
                    if (beatDetected) {
                        // Move emoji up
                        emoji.style.top = (currentTop - EMOJI_MOVEMENT_AMOUNT) + 'px';
                        // Rotate right on the beat
                        emoji.style.transform = `rotate(${ROTATION_AMOUNT}deg)`;
                    } else {
                        // Move emoji down
                        emoji.style.top = (currentTop + EMOJI_MOVEMENT_AMOUNT) + 'px';
                        // Rotate right on the beat
                        emoji.style.transform = `rotate(${-ROTATION_AMOUNT}deg)`;
                    }
                });
                
                requestAnimationFrame(animateEmojis);
            }

            function showHelp(event) {
                event.stopPropagation(); // Prevent click from propagating to parent elements
            
                const commandsInfo = "Here are some things you can say or do: " +
                    "'Black hole' to create a black hole, which attracts emojis. " +
                    "'Dance' to make emojis move and dance to the beat of the music. You can also drop an MP3 file onto the app to use your own music for dancing. " +
                    "'Chase' to start a chase mode where each emoji follows and tries to catch another one. " +
                    "'Bigger' or 'smaller' to change the size of the emojis. " +
                    "'Random' to change emojis to random ones. " +
                    "'Faster' or 'Slower' to adjust the speed of emoji movement and gravity's pull. " +
                    "'Spell' followed by any word to have emojis form the letters of that word. " +
                    "You can also say anything and you'll get a matching emoji.";
            
                speak(commandsInfo);
            }
            
            // Attach event listeners
            document.getElementById('helpButton').addEventListener('click', () => {
                showHelp(event);
            });

            function toggleStopSign(containerId) {
                var container = document.getElementById(containerId);
                var stopSign = container.querySelector('.stopSign'); // Find the stop sign within the container
                if (stopSign.style.display === 'none') {
                    stopSign.style.display = 'flex'; // Show the stop sign
                } else {
                    stopSign.style.display = 'none'; // Hide the stop sign
                }
            }

            let isRandomActive = true; // The app starts with the random feature active

            function toggleRandom() {
                isRandomActive = !isRandomActive;
                toggleStopSign('randomContainer'); // Toggles the visibility of the stop sign
            
                if (!isRandomActive) {
                    // Set currentEmoji to a random emoji when turning off random mode
                    currentEmoji = Object.values(emojiDict)[Math.floor(Math.random() * Object.values(emojiDict).length)];
                } else {
                    currentEmoji = ""; // Reset to default behavior
                }
            }
            
            // Add event listener to the Random button
            document.getElementById('randomButton').addEventListener('click', () => {
                event.stopPropagation();
                toggleRandom();
            });
            
            document.getElementById('microphoneButton').addEventListener('click', () => {
                event.stopPropagation();
                toggleMicrophone();
                toggleStopSign('microphoneContainer');
            });
            
            document.getElementById('blackHoleButton').addEventListener('click', () => {
                event.stopPropagation();
                blackHoleActive = !blackHoleActive;
                updateBlackHoleMode();
                toggleStopSign('blackHoleContainer');
            });
            
            document.getElementById('chaseButton').addEventListener('click', () => {
                event.stopPropagation();
                toggleChaseMode();
                toggleStopSign('chaseContainer');
            });
            
            document.getElementById('dancingButton').addEventListener('click', () => {
                event.stopPropagation();
                dance();
                toggleStopSign('dancingContainer');
            });

            const buttonChangeFactor = 1.2; // 20% increase

            document.getElementById('smallerButton').addEventListener('click', () => {
                event.stopPropagation();
                emojiSize /= buttonChangeFactor;
            });
            
            document.getElementById('biggerButton').addEventListener('click', () => {
                event.stopPropagation();
                emojiSize *= buttonChangeFactor;
            });
            
            document.getElementById('fasterButton').addEventListener('click', () => {
                event.stopPropagation();
                emojiSpeed *= buttonChangeFactor; 
                gravityStrength *= buttonChangeFactor;
            });
            
            document.getElementById('slowerButton').addEventListener('click', () => {
                event.stopPropagation();
                emojiSpeed /= buttonChangeFactor; 
                gravityStrength /= buttonChangeFactor; 
            });
                        
            document.addEventListener('mousemove', function(e) {
                if (mouseDown && !blackHoleActive) {
                    // Check if the black hole is not active
                    createEmojiElement(e.clientX, e.clientY);
                }
            });

            document.addEventListener('mousedown', function() {
                mouseDown = true;
            });

            document.addEventListener('mouseup', function() {
                mouseDown = false;
            });

            document.addEventListener('touchmove', function(e) {
                e.preventDefault();
                if (!blackHoleActive) {
                    // Check if the black hole is not active
                    let touch = e.touches[0];
                    createEmojiElement(touch.clientX, touch.clientY);
                }
            });

            document.addEventListener('touchstart', function() {
                mouseDown = true;
            });

            document.addEventListener('touchend', function() {
                mouseDown = false;
            });

        </script>
    </body>
</html>
