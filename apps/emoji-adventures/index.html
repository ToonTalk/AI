<!DOCTYPE html>
<html>
    <head>
        <title>Emoji Adventures: Play and Interact with Emojis</title>
        <link rel="icon" type="image/png" href="favicon-48x48.png">
        <style>

            .emoji {
                position: fixed;
                pointer-events: none;
                /* Ignore mouse events on emojis */
                transition: font-size 0.5s;
                /* Smooth transition for size change */
            }

            #emojiContainer {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                z-index: 1; /* Lower than buttons */
            }
            
            #buttonContainer {
                position: fixed;
                left: 20px;
                display: flex;
                flex-direction: column;
                align-items: flex-start;
                z-index: 20; /* Ensure it's higher than the emoji container */
            }
            
            #microphoneContainer, #blackHoleContainer, #dancingContainer, #chaseContainer, #randomContainer, #helpButton {
                font-size: 6vh; /* Adjust the size based on viewport height */
                position: relative; /* This is crucial for correct positioning of the stop sign */
                z-index: 10; /* Ensures buttons are above emojis */
            }
            
            .stopSign {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                display: block; /* Changed from flex to block */
                pointer-events: none; /* The stop sign won't block click events */
                z-index: 10; /* Ensures buttons are above emojis */
            }
            
            .stopSign svg {
                width: 100%;
                height: auto; /* Adjust height to maintain aspect ratio */
            }

            #microphoneButton, #helpButton, #blackHoleButton, #chaseButton, #dancingButton, #smallerButton, #biggerButton, #fasterButton, #slowerButton, #randomButton {
                font-size: 6vh; 
                cursor: pointer;
                position: relative;
                z-index: 10; /* Ensures buttons are above emojis */
            }

        </style>
    </head>
    <body>
        <div id="feedbackDisplay" style="font-size: 4vh; text-align: center; display: none;"></div>
        <div id="buttonContainer">
            <div id="microphoneContainer">
                <div id="microphoneButton">üé§</div>
                <div class="stopSign" style="display: none;">
                    <svg viewBox="0 0 50 50">
                        <circle cx="25" cy="25" r="23" stroke="red" stroke-width="4" fill="none" />
                        <line x1="10" y1="10" x2="40" y2="40" stroke="red" stroke-width="4" />
                    </svg>
                </div>
            </div>

            <div id="blackHoleContainer">
                <div id="blackHoleButton">üåÄ</div>
                <div id="stopSignBlackHole" class="stopSign" style="display: none;">
                    <svg width="50" height="50" viewBox="0 0 50 50">
                        <circle cx="25" cy="25" r="23" stroke="red" stroke-width="4" fill="none" />
                        <line x1="10" y1="10" x2="40" y2="40" stroke="red" stroke-width="4" />
                    </svg> 
                </div>
            </div>
            <div id="dancingContainer">
                <div id="dancingButton">üíÉ</div> <!-- or use üï∫ for Man Dancing -->
                <div class="stopSign" style="display: none;"> 
                    <svg width="50" height="50" viewBox="0 0 50 50">
                        <circle cx="25" cy="25" r="23" stroke="red" stroke-width="4" fill="none" />
                        <line x1="10" y1="10" x2="40" y2="40" stroke="red" stroke-width="4" />
                    </svg>
                </div>
            </div>
            <div id="chaseContainer">
                <div id="chaseButton">üèÉ</div>
                <div class="stopSign" style="display: none;">
                    <svg width="50" height="50" viewBox="0 0 50 50">
                        <circle cx="25" cy="25" r="23" stroke="red" stroke-width="4" fill="none" />
                        <line x1="10" y1="10" x2="40" y2="40" stroke="red" stroke-width="4" />
                    </svg> 
                </div>
            </div>
            <div id="slowerButton">üê¢</div>
            <div id="fasterButton">üêé</div>
            <div id="smallerButton">üêú</div>
            <div id="biggerButton">üêò</div>
            <div id="randomContainer">
                <div id="randomButton">üé≤</div>
                <div class="stopSign" style="display: flex;"> <!-- Initially visible -->
                    <svg width="50" height="50" viewBox="0 0 50 50">
                        <circle cx="25" cy="25" r="23" stroke="red" stroke-width="4" fill="none" />
                        <line x1="10" y1="10" x2="40" y2="40" stroke="red" stroke-width="4" />
                    </svg>
                </div>
            </div>
            <div id="helpButton">‚ùì</div> 
        </div>
        <div id="emojiContainer"></div>
        <script>
            let useModel;

            let emojiDescriptions = [];
            // Array to store emoji descriptions
            let emojiDescriptionsEmbeddings;
            // Variable to store precomputed embeddings

            async function loadUSEModel() {
                // Function to dynamically load a script
                function loadScript(url) {
                    return new Promise((resolve, reject) => {
                        const script = document.createElement('script');
                        script.src = url;
                        script.onload = resolve;
                        script.onerror = reject;
                        document.head.appendChild(script);
                    });
                }
            
                try {
                    // Load TensorFlow.js
                    await loadScript('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs');
                    // Load Universal Sentence Encoder
                    await loadScript('https://cdn.jsdelivr.net/npm/@tensorflow-models/universal-sentence-encoder');
            
                    // TensorFlow.js and USE are now loaded and can be used
                    useModel = await use.load();
            
                    // Populate emojiDescriptions array from emojiDict
                    emojiDescriptions = Object.keys(emojiDict);
            
                    // Compute and store embeddings for all emoji descriptions
                    emojiDescriptionsEmbeddings = await useModel.embed(emojiDescriptions);
                    onUSEModelLoaded();
                } catch (error) {
                    console.error('Error loading scripts:', error);
                }
            }

            // Check if the speechSynthesis API is available
            if ('speechSynthesis' in window) {
                // Attempt to load the list of speech synthesis voices available
                voices = window.speechSynthesis.getVoices();
            
                // Set up an event listener for when the list of voices changes (e.g., when voices are loaded)
                window.speechSynthesis.onvoiceschanged = function() {
                    // Update the voices list when new voices become available
                    voices = window.speechSynthesis.getVoices();
                };
            }

            function speak(text) {
                if ('speechSynthesis' in window && voices.length > 0) {
                    const msg = new SpeechSynthesisUtterance(text);
                    msg.voice = voices.find(voice => voice.lang === 'en-US') || voices[0];
                    window.speechSynthesis.speak(msg);
                } else {
                    // Split text into sentences for display if speech synthesis is not supported or no voices are available
                    const sentences = text.split('. ');
                    displayFeedback(sentences);
                }
            }

            function onUSEModelLoaded() {
                const message = "I can now understand almost anything you say."
                speak(message);
                displayFeedback(message);
            }

            async function findClosestEmojiDescription(userInput) {
                const userInputEmbedding = await useModel.embed([userInput]);
            
                // Compute cosine proximity between user input and all emoji descriptions
                const cosineProximities = tf.metrics.cosineProximity(userInputEmbedding, emojiDescriptionsEmbeddings);
            
                // Temporary variable for the argMin tensor
                const closestEmojiTensor = cosineProximities.argMin();
                const closestEmojiIndex = (await closestEmojiTensor.data())[0];
            
                // Dispose tensors to free memory
                userInputEmbedding.dispose();
                cosineProximities.dispose();
                closestEmojiTensor.dispose(); // Dispose the argMin tensor
            
                return emojiDescriptions[closestEmojiIndex];
            }

            let emojiSpeed = 2; // Default speed for emoji movement
            let gravityStrength = 1000; // Default strength for gravity
            let emojiSize = 50;
            let currentEmoji = "";
            let mouseDown = false;
            let listening = false;
            const recognition = new webkitSpeechRecognition();
            recognition.continuous = true;
            recognition.lang = 'en-US';
            recognition.interimResults = true;
            recognition.maxAlternatives = 1;

            function createEmojiElement(x, y, emoji) {
                let emojiElement = document.createElement('div');
                emojiElement.classList.add('emoji');
                emojiElement.textContent = emoji || currentEmoji || Object.values(emojiDict)[Math.floor(Math.random() * Object.values(emojiDict).length)];
                emojiElement.style.left = x + 'px';
                emojiElement.style.top = y + 'px';
                emojiElement.style.fontSize = emojiSize + 'px';
                emojiElement.velocity = {
                    x: 0,
                    y: 0
                };
                const emojiContainer = document.getElementById('emojiContainer');
                emojiContainer.appendChild(emojiElement);
                return emojiElement;
            }

            function showFeedbackEmoji(emoji) {
                let feedbackEmoji = document.createElement('div');
                feedbackEmoji.textContent = emoji;
                feedbackEmoji.style.position = 'fixed';
                feedbackEmoji.style.left = '50%';
                feedbackEmoji.style.top = '50%';
                feedbackEmoji.style.transform = 'translate(-50%, -50%)';
                feedbackEmoji.style.fontSize = '100px';
                feedbackEmoji.style.zIndex = '1000';
                document.body.appendChild(feedbackEmoji);
                setTimeout(() => feedbackEmoji.remove(), 2000);
                // Remove after 2 seconds
            }

            recognition.onresult = function(event) {
                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) {
                        const command = event.results[i][0].transcript.trim().toLowerCase();

                        // Skip processing if the command is an empty string
                        if (!command) {
                            continue;
                            // Skip to the next loop iteration
                        }

                        console.log("Spoken:", command);
                        displayFeedback(command); 

                        if (command.startsWith('spell ')) {
                            const wordsToSpell = command.substring(6); // Extract the words after "spell "
                            spellWords(wordsToSpell);
                            updateSpellMode();
                        } else if (command.includes('dance')) {
                            dance();
                            toggleStopSign('dancingContainer');
                        } else if (command.includes('black hole')) {
                            blackHoleActive = !blackHoleActive;
                            updateBlackHoleMode();
                            toggleStopSign('blackHoleContainer');
                        } else if (command.includes('chase')) {
                            toggleChaseMode();
                            toggleStopSign('chaseContainer');
                        } else if (command.includes('random')) {
                            toggleRandom();
                        } else if (command.includes('bigger')) {
                            emojiSize *= 1.5;
                        } else if (command.includes('smaller')) {
                            emojiSize *= 2/3;
                        } else if (command.includes('faster')) {
                            emojiSpeed *= 1.5; // Increase speed by 50%
                            gravityStrength *= 1.5; // Increase gravity strength by 50%
                        } else if (command.includes('slower')) {
                            emojiSpeed *= 2/3; // Decrease speed by 33%
                            gravityStrength *= 2/3; // Decrease gravity strength by 33%
                        } else if (emojiDict[command]) {
                            currentEmoji = emojiDict[command];
                            showFeedbackEmoji(currentEmoji);
                        } else if (useModel) {
                            // If USE model is loaded and no exact match is found
                            findClosestEmojiDescription(command).then(closestEmojiDescription => {
                                if (closestEmojiDescription && emojiDict[closestEmojiDescription]) {
                                    currentEmoji = emojiDict[closestEmojiDescription];
                                    showFeedbackEmoji(currentEmoji);
                                    console.log("->", closestEmojiDescription);
                                }
                            });
                        }
                    }
                }

            };

            recognition.onend = function() {
                console.log("Speech recognition service disconnected");
                if (listening) {
                    // Assuming 'listening' is a flag indicating whether recognition should be active
                    recognition.start();
                }
            };

            recognition.onerror = function(event) {
                console.error("Speech recognition error", event.error);
                // Optionally restart recognition or handle differently based on the error
            };

            document.addEventListener('click', function(e) {
                createEmojiElement(e.clientX, e.clientY);
            });

            document.addEventListener('touchstart', function(e) {
                if (!e.touches.length)
                    return;
                let touch = e.touches[0];
                createEmojiElement(touch.clientX, touch.clientY);
            });

            function createBlackHole() {
                let blackHole = document.createElement('div');
                blackHole.id = 'blackHole';
                blackHole.style.width = '50px';
                blackHole.style.height = '50px';
                blackHole.style.borderRadius = '50%';
                blackHole.style.backgroundColor = 'black';
                blackHole.style.position = 'fixed';
                blackHole.style.display = 'none';
                // Initially hidden
                document.body.appendChild(blackHole);
                return blackHole;
            }

            let blackHole = createBlackHole();
            let blackHoleActive = false;

            // Function to move the black hole
            function moveBlackHole(x, y) {
                blackHole.style.left = x + 'px';
                blackHole.style.top = y + 'px';
                blackHole.style.display = 'block';
            }

            // Event listeners for mouse and touch movement
            document.addEventListener('mousemove', function(e) {
                if (blackHoleActive) {
                    moveBlackHole(e.clientX, e.clientY);
                }
            });

            document.addEventListener('touchmove', function(e) {
                if (blackHoleActive && e.touches.length) {
                    let touch = e.touches[0];
                    moveBlackHole(touch.clientX, touch.clientY);
                }
            });

            let isChaseMode = false;

            function updateChaseMode() {
                let emojis = document.querySelectorAll('.emoji');
                let chasers = new Map();
                
                // Determine chasers for each emoji
                emojis.forEach(emoji => {
                    chasers.set(emoji, []);
                });

                // Determine chasers for each emoji
                emojis.forEach(emoji => {
                    const target = emojiTargets.get(emoji);
                    if (target && !target.isRemoved) {
                        const targetChasers = chasers.get(target);
                        if (targetChasers) {
                            targetChasers.push(emoji);
                        }
                    }
                });
                
               let processedCount = 0;
               const maxUpdateTime = 16; // milliseconds
               const startTime = performance.now();
                
               while (processedCount < emojis.length) {
                   if (performance.now() - startTime > maxUpdateTime) {
                      break; // Exit the loop if maximum update time is exceeded
                    }
                
                    // Pick a random emoji
                    const randomIndex = Math.floor(Math.random() * emojis.length);
                    const emoji = emojis[randomIndex];
                
                    let target = emojiTargets.get(emoji);

                    // Check if the target is still valid
                    if (!target || target.isRemoved) {
                        assignNewTarget(emoji);
                        // Assign a new target
                        target = emojiTargets.get(emoji);
                        // Update the target reference
                    }
    
                    if (target && !target.isRemoved) {
                        // Calculate distance to the target
                        const dx = target.offsetLeft - emoji.offsetLeft;
                        const dy = target.offsetTop - emoji.offsetTop;
                        const distance = Math.sqrt(dx * dx + dy * dy);
    
                        // Remove target and assign a new one if distance is small enough
                        if (distance < 10) {
                            // Threshold for reaching the target
                            target.remove();
                            target.isRemoved = true;
                            assignNewTarget(emoji);
                            // Assign a new target
                        } else {
                            // Calculate attraction towards the target
                            let dx = target.offsetLeft - emoji.offsetLeft;
                            let dy = target.offsetTop - emoji.offsetTop;
                            let distance = Math.sqrt(dx * dx + dy * dy);
                            let attraction = {
                                x: dx / distance,
                                y: dy / distance
                            };
    
                            // Calculate repulsion from chasers
                            let repulsion = {
                                x: 0,
                                y: 0
                            };
                            chasers.get(emoji).forEach(chaser => {
                                let rdx = emoji.offsetLeft - chaser.offsetLeft;
                                let rdy = emoji.offsetTop - chaser.offsetTop;
                                let rDistance = Math.sqrt(rdx * rdx + rdy * rdy);
                                rDistance = Math.max(rDistance, 1);
                                // Avoid division by zero
                                repulsion.x += rdx / rDistance;
                                repulsion.y += rdy / rDistance;
                            });
    
                            // Combine attraction and repulsion
                            const speed = emojiSpeed; // Use the global emojiSpeed variable
                            let vx = (attraction.x + repulsion.x) * speed;
                            let vy = (attraction.y + repulsion.y) * speed;
    
                            const windowWidth = window.innerWidth;
                            const windowHeight = window.innerHeight;
    
                            // Calculate new position with boundaries
                            let newX = emoji.offsetLeft + vx;
                            let newY = emoji.offsetTop + vy;
    
                            // Only rotate the emoji if it is moving
                            if (vx !== 0 || vy !== 0) {
                                // Calculate the angle of motion
                                const angle = Math.atan2(vy, vx) * 180 / Math.PI + 90;
                                
                                // Rotate the emoji to face the direction of motion
                                emoji.style.transform = `rotate(${angle}deg)`;
                            }
    
                            // Boundary checks and adjustments
                            if (newX < 0) {
                                newX = 0;
                                vx = -vx;
                                // Reverse horizontal velocity
                            } else if (newX + emoji.offsetWidth > windowWidth) {
                                newX = windowWidth - emoji.offsetWidth;
                                vx = -vx;
                                // Reverse horizontal velocity
                            }
    
                            if (newY < 0) {
                                newY = 0;
                                vy = -vy;
                                // Reverse vertical velocity
                            } else if (newY + emoji.offsetHeight > windowHeight) {
                                newY = windowHeight - emoji.offsetHeight;
                                vy = -vy;
                                // Reverse vertical velocity
                            }
    
                            // Update position with boundaries
                            emoji.style.left = newX + 'px';
                            emoji.style.top = newY + 'px';
                        }
                
                        processedCount++;
                    }
               }

               if (isChaseMode) {
                   requestAnimationFrame(updateChaseMode);
               }
            }

            function moveEmojiTowardsTarget(emoji, target) {
                const speed = emojiSpeed;
            
                // Current position of the emoji
                const emojiX = parseFloat(emoji.style.left);
                const emojiY = parseFloat(emoji.style.top);
            
                // Target position
                const targetX = parseFloat(target.style.left);
                const targetY = parseFloat(target.style.top);
            
                // Calculate distance to target
                const dx = targetX - emojiX;
                const dy = targetY - emojiY;
                const distance = Math.sqrt(dx * dx + dy * dy);
            
                // If the emoji is close enough to the target, stop moving
                if (distance < 1) {
                    return;
                }
            
                // Calculate movement vector
                const vx = (dx / distance) * speed;
                const vy = (dy / distance) * speed;

                // Only rotate the emoji if it is moving
                if (vx !== 0 || vy !== 0) {
                    // Calculate the angle of motion and adjust by 90 degrees
                    const angle = Math.atan2(vy, vx) * 180 / Math.PI + 90;
            
                    // Rotate the emoji to face the direction of motion
                    emoji.style.transform = `rotate(${angle}deg)`;
                }
            
                // Update emoji position
                emoji.style.left = (emojiX + vx) + 'px';
                emoji.style.top = (emojiY + vy) + 'px';

                // console.log(`Target for emoji at x: ${emoji.style.left}, y: ${emoji.style.top} is x: ${target.style.left}, y: ${target.style.top}`);

            }

            function updateBlackHoleMode() {
                let emojis = document.querySelectorAll('.emoji');
                // Check if the emoji collection is empty
                if (!emojis.length || !blackHoleActive) {
                    blackHoleActive = false;
                    blackHole.style.display = 'none';
            
                    const stopSignBlackHole = document.getElementById('stopSignBlackHole');
                    if (stopSignBlackHole) {
                        stopSignBlackHole.style.display = 'none';
                    }
            
                    return; // Exit the function early
                } else {
                    blackHole.style.display = 'block';
                }
            
                const blackHoleRadius = 25;
                const blackHoleRadiusSquared = blackHoleRadius * blackHoleRadius; // Pre-calculate the squared radius
                const blackHoleCenterX = parseFloat(blackHole.style.left) + blackHoleRadius;
                const blackHoleCenterY = parseFloat(blackHole.style.top) + blackHoleRadius;
            
                let processedCount = 0;
                const maxUpdateTime = 33; // milliseconds
                const startTime = performance.now();
                
                // Convert NodeList to Array
                let emojiArray = Array.from(emojis);
            
                while (processedCount < emojiArray.length) {
                    if (performance.now() - startTime > maxUpdateTime) {
                        // console.log(processedCount, emojiArray.length);
                        break; // Exit the function early if maximum update time is exceeded
                    }
                
                    // Pick a random emoji from the array
                    const randomIndex = Math.floor(Math.random() * emojiArray.length);
                    const emoji = emojiArray[randomIndex];
                
                    const emojiCenterX = emoji.offsetLeft + emoji.offsetWidth / 2;
                    const emojiCenterY = emoji.offsetTop + emoji.offsetHeight / 2;
                
                    let dx = blackHoleCenterX - emojiCenterX;
                    let dy = blackHoleCenterY - emojiCenterY;
                    let distanceSquared = dx * dx + dy * dy; // Use squared distance

                    if (distanceSquared < blackHoleRadiusSquared) {
                        emoji.remove();
                        emojiArray.splice(randomIndex, 1); // Remove the emoji from the array
                    } else if (distanceSquared > 0) {
                        // Update velocity
                        let strength = gravityStrength / distanceSquared;
                        const distance = Math.sqrt(distanceSquared); // Use actual distance
                        emoji.velocity.x += strength * dx / distance; 
                        emoji.velocity.y += strength * dy / distance;
                    } else {
                        emoji.velocity = { x: 0, y: 0 };
                    }
                
                    emoji.style.left = (emoji.offsetLeft + emoji.velocity.x) + 'px';
                    emoji.style.top = (emoji.offsetTop + emoji.velocity.y) + 'px';

                    processedCount++;
                }
            
                if (blackHoleActive) {
                    requestAnimationFrame(updateBlackHoleMode);
                }
            }

            function updateSpellMode() {
                const emojis = document.querySelectorAll('.emoji');
                let allReached = true;
            
                emojis.forEach(emoji => {
                    const target = emojiTargets.get(emoji);
                    if (target) {
                        moveEmojiTowardsTarget(emoji, target);
                        if (!hasReachedTarget(emoji)) {
                            allReached = false;
                        }
                    }
                });
            
                if (allReached) {
                    exitLetterMode();
                } else {
                    requestAnimationFrame(updateSpellMode);
                }
            }

            function hasReachedTarget(emoji) {
                const target = emojiTargets.get(emoji);
                if (!target) {
                    return false; // No target assigned
                }
            
                const threshold = 5; // Pixels, adjust based on how close they need to get
            
                // Get current position of emoji
                const emojiX = parseFloat(emoji.style.left);
                const emojiY = parseFloat(emoji.style.top);
            
                // Get target position
                const targetX = parseFloat(target.style.left);
                const targetY = parseFloat(target.style.top);
            
                // Calculate distance to target
                const dx = targetX - emojiX;
                const dy = targetY - emojiY;
                const distance = Math.sqrt(dx * dx + dy * dy);
            
                // return distance <= threshold;
                const reached =  distance <= threshold;
                // console.log(`Emoji has reached target: ${reached}`);
                return reached;                
            }

            function exitLetterMode() {           
                // Select and remove all invisible emojis
                const invisibleEmojis = document.querySelectorAll('.invisible-emoji'); 
                invisibleEmojis.forEach(emoji => emoji.remove());
            
                // Clear targets from visible emojis
                const visibleEmojis = document.querySelectorAll('.emoji');
                visibleEmojis.forEach(emoji => emojiTargets.delete(emoji));
            }

            let emojiTargets = new Map();
            // Map each emoji to its target

            function toggleChaseMode() {
                isChaseMode = !isChaseMode;
                if (isChaseMode) {
                    assignEmojiTargets();
                    updateChaseMode();
                } else {
                    emojiTargets.clear();
                }
            }

            function assignEmojiTargets() {
                const emojis = document.querySelectorAll('.emoji');
                emojis.forEach(emoji => {
                    assignNewTarget(emoji);
                });
            }

            function assignNewTarget(emoji) {
                const emojis = Array.from(document.querySelectorAll('.emoji'));
                const currentEmojiChar = emoji.textContent;
                const differentCharEmojis = emojis.filter(e => e.textContent !== currentEmojiChar && !e.isRemoved);

                let newTarget;

                if (differentCharEmojis.length > 0) {
                    // Choose a random target from emojis with a different character
                    newTarget = differentCharEmojis[Math.floor(Math.random() * differentCharEmojis.length)];
                } else {
                    // If no different character emojis are available, choose any other random emoji
                    const otherEmojis = emojis.filter(e => e !== emoji && !e.isRemoved);
                    if (otherEmojis.length > 0) {
                        newTarget = otherEmojis[Math.floor(Math.random() * otherEmojis.length)];
                    }
                }

                if (newTarget) {
                    emojiTargets.set(emoji, newTarget);
                } else {
                    // No valid targets available
                    emojiTargets.delete(emoji);
                }
            }

            function createInvisibleEmoji(x, y, emojiSize) {
                const invisibleEmoji = document.createElement('div');
                invisibleEmoji.style.left = `${x}px`;
                invisibleEmoji.style.top = `${y}px`;
                invisibleEmoji.style.position = 'absolute';
                invisibleEmoji.style.visibility = 'hidden';
                invisibleEmoji.style.width = `${emojiSize}px`;
                invisibleEmoji.style.height = `${emojiSize}px`;
                invisibleEmoji.classList.add('invisible-emoji');
                document.body.appendChild(invisibleEmoji);

                return invisibleEmoji;
            }

           function spellWords(words) {
                const letters = words.toUpperCase(); // Convert to uppercase, but keep spaces
                let offset = 150; // Start a bit to the right of the buttons, adjust as needed
                let allInvisibleEmojis = [];
            
                letters.split('').forEach(letter => {
                    if (letter === ' ') {
                        offset += emojiSize * 2;
                    } else {
                        const letterInvisibleEmojis = formLetter(letter, offset);
                        allInvisibleEmojis = allInvisibleEmojis.concat(letterInvisibleEmojis);
                        offset += getLetterWidth(letter) + emojiSize; // Add space after each letter
                    }
                });
            
                // After creating all invisible emojis, assign them as targets
                assignTargetsToVisibleEmojis(allInvisibleEmojis);
            }
              
           function formLetter(letter, xOffset = 0) {
                const art = asciiArtLetters[letter];
                if (!art) return [];
            
                let yOffset = window.innerHeight / 2 - (art.length * emojiSize) / 2; // Center vertically
                const invisibleEmojis = [];
            
                // Create invisible emojis for each character in the ASCII art
                art.forEach((line, y) => {
                    line.split('').forEach((char, x) => {
                        if (char !== ' ') {
                            const xPosition = xOffset + x * emojiSize;
                            const yPosition = yOffset + y * emojiSize;
                            // console.log(`Creating invisible emoji for letter '${letter}' at x: ${xPosition}, y: ${yPosition}`);
                            const invisibleEmoji = createInvisibleEmoji(xPosition, yPosition, emojiSize);
                            invisibleEmojis.push(invisibleEmoji);
                        }
                    });
                });
            
                return invisibleEmojis;
            }
            
            function assignTargetsToVisibleEmojis(invisibleEmojis) {
                const visibleEmojis = document.querySelectorAll('.emoji');
                if (invisibleEmojis.length > 0) {
                    visibleEmojis.forEach(emoji => {
                        const randomIndex = Math.floor(Math.random() * invisibleEmojis.length);
                        emojiTargets.set(emoji, invisibleEmojis[randomIndex]);
                        // console.log(`Emoji at (${emoji.style.left}, ${emoji.style.top}) assigned target at (${invisibleEmojis[randomIndex].style.left}, ${invisibleEmojis[randomIndex].style.top})`);
                    });
                }
            }

            function getLetterWidth(letter) {
                const art = asciiArtLetters[letter];
                if (!art) return 0;
            
                const maxWidthInChars = Math.max(...art.map(line => line.length)); // Max width in characters
                return maxWidthInChars * emojiSize; // Convert to pixels
            }

            function displayFeedback(text, index = 0) {
                const feedbackDisplay = document.getElementById('feedbackDisplay');
            
                if (Array.isArray(text)) {
                    // If text is an array, display each element in sequence
                    if (index < text.length) {
                        feedbackDisplay.innerText = text[index];
                        feedbackDisplay.style.display = 'block';
            
                        setTimeout(() => {
                            feedbackDisplay.style.display = 'none';
                            displayFeedback(text, index + 1); // Display next sentence
                        }, 6000); // Adjust time as needed
                    }
                } else {
                    // If text is a string, display it directly
                    feedbackDisplay.innerText = text;
                    feedbackDisplay.style.display = 'block';
            
                    setTimeout(() => {
                        feedbackDisplay.style.display = 'none';
                    }, 5000); // Adjust time as needed for single string
                }
            }
  
            let isPlaying;
            let audioCtx;
            let analyser;
            let lastDroppedAudio = null; // Store the ArrayBuffer of the last dropped file
            
            // Function to start playing audio
            let isDancing = false;
            let currentSource = null; // To keep track of the current audio source
            
            function playAudio(arrayBuffer) {
                if (!audioCtx) {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    analyser = audioCtx.createAnalyser();
                    BUFFER_SIZE = analyser.frequencyBinCount;
                    audioData = new Uint8Array(BUFFER_SIZE);
                }
                isPlaying = true;
                audioCtx.decodeAudioData(arrayBuffer)
                    .then(audioBuffer => {
                        if (currentSource) {
                            currentSource.disconnect(); // Disconnect the current source if any
                        }
                        currentSource = audioCtx.createBufferSource();
                        currentSource.buffer = audioBuffer;
                        currentSource.connect(analyser);
                        currentSource.connect(audioCtx.destination);
                        currentSource.start();
                        currentSource.onended = () => {
                            isPlaying = false;
                            isDancing = false; // Update dance state when music ends
                        };
                    });
                requestAnimationFrame(animateEmojis);
            }
            
            function stopMusic() {
                if (currentSource) {
                    currentSource.stop();
                    isPlaying = false;
                }
            }

            function dance() {
                if (!isDancing) {
                    if (listening) {
                        // Microphone is on, switch to dancing to microphone input
                        danceToMicrophone();
                    } else {
                        // Microphone is off, play dropped audio or default audio
                        if (lastDroppedAudio) {
                            playAudio(lastDroppedAudio);
                        } else {
                            fetch('https://toontalk.github.io/AI/apps/emoji-adventures/ellis sisi song.mp3') 
                                .then(response => response.arrayBuffer())
                                .then(arrayBuffer => playAudio(arrayBuffer));
                        }
                        isDancing = true;
                    }
                } else {
                    // Stop dancing
                    stopMusic();
                    isDancing = false;
                    if (listening) {
                        // If microphone was used for dancing, restart speech recognition
                        restartSpeechRecognition();
                    }
                }
            }

            function getMicrophoneInput() {
                navigator.mediaDevices.getUserMedia({ audio: true, video: false })
                    .then(stream => {
                        if (!audioCtx) {
                            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                            analyser = audioCtx.createAnalyser();
                            BUFFER_SIZE = analyser.frequencyBinCount;
                            audioData = new Uint8Array(BUFFER_SIZE); 
                        }
            
                        const microphone = audioCtx.createMediaStreamSource(stream);
                        microphone.connect(analyser);
            
                        isPlaying = true; // Set isPlaying to true for microphone input
                        requestAnimationFrame(animateEmojis);
                    })
                    .catch(err => {
                        console.error('Error accessing the microphone', err);
                    });
            }

            function danceToMicrophone() {
                if (!isDancing) {
                    if (listening) {
                        recognition.stop();
                        listening = false;
                    }
                    getMicrophoneInput();
                    isDancing = true;
                } else {
                    // Stop dancing to microphone
                    isPlaying = false; // Set isPlaying to false when stopping microphone input
                    isDancing = false;
                    restartSpeechRecognition();
                }
            }
            
            function restartSpeechRecognition() {
                if (!listening) {
                    recognition.start();
                    listening = true;
                }
            }

            let isModelLoaded = false;
            
            function toggleMicrophone() {
                if (!listening) {
                    if (!isModelLoaded) {
                        isModelLoaded = true;
                        loadUSEModel(); 
                    }
                    if (isDancing) {
                        // Stop dancing if it's active
                        danceToMicrophone(); // This will toggle off the dancing
                    }
                    restartSpeechRecognition();
                } else {
                    recognition.stop();
                    listening = false;
                }
            }
            
            // Prevent default dragover behavior
            document.addEventListener('dragover', function(event) {
                event.preventDefault();
                event.stopPropagation();
            });
            
            // Add event listener for file drop
            document.addEventListener('drop', function(event) {
                event.preventDefault();
                event.stopPropagation();
            
                if (event.dataTransfer.files.length > 0) {
                    let file = event.dataTransfer.files[0];
                    if (file.type === "audio/mpeg" || file.type === "audio/mp3") {
                        let reader = new FileReader();
                        reader.onload = function(e) {
                            lastDroppedAudio = e.target.result; // Store the ArrayBuffer of the dropped file
                        };
                        reader.readAsArrayBuffer(file);
                    }
                }
            });

            let beatThreshold = 0; // Starting value, will be updated dynamically
            const EMOJI_MOVEMENT_AMOUNT = 1; // Pixels to move up or down
            const ROTATION_AMOUNT = 10; // Degrees to rotate

            const MAX_VALUES_LIST_SIZE = 50; // Size of the list to store max values
            let maxValuesList = [];

            function calculateMedian(values) {
                const sortedValues = values.slice().sort((a, b) => a - b);
                const middleIndex = Math.floor(sortedValues.length / 2);
            
                if (sortedValues.length % 2 === 0) {
                    return (sortedValues[middleIndex - 1] + sortedValues[middleIndex]) / 2;
                } else {
                    return sortedValues[middleIndex];
                }
            }

            let previousEnergy = 0;
            let energyThreshold = 0;
            let BUFFER_SIZE;
            let audioData;

            function calculateEnergy(data) {
                let sum = 0;
                for (let i = 0; i < data.length; i++) {
                    sum += data[i] * data[i]; // Energy is the square of amplitude
                }
                return sum / data.length;
            }
            
            function updateThreshold(currentEnergy) {
                if (maxValuesList.length >= MAX_VALUES_LIST_SIZE) {
                    maxValuesList.shift(); // Remove the oldest value
                }
                maxValuesList.push(currentEnergy); // Add the new energy value
            
                // Update the energy threshold to be the median of maxValuesList
                energyThreshold = calculateMedian(maxValuesList);
                
            }
            
            function detectBeat() {
                analyser.getByteFrequencyData(audioData);
                let currentEnergy = calculateEnergy(audioData);
                updateThreshold(currentEnergy);
                let beatDetected = currentEnergy > energyThreshold; 

                return beatDetected;
            }

            function animateEmojis() {
                if (!isPlaying) {
                    return; // Stop animation if music is not playing
                }
            
                let beatDetected = detectBeat();
                
                // Animate emojis based on beat detection
 
                // Select all emojis
                let emojis = document.querySelectorAll('.emoji');
                    
                emojis.forEach(emoji => {
                    let currentTop = parseInt(emoji.style.top, 10) || 0; // Get current top position, default to 0 if not set
                
                    if (beatDetected) {
                        // Move emoji up
                        emoji.style.top = (currentTop - EMOJI_MOVEMENT_AMOUNT) + 'px';
                        // Rotate right on the beat
                        emoji.style.transform = `rotate(${ROTATION_AMOUNT}deg)`;
                    } else {
                        // Move emoji down
                        emoji.style.top = (currentTop + EMOJI_MOVEMENT_AMOUNT) + 'px';
                        // Rotate right on the beat
                        emoji.style.transform = `rotate(${-ROTATION_AMOUNT}deg)`;
                    }
                });
                
                requestAnimationFrame(animateEmojis);
            }

            function showHelp(event) {
                event.stopPropagation(); // Prevent click from propagating to parent elements
            
                const commandsInfo = "Here are some things you can say or do: " +
                    "'Black hole' to create a black hole, which attracts emojis. " +
                    "'Dance' to make emojis move and dance to the beat of the music. You can also drop an MP3 file onto the app to use your own music for dancing. " +
                    "'Chase' to start a chase mode where each emoji follows and tries to catch another one. " +
                    "'Bigger' or 'smaller' to change the size of the emojis. " +
                    "'Random' to change emojis to random ones. " +
                    "'Faster' or 'Slower' to adjust the speed of emoji movement and gravity's pull. " +
                    "'Spell' followed by any word to have emojis form the letters of that word. " +
                    "You can also say anything and you'll get a matching emoji.";
            
                speak(commandsInfo);
            }

            function toggleStopSign(containerId) {
                var container = document.getElementById(containerId);
                var stopSign = container.querySelector('.stopSign'); // Find the stop sign within the container
                if (stopSign.style.display === 'none') {
                    stopSign.style.display = 'flex'; // Show the stop sign
                } else {
                    stopSign.style.display = 'none'; // Hide the stop sign
                }
            }

            let isRandomActive = true; // The app starts with the random feature active

            function toggleRandom() {
                isRandomActive = !isRandomActive;
                toggleStopSign('randomContainer'); // Toggles the visibility of the stop sign
            
                if (!isRandomActive) {
                    // Set currentEmoji to a random emoji when turning off random mode
                    currentEmoji = Object.values(emojiDict)[Math.floor(Math.random() * Object.values(emojiDict).length)];
                } else {
                    currentEmoji = ""; // Reset to default behavior
                }
            }

            document.getElementById('helpButton').addEventListener('click', () => {
                event.stopPropagation();
                showHelp(event);
            });
            
            // Add event listener to the Random button
            document.getElementById('randomButton').addEventListener('click', () => {
                event.stopPropagation();
                toggleRandom();
            });
            
            document.getElementById('microphoneButton').addEventListener('click', () => {
                event.stopPropagation();
                toggleMicrophone();
                toggleStopSign('microphoneContainer');
            });
            
            document.getElementById('blackHoleButton').addEventListener('click', () => {
                event.stopPropagation();
                blackHoleActive = !blackHoleActive;
                updateBlackHoleMode();
                toggleStopSign('blackHoleContainer');
            });
            
            document.getElementById('chaseButton').addEventListener('click', () => {
                event.stopPropagation();
                toggleChaseMode();
                toggleStopSign('chaseContainer');
            });
            
            document.getElementById('dancingButton').addEventListener('click', () => {
                event.stopPropagation();
                dance();
                toggleStopSign('dancingContainer');
            });

            const buttonChangeFactor = 1.2; // 20% increase

            document.getElementById('smallerButton').addEventListener('click', () => {
                event.stopPropagation();
                emojiSize /= buttonChangeFactor;
            });
            
            document.getElementById('biggerButton').addEventListener('click', () => {
                event.stopPropagation();
                emojiSize *= buttonChangeFactor;
            });
            
            document.getElementById('fasterButton').addEventListener('click', () => {
                event.stopPropagation();
                emojiSpeed *= buttonChangeFactor; 
                gravityStrength *= buttonChangeFactor;
            });
            
            document.getElementById('slowerButton').addEventListener('click', () => {
                event.stopPropagation();
                emojiSpeed /= buttonChangeFactor; 
                gravityStrength /= buttonChangeFactor; 
            });
                        
            document.addEventListener('mousemove', function(e) {
                if (mouseDown && !blackHoleActive) {
                    // Check if the black hole is not active
                    createEmojiElement(e.clientX, e.clientY);
                }
            });

            document.addEventListener('mousedown', function() {
                mouseDown = true;
            });

            document.addEventListener('mouseup', function() {
                mouseDown = false;
            });

            document.addEventListener('touchmove', function(e) {
                e.preventDefault();
                if (!blackHoleActive) {
                    // Check if the black hole is not active
                    let touch = e.touches[0];
                    createEmojiElement(touch.clientX, touch.clientY);
                }
            });

            document.addEventListener('touchstart', function() {
                mouseDown = true;
            });

            document.addEventListener('touchend', function() {
                mouseDown = false;
            });

const asciiArtLetters = {
    'A': ["  A  ", " A A ", "AAAAA", "A   A", "A   A"],
    'B': ["BBB  ", "B  B ", "BBBB ", "B   B", "BBBB "],
    'C': [" CCC ", "C   C", "C    ", "C   C", " CCC "],
    'D': ["DDD  ", "D  D ", "D   D", "D  D ", "DDD  "],
    'E': ["EEEE ", "E    ", "EEE  ", "E    ", "EEEE "],
    'F': ["FFFF ", "F    ", "FFF  ", "F    ", "F    "],
    'G': [" GGG ", "G    ", "G  GG", "G   G", " GGG "],
    'H': ["H   H", "H   H", "HHHHH", "H   H", "H   H"],
    'I': [" III ", "  I  ", "  I  ", "  I  ", " III "],
    'J': [" JJJ ", "   J ", "   J ", "J  J ", " JJ  "],
    'K': ["K  K ", "K K  ", "KK   ", "K K  ", "K  K "],
    'L': ["L    ", "L    ", "L    ", "L    ", "LLLL "],
    'M': ["M   M", "MM MM", "M M M", "M   M", "M   M"],
    'N': ["N   N", "NN  N", "N N N", "N  NN", "N   N"],
    'O': [" OOO ", "O   O", "O   O", "O   O", " OOO "],
    'P': ["PPP  ", "P   P", "PPP  ", "P    ", "P    "],
    'Q': [" QQQ ", "Q   Q", "Q   Q", "Q  Q ", " QQ Q"],
    'R': ["RRR  ", "R   R", "RRR  ", "R R  ", "R  RR"],
    'S': [" SSS ", "S    ", " SSS ", "    S", "SSSS "],
    'T': ["TTTTT", "  T  ", "  T  ", "  T  ", "  T  "],
    'U': ["U   U", "U   U", "U   U", "U   U", " UUU "],
    'V': ["V   V", "V   V", "V   V", " V V ", "  V  "],
    'W': ["W   W", "W   W", "W W W", "WW WW", "W   W"],
    'X': ["X   X", " X X ", "  X  ", " X X ", "X   X"],
    'Y': ["Y   Y", " Y Y ", "  Y  ", "  Y  ", "  Y  "],
    'Z': ["ZZZZZ", "   Z ", "  Z  ", " Z   ", "ZZZZZ"]
};

const emojiDict = {
    // generated from https://unicode.org/Public/emoji/15.1/emoji-sequences.txt - February 2024
'watch': '‚åö',
'hourglass done': '‚åõ',
'fast-forward button': '‚è©',
'fast down button': '‚è¨',
'alarm clock': '‚è∞',
'hourglass not done': '‚è≥',
'white medium-small square': '‚óΩ',
'black medium-small square': '‚óæ',
'umbrella with rain drops': '‚òî',
'hot beverage': '‚òï',
'aries': '‚ôà',
'pisces': '‚ôì',
'wheelchair symbol': '‚ôø',
'anchor': '‚öì',
'high voltage': '‚ö°',
'white circle': '‚ö™',
'black circle': '‚ö´',
'soccer ball': '‚öΩ',
'baseball': '‚öæ',
'snowman without snow': '‚õÑ',
'sun behind cloud': '‚õÖ',
'ophiuchus': '‚õé',
'no entry': '‚õî',
'church': '‚õ™',
'fountain': '‚õ≤',
'flag in hole': '‚õ≥',
'sailboat': '‚õµ',
'tent': '‚õ∫',
'fuel pump': '‚õΩ',
'check mark button': '‚úÖ',
'raised fist': '‚úä',
'raised hand': '‚úã',
'sparkles': '‚ú®',
'cross mark': '‚ùå',
'cross mark button': '‚ùé',
'red question mark': '‚ùì',
'white exclamation mark': '‚ùï',
'red exclamation mark': '‚ùó',
'plus': '‚ûï',
'divide': '‚ûó',
'curly loop': '‚û∞',
'double curly loop': '‚ûø',
'black large square': '‚¨õ',
'white large square': '‚¨ú',
'star': '‚≠ê',
'hollow red circle': '‚≠ï',
'mahjong red dragon': 'üÄÑ',
'joker': 'üÉè',
'ab button (blood type)': 'üÜé',
'cl button': 'üÜë',
'vs button': 'üÜö',
'japanese ‚Äúhere‚Äù button': 'üàÅ',
'japanese ‚Äúfree of charge‚Äù button': 'üàö',
'japanese ‚Äúreserved‚Äù button': 'üàØ',
'japanese ‚Äúprohibited‚Äù button': 'üà≤',
'japanese ‚Äúnot free of charge‚Äù button': 'üà∂',
'japanese ‚Äúapplication‚Äù button': 'üà∏',
'japanese ‚Äúopen for business‚Äù button': 'üà∫',
'japanese ‚Äúbargain‚Äù button': 'üâê',
'japanese ‚Äúacceptable‚Äù button': 'üâë',
'cyclone': 'üåÄ',
'milky way': 'üåå',
'globe showing europe-africa': 'üåç',
'globe showing americas': 'üåé',
'globe showing asia-australia': 'üåè',
'globe with meridians': 'üåê',
'new moon': 'üåë',
'waxing crescent moon': 'üåí',
'first quarter moon': 'üåì',
'full moon': 'üåï',
'waning gibbous moon': 'üåñ',
'waning crescent moon': 'üåò',
'crescent moon': 'üåô',
'new moon face': 'üåö',
'first quarter moon face': 'üåõ',
'last quarter moon face': 'üåú',
'full moon face': 'üåù',
'sun with face': 'üåû',
'glowing star': 'üåü',
'shooting star': 'üå†',
'hot dog': 'üå≠',
'burrito': 'üåØ',
'chestnut': 'üå∞',
'seedling': 'üå±',
'evergreen tree': 'üå≤',
'deciduous tree': 'üå≥',
'palm tree': 'üå¥',
'cactus': 'üåµ',
'tulip': 'üå∑',
'tangerine': 'üçä',
'lemon': 'üçã',
'banana': 'üçå',
'green apple': 'üçè',
'pear': 'üçê',
'peach': 'üçë',
'clinking beer mugs': 'üçª',
'baby bottle': 'üçº',
'bottle with popping cork': 'üçæ',
'popcorn': 'üçø',
'ribbon': 'üéÄ',
'graduation cap': 'üéì',
'carousel horse': 'üé†',
'person surfing': 'üèÑ',
'sports medal': 'üèÖ',
'trophy': 'üèÜ',
'horse racing': 'üèá',
'american football': 'üèà',
'rugby football': 'üèâ',
'person swimming': 'üèä',
'cricket game': 'üèè',
'ping pong': 'üèì',
'house': 'üè†',
'japanese post office': 'üè£',
'post office': 'üè§',
'hospital': 'üè•',
'castle': 'üè∞',
'black flag': 'üè¥',
'badminton': 'üè∏',
'rabbit': 'üêá',
'cat': 'üêà',
'dragon': 'üêâ',
'whale': 'üêã',
'snail': 'üêå',
'horse': 'üêé',
'ram': 'üêè',
'goat': 'üêê',
'ewe': 'üêë',
'monkey': 'üêí',
'rooster': 'üêì',
'chicken': 'üêî',
'dog': 'üêï',
'pig': 'üêñ',
'boar': 'üêó',
'poodle': 'üê©',
'camel': 'üê™',
'two-hump camel': 'üê´',
'paw prints': 'üêæ',
'eyes': 'üëÄ',
'ear': 'üëÇ',
'bust in silhouette': 'üë§',
'busts in silhouette': 'üë•',
'boy': 'üë¶',
'woman and man holding hands': 'üë´',
'men holding hands': 'üë¨',
'women holding hands': 'üë≠',
'police officer': 'üëÆ',
'speech balloon': 'üí¨',
'thought balloon': 'üí≠',
'white flower': 'üíÆ',
'dollar banknote': 'üíµ',
'euro banknote': 'üí∂',
'pound banknote': 'üí∑',
'money with wings': 'üí∏',
'closed mailbox with raised flag': 'üì´',
'open mailbox with raised flag': 'üì¨',
'open mailbox with lowered flag': 'üì≠',
'postbox': 'üìÆ',
'postal horn': 'üìØ',
'newspaper': 'üì∞',
'mobile phone off': 'üì¥',
'no mobile phones': 'üìµ',
'antenna bars': 'üì∂',
'camera': 'üì∑',
'camera with flash': 'üì∏',
'video camera': 'üìπ',
'videocassette': 'üìº',
'prayer beads': 'üìø',
'repeat single button': 'üîÇ',
'clockwise vertical arrows': 'üîÉ',
'counterclockwise arrows button': 'üîÑ',
'muted speaker': 'üîá',
'speaker low volume': 'üîà',
'speaker medium volume': 'üîâ',
'speaker high volume': 'üîä',
'bell': 'üîî',
'bell with slash': 'üîï',
'bookmark': 'üîñ',
'water pistol': 'üî´',
'microscope': 'üî¨',
'telescope': 'üî≠',
'crystal ball': 'üîÆ',
'downwards button': 'üîΩ',
'kaaba': 'üïã',
'menorah': 'üïé',
'one o‚Äôclock': 'üïê',
'twelve o‚Äôclock': 'üïõ',
'one-thirty': 'üïú',
'twelve-thirty': 'üïß',
'man dancing': 'üï∫',
'middle finger': 'üñï',
'vulcan salute': 'üññ',
'black heart': 'üñ§',
'mount fuji': 'üóª',
'moai': 'üóø',
'grinning face': 'üòÄ',
'beaming face with smiling eyes': 'üòÅ',
'grinning squinting face': 'üòÜ',
'smiling face with halo': 'üòá',
'smiling face with horns': 'üòà',
'winking face': 'üòâ',
'smiling face with heart-eyes': 'üòç',
'smiling face with sunglasses': 'üòé',
'smirking face': 'üòè',
'neutral face': 'üòê',
'expressionless face': 'üòë',
'unamused face': 'üòí',
'pensive face': 'üòî',
'confused face': 'üòï',
'confounded face': 'üòñ',
'kissing face': 'üòó',
'face blowing a kiss': 'üòò',
'kissing face with smiling eyes': 'üòô',
'kissing face with closed eyes': 'üòö',
'face with tongue': 'üòõ',
'winking face with tongue': 'üòú',
'disappointed face': 'üòû',
'worried face': 'üòü',
'angry face': 'üò†',
'sad but relieved face': 'üò•',
'frowning face with open mouth': 'üò¶',
'anguished face': 'üòß',
'fearful face': 'üò®',
'tired face': 'üò´',
'grimacing face': 'üò¨',
'loudly crying face': 'üò≠',
'face with open mouth': 'üòÆ',
'hushed face': 'üòØ',
'anxious face with sweat': 'üò∞',
'flushed face': 'üò≥',
'sleeping face': 'üò¥',
'face with crossed-out eyes': 'üòµ',
'face without mouth': 'üò∂',
'face with medical mask': 'üò∑',
'weary cat': 'üôÄ',
'slightly frowning face': 'üôÅ',
'face with rolling eyes': 'üôÑ',
'person gesturing no': 'üôÖ',
'folded hands': 'üôè',
'rocket': 'üöÄ',
'helicopter': 'üöÅ',
'locomotive': 'üöÇ',
'railway car': 'üöÉ',
'bullet train': 'üöÖ',
'train': 'üöÜ',
'metro': 'üöá',
'light rail': 'üöà',
'station': 'üöâ',
'tram': 'üöä',
'tram car': 'üöã',
'bus': 'üöå',
'oncoming bus': 'üöç',
'trolleybus': 'üöé',
'bus stop': 'üöè',
'minibus': 'üöê',
'ambulance': 'üöë',
'police car': 'üöì',
'oncoming police car': 'üöî',
'taxi': 'üöï',
'oncoming taxi': 'üöñ',
'automobile': 'üöó',
'oncoming automobile': 'üöò',
'sport utility vehicle': 'üöô',
'delivery truck': 'üöö',
'articulated lorry': 'üöõ',
'aerial tramway': 'üö°',
'ship': 'üö¢',
'person rowing boat': 'üö£',
'speedboat': 'üö§',
'horizontal traffic light': 'üö•',
'vertical traffic light': 'üö¶',
'construction': 'üöß',
'no smoking': 'üö≠',
'litter in bin sign': 'üöÆ',
'non-potable water': 'üö±',
'bicycle': 'üö≤',
'no bicycles': 'üö≥',
'person mountain biking': 'üöµ',
'person walking': 'üö∂',
'no pedestrians': 'üö∑',
'children crossing': 'üö∏',
'men‚Äôs room': 'üöπ',
'water closet': 'üöæ',
'shower': 'üöø',
'person taking bath': 'üõÄ',
'bathtub': 'üõÅ',
'left luggage': 'üõÖ',
'person in bed': 'üõå',
'place of worship': 'üõê',
'stop sign': 'üõë',
'shopping cart': 'üõí',
'hindu temple': 'üõï',
'hut': '\u{0001f6d6}',
'elevator': '\u{0001f6d7}',
'wireless': '\u{0001f6dc}',
'playground slide': '\u{0001f6dd}',
'ring buoy': '\u{0001f6df}',
'airplane departure': 'üõ´',
'airplane arrival': 'üõ¨',
'kick scooter': 'üõ¥',
'canoe': 'üõ∂',
'sled': 'üõ∑',
'flying saucer': 'üõ∏',
'skateboard': 'üõπ',
'auto rickshaw': 'üõ∫',
'pickup truck': '\u{0001f6fb}',
'roller skate': '\u{0001f6fc}',
'orange circle': 'üü†',
'brown square': 'üü´',
'heavy equals sign': '\u{0001f7f0}',
'pinched fingers': '\u{0001f90c}',
'white heart': 'ü§ç',
'pinching hand': 'ü§è',
'zipper-mouth face': 'ü§ê',
'sign of the horns': 'ü§ò',
'call me hand': 'ü§ô',
'crossed fingers': 'ü§û',
'love-you gesture': 'ü§ü',
'cowboy hat face': 'ü§†',
'sneezing face': 'ü§ß',
'face with raised eyebrow': 'ü§®',
'exploding head': 'ü§Ø',
'pregnant woman': 'ü§∞',
'breast-feeding': 'ü§±',
'palms up together': 'ü§≤',
'selfie': 'ü§≥',
'person fencing': 'ü§∫',
'people wrestling': 'ü§º',
'person playing handball': 'ü§æ',
'diving mask': 'ü§ø',
'wilted flower': 'ü•Ä',
'goal net': 'ü•Ö',
'1st place medal': 'ü•á',
'martial arts uniform': 'ü•ã',
'curling stone': 'ü•å',
'lacrosse': 'ü•ç',
'flying disc': 'ü•è',
'croissant': 'ü•ê',
'pancakes': 'ü•û',
'dumpling': 'ü•ü',
'canned food': 'ü•´',
'leafy green': 'ü•¨',
'smiling face with hearts': 'ü•∞',
'yawning face': 'ü•±',
'smiling face with tear': '\u{0001f972}',
'partying face': 'ü•≥',
'cold face': 'ü•∂',
'ninja': '\u{0001f977}',
'disguised face': '\u{0001f978}',
'face holding back tears': '\u{0001f979}',
'pleading face': 'ü•∫',
'sari': 'ü•ª',
'lab coat': 'ü•º',
'flat shoe': 'ü•ø',
'crab': 'ü¶Ä',
'unicorn': 'ü¶Ñ',
'eagle': 'ü¶Ö',
'squid': 'ü¶ë',
'giraffe': 'ü¶í',
'cricket': 'ü¶ó',
'kangaroo': 'ü¶ò',
'swan': 'ü¶¢',
'mammoth': '\u{0001f9a3}',
'dodo': '\u{0001f9a4}',
'sloth': 'ü¶•',
'oyster': 'ü¶™',
'beaver': '\u{0001f9ab}',
'seal': '\u{0001f9ad}',
'guide dog': 'ü¶Æ',
'white cane': 'ü¶Ø',
'red hair': 'ü¶∞',
'supervillain': 'ü¶π',
'safety vest': 'ü¶∫',
'mechanical leg': 'ü¶ø',
'cheese wedge': 'üßÄ',
'cupcake': 'üßÅ',
'salt': 'üßÇ',
'beverage box': 'üßÉ',
'ice': 'üßä',
'bubble tea': '\u{0001f9cb}',
'troll': '\u{0001f9cc}',
'person standing': 'üßç',
'deaf person': 'üßè',
'face with monocle': 'üßê',
'socks': 'üß¶',
'red envelope': 'üßß',
'nazar amulet': 'üßø',
'ballet shoes': 'ü©∞',
'shorts': 'ü©≥',
'thong sandal': '\u{0001fa74}',
'light blue heart': '\u{0001fa75}',
'pink heart': '\u{0001fa77}',
'drop of blood': 'ü©∏',
'stethoscope': 'ü©∫',
'x-ray': '\u{0001fa7b}',
'crutch': '\u{0001fa7c}',
'yo-yo': 'ü™Ä',
'parachute': 'ü™Ç',
'boomerang': '\u{0001fa83}',
'nesting dolls': '\u{0001fa86}',
'maracas': '\u{0001fa87}',
'flute': '\u{0001fa88}',
'ringed planet': 'ü™ê',
'banjo': 'ü™ï',
'military helmet': '\u{0001fa96}',
'rock': '\u{0001faa8}',
'mirror ball': '\u{0001faa9}',
'hamsa': '\u{0001faac}',
'folding hand fan': '\u{0001faad}',
'khanda': '\u{0001faaf}',
'fly': '\u{0001fab0}',
'feather': '\u{0001fab6}',
'lotus': '\u{0001fab7}',
'nest with eggs': '\u{0001faba}',
'hyacinth': '\u{0001fabb}',
'wing': '\u{0001fabd}',
'goose': '\u{0001fabf}',
'anatomical heart': '\u{0001fac0}',
'people hugging': '\u{0001fac2}',
'pregnant man': '\u{0001fac3}',
'person with crown': '\u{0001fac5}',
'moose': '\u{0001face}',
'donkey': '\u{0001facf}',
'blueberries': '\u{0001fad0}',
'teapot': '\u{0001fad6}',
'pouring liquid': '\u{0001fad7}',
'jar': '\u{0001fad9}',
'ginger root': '\u{0001fada}',
'pea pod': '\u{0001fadb}',
'melting face': '\u{0001fae0}',
'bubbles': '\u{0001fae7}',
'shaking face': '\u{0001fae8}',
'hand with index finger and thumb crossed': '\u{0001faf0}',
'heart hands': '\u{0001faf6}',
'leftwards pushing hand': '\u{0001faf7}',
'rightwards pushing hand': '\u{0001faf8}',
'copyright': '¬©Ô∏è',
'registered': '¬ÆÔ∏è',
'double exclamation mark': '‚ÄºÔ∏è',
'exclamation question mark': '‚ÅâÔ∏è',
'trade mark': '‚Ñ¢Ô∏è',
'information': '‚ÑπÔ∏è',
'left-right arrow': '‚ÜîÔ∏è',
'up-down arrow': '‚ÜïÔ∏è',
'up-left arrow': '‚ÜñÔ∏è',
'up-right arrow': '‚ÜóÔ∏è',
'down-right arrow': '‚ÜòÔ∏è',
'down-left arrow': '‚ÜôÔ∏è',
'right arrow curving left': '‚Ü©Ô∏è',
'left arrow curving right': '‚Ü™Ô∏è',
'keyboard': '‚å®Ô∏è',
'eject button': '‚èèÔ∏è',
'next track button': '‚è≠Ô∏è',
'last track button': '‚èÆÔ∏è',
'play or pause button': '‚èØÔ∏è',
'stopwatch': '‚è±Ô∏è',
'timer clock': '‚è≤Ô∏è',
'pause button': '‚è∏Ô∏è',
'stop button': '‚èπÔ∏è',
'record button': '‚è∫Ô∏è',
'circled m': '‚ìÇÔ∏è',
'black small square': '‚ñ™Ô∏è',
'white small square': '‚ñ´Ô∏è',
'play button': '‚ñ∂Ô∏è',
'reverse button': '‚óÄÔ∏è',
'white medium square': '‚óªÔ∏è',
'black medium square': '‚óºÔ∏è',
'sun': '‚òÄÔ∏è',
'cloud': '‚òÅÔ∏è',
'umbrella': '‚òÇÔ∏è',
'snowman': '‚òÉÔ∏è',
'comet': '‚òÑÔ∏è',
'telephone': '‚òéÔ∏è',
'check box with check': '‚òëÔ∏è',
'shamrock': '‚òòÔ∏è',
'index pointing up': '‚òùÔ∏è',
'skull and crossbones': '‚ò†Ô∏è',
'radioactive': '‚ò¢Ô∏è',
'biohazard': '‚ò£Ô∏è',
'orthodox cross': '‚ò¶Ô∏è',
'star and crescent': '‚ò™Ô∏è',
'peace symbol': '‚òÆÔ∏è',
'yin yang': '‚òØÔ∏è',
'wheel of dharma': '‚ò∏Ô∏è',
'frowning face': '‚òπÔ∏è',
'smiling face': '‚ò∫Ô∏è',
'female sign': '‚ôÄÔ∏è',
'male sign': '‚ôÇÔ∏è',
'chess pawn': '‚ôüÔ∏è',
'spade suit': '‚ô†Ô∏è',
'club suit': '‚ô£Ô∏è',
'heart suit': '‚ô•Ô∏è',
'diamond suit': '‚ô¶Ô∏è',
'hot springs': '‚ô®Ô∏è',
'recycling symbol': '‚ôªÔ∏è',
'infinity': '‚ôæÔ∏è',
'hammer and pick': '‚öíÔ∏è',
'crossed swords': '‚öîÔ∏è',
'medical symbol': '‚öïÔ∏è',
'balance scale': '‚öñÔ∏è',
'alembic': '‚öóÔ∏è',
'gear': '‚öôÔ∏è',
'atom symbol': '‚öõÔ∏è',
'fleur-de-lis': '‚öúÔ∏è',
'warning': '‚ö†Ô∏è',
'transgender symbol': '‚ößÔ∏è',
'coffin': '‚ö∞Ô∏è',
'funeral urn': '‚ö±Ô∏è',
'cloud with lightning and rain': '‚õàÔ∏è',
'pick': '‚õèÔ∏è',
'rescue worker‚Äôs helmet': '‚õëÔ∏è',
'chains': '‚õìÔ∏è',
'shinto shrine': '‚õ©Ô∏è',
'mountain': '‚õ∞Ô∏è',
'umbrella on ground': '‚õ±Ô∏è',
'ferry': '‚õ¥Ô∏è',
'skier': '‚õ∑Ô∏è',
'ice skate': '‚õ∏Ô∏è',
'person bouncing ball': '‚õπÔ∏è',
'scissors': '‚úÇÔ∏è',
'airplane': '‚úàÔ∏è',
'envelope': '‚úâÔ∏è',
'victory hand': '‚úåÔ∏è',
'writing hand': '‚úçÔ∏è',
'pencil': '‚úèÔ∏è',
'black nib': '‚úíÔ∏è',
'check mark': '‚úîÔ∏è',
'multiply': '‚úñÔ∏è',
'latin cross': '‚úùÔ∏è',
'star of david': '‚ú°Ô∏è',
'eight-spoked asterisk': '‚ú≥Ô∏è',
'eight-pointed star': '‚ú¥Ô∏è',
'snowflake': '‚ùÑÔ∏è',
'sparkle': '‚ùáÔ∏è',
'heart exclamation': '‚ù£Ô∏è',
'red heart': '‚ù§Ô∏è',
'right arrow': '‚û°Ô∏è',
'right arrow curving up': '‚§¥Ô∏è',
'right arrow curving down': '‚§µÔ∏è',
'left arrow': '‚¨ÖÔ∏è',
'up arrow': '‚¨ÜÔ∏è',
'down arrow': '‚¨áÔ∏è',
'wavy dash': '„Ä∞Ô∏è',
'part alternation mark': '„ÄΩÔ∏è',
'japanese ‚Äúcongratulations‚Äù button': '„äóÔ∏è',
'japanese ‚Äúsecret‚Äù button': '„äôÔ∏è',
'a button (blood type)': 'üÖ∞Ô∏è',
'b button (blood type)': 'üÖ±Ô∏è',
'o button (blood type)': 'üÖæÔ∏è',
'p button': 'üÖøÔ∏è',
'japanese ‚Äúservice charge‚Äù button': 'üàÇÔ∏è',
'japanese ‚Äúmonthly amount‚Äù button': 'üà∑Ô∏è',
'thermometer': 'üå°Ô∏è',
'sun behind small cloud': 'üå§Ô∏è',
'sun behind large cloud': 'üå•Ô∏è',
'sun behind rain cloud': 'üå¶Ô∏è',
'cloud with rain': 'üåßÔ∏è',
'cloud with snow': 'üå®Ô∏è',
'cloud with lightning': 'üå©Ô∏è',
'tornado': 'üå™Ô∏è',
'fog': 'üå´Ô∏è',
'wind face': 'üå¨Ô∏è',
'hot pepper': 'üå∂Ô∏è',
'fork and knife with plate': 'üçΩÔ∏è',
'military medal': 'üéñÔ∏è',
'reminder ribbon': 'üéóÔ∏è',
'studio microphone': 'üéôÔ∏è',
'level slider': 'üéöÔ∏è',
'control knobs': 'üéõÔ∏è',
'film frames': 'üéûÔ∏è',
'admission tickets': 'üéüÔ∏è',
'person lifting weights': 'üèãÔ∏è',
'person golfing': 'üèåÔ∏è',
'motorcycle': 'üèçÔ∏è',
'racing car': 'üèéÔ∏è',
'snow-capped mountain': 'üèîÔ∏è',
'camping': 'üèïÔ∏è',
'beach with umbrella': 'üèñÔ∏è',
'building construction': 'üèóÔ∏è',
'houses': 'üèòÔ∏è',
'cityscape': 'üèôÔ∏è',
'derelict house': 'üèöÔ∏è',
'classical building': 'üèõÔ∏è',
'desert': 'üèúÔ∏è',
'desert island': 'üèùÔ∏è',
'national park': 'üèûÔ∏è',
'stadium': 'üèüÔ∏è',
'white flag': 'üè≥Ô∏è',
'rosette': 'üèµÔ∏è',
'label': 'üè∑Ô∏è',
'chipmunk': 'üêøÔ∏è',
'eye': 'üëÅÔ∏è',
'film projector': 'üìΩÔ∏è',
'om': 'üïâÔ∏è',
'dove': 'üïäÔ∏è',
'candle': 'üïØÔ∏è',
'mantelpiece clock': 'üï∞Ô∏è',
// 'hole': 'üï≥Ô∏è',
'person in suit levitating': 'üï¥Ô∏è',
'detective': 'üïµÔ∏è',
'sunglasses': 'üï∂Ô∏è',
'spider': 'üï∑Ô∏è',
'spider web': 'üï∏Ô∏è',
'joystick': 'üïπÔ∏è',
'linked paperclips': 'üñáÔ∏è',
'pen': 'üñäÔ∏è',
'fountain pen': 'üñãÔ∏è',
'paintbrush': 'üñåÔ∏è',
'crayon': 'üñçÔ∏è',
'hand with fingers splayed': 'üñêÔ∏è',
'desktop computer': 'üñ•Ô∏è',
'printer': 'üñ®Ô∏è',
'computer mouse': 'üñ±Ô∏è',
'trackball': 'üñ≤Ô∏è',
'framed picture': 'üñºÔ∏è',
'card index dividers': 'üóÇÔ∏è',
'card file box': 'üóÉÔ∏è',
'file cabinet': 'üóÑÔ∏è',
'wastebasket': 'üóëÔ∏è',
'spiral notepad': 'üóíÔ∏è',
'spiral calendar': 'üóìÔ∏è',
'clamp': 'üóúÔ∏è',
'old key': 'üóùÔ∏è',
'rolled-up newspaper': 'üóûÔ∏è',
'dagger': 'üó°Ô∏è',
'speaking head': 'üó£Ô∏è',
'left speech bubble': 'üó®Ô∏è',
'right anger bubble': 'üóØÔ∏è',
'ballot box with ballot': 'üó≥Ô∏è',
'world map': 'üó∫Ô∏è',
'couch and lamp': 'üõãÔ∏è',
'shopping bags': 'üõçÔ∏è',
'bellhop bell': 'üõéÔ∏è',
'bed': 'üõèÔ∏è',
'hammer and wrench': 'üõ†Ô∏è',
'shield': 'üõ°Ô∏è',
'oil drum': 'üõ¢Ô∏è',
'motorway': 'üõ£Ô∏è',
'railway track': 'üõ§Ô∏è',
'motor boat': 'üõ•Ô∏è',
'small airplane': 'üõ©Ô∏è',
'satellite': 'üõ∞Ô∏è',
'passenger ship': 'üõ≥Ô∏è', 
};


        </script>
    </body>
</html>
