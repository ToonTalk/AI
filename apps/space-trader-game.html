<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Trader - Space Property Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1a3e 100%);
            color: #ffffff;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .game-container {
            max-width: 1400px;
            width: 100%;
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .board-container {
            flex: 1;
            min-width: 600px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .board {
            width: 100%;
            aspect-ratio: 1;
            display: grid;
            grid-template-columns: repeat(11, 1fr);
            grid-template-rows: repeat(11, 1fr);
            gap: 2px;
            background: #1a1a3e;
            border: 3px solid #4a5568;
            border-radius: 10px;
            position: relative;
        }

        .space {
            background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
            border: 1px solid #4a5568;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 4px;
            font-size: 0.7em;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }

        .space:hover {
            background: linear-gradient(135deg, #3d4758 0%, #2a303c 100%);
            transform: scale(1.05);
            z-index: 10;
        }

        .space.corner {
            font-size: 0.65em;
            font-weight: bold;
        }

        .color-strip {
            width: 100%;
            height: 8px;
            border-radius: 2px;
            margin-bottom: 2px;
        }

        .space-name {
            flex: 1;
            display: flex;
            align-items: center;
            font-weight: 500;
        }

        .space-price {
            font-size: 0.8em;
            color: #a0aec0;
        }

        .player-token {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid white;
            position: absolute;
            bottom: 2px;
            transition: all 0.3s;
        }

        .player-token.player-0 {
            background: #f56565;
            left: 4px;
        }

        .player-token.player-1 {
            background: #48bb78;
            left: 18px;
        }

        .player-token.player-2 {
            background: #4299e1;
            right: 18px;
        }

        .player-token.player-3 {
            background: #ed8936;
            right: 4px;
        }

        .info-panel {
            width: 350px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .players-info {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .player-card {
            background: rgba(255, 255, 255, 0.08);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            border-left: 4px solid;
            transition: all 0.2s ease;
        }
        
        .player-card:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateX(5px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .player-card.active {
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 0 20px rgba(74, 85, 104, 0.5);
        }
        
        .player-card.active:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .player-card h3 {
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .player-indicator {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid white;
        }

        .controls {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        button {
            width: 100%;
            padding: 15px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 10px;
        }

        .roll-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .roll-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .roll-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .action-button {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .action-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(245, 87, 108, 0.4);
        }

        .message-box {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            min-height: 60px;
            font-size: 14px;
            line-height: 1.5;
        }

        .dice-display {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 15px 0;
        }

        .die {
            width: 50px;
            height: 50px;
            background: white;
            color: #1a202c;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            font-weight: bold;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .property-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #2d3748;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            max-width: 400px;
            width: 90%;
        }

        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 999;
        }

        .property-modal h2 {
            margin-bottom: 20px;
            color: #f7fafc;
        }

        .property-modal .color-strip {
            height: 20px;
            margin-bottom: 20px;
        }

        .property-details {
            margin: 15px 0;
            line-height: 1.8;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .modal-buttons button {
            flex: 1;
            margin: 0;
        }

        .player-setting {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            margin-bottom: 10px;
        }

        .player-setting label {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            flex: 1;
        }

        .player-setting input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        /* Board layout positions */
        .space[data-position="0"] { grid-column: 11; grid-row: 11; }
        .space[data-position="1"] { grid-column: 10; grid-row: 11; }
        .space[data-position="2"] { grid-column: 9; grid-row: 11; }
        .space[data-position="3"] { grid-column: 8; grid-row: 11; }
        .space[data-position="4"] { grid-column: 7; grid-row: 11; }
        .space[data-position="5"] { grid-column: 6; grid-row: 11; }
        .space[data-position="6"] { grid-column: 5; grid-row: 11; }
        .space[data-position="7"] { grid-column: 4; grid-row: 11; }
        .space[data-position="8"] { grid-column: 3; grid-row: 11; }
        .space[data-position="9"] { grid-column: 2; grid-row: 11; }
        .space[data-position="10"] { grid-column: 1; grid-row: 11; }
        
        .space[data-position="11"] { grid-column: 1; grid-row: 10; }
        .space[data-position="12"] { grid-column: 1; grid-row: 9; }
        .space[data-position="13"] { grid-column: 1; grid-row: 8; }
        .space[data-position="14"] { grid-column: 1; grid-row: 7; }
        .space[data-position="15"] { grid-column: 1; grid-row: 6; }
        .space[data-position="16"] { grid-column: 1; grid-row: 5; }
        .space[data-position="17"] { grid-column: 1; grid-row: 4; }
        .space[data-position="18"] { grid-column: 1; grid-row: 3; }
        .space[data-position="19"] { grid-column: 1; grid-row: 2; }
        .space[data-position="20"] { grid-column: 1; grid-row: 1; }
        
        .space[data-position="21"] { grid-column: 2; grid-row: 1; }
        .space[data-position="22"] { grid-column: 3; grid-row: 1; }
        .space[data-position="23"] { grid-column: 4; grid-row: 1; }
        .space[data-position="24"] { grid-column: 5; grid-row: 1; }
        .space[data-position="25"] { grid-column: 6; grid-row: 1; }
        .space[data-position="26"] { grid-column: 7; grid-row: 1; }
        .space[data-position="27"] { grid-column: 8; grid-row: 1; }
        .space[data-position="28"] { grid-column: 9; grid-row: 1; }
        .space[data-position="29"] { grid-column: 10; grid-row: 1; }
        .space[data-position="30"] { grid-column: 11; grid-row: 1; }
        
        .space[data-position="31"] { grid-column: 11; grid-row: 2; }
        .space[data-position="32"] { grid-column: 11; grid-row: 3; }
        .space[data-position="33"] { grid-column: 11; grid-row: 4; }
        .space[data-position="34"] { grid-column: 11; grid-row: 5; }
        .space[data-position="35"] { grid-column: 11; grid-row: 6; }
        .space[data-position="36"] { grid-column: 11; grid-row: 7; }
        .space[data-position="37"] { grid-column: 11; grid-row: 8; }
        .space[data-position="38"] { grid-column: 11; grid-row: 9; }
        .space[data-position="39"] { grid-column: 11; grid-row: 10; }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="board-container">
            <div class="board" id="board"></div>
        </div>
        
        <div class="info-panel">
            <div class="controls">
                <button class="action-button" id="fastModeButton" style="background: linear-gradient(135deg, #38b2ac 0%, #319795 100%);">Fast Mode</button>
                <button class="action-button" id="pauseButton" style="background: linear-gradient(135deg, #ed8936 0%, #dd6b20 100%);">Pause</button>
                <button class="action-button" id="settingsButton" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">Settings</button>
                <button class="action-button" id="resetButton" style="background: linear-gradient(135deg, #fc8181 0%, #f56565 100%);">New Game</button>
                
                <div class="message-box" id="messageBox">Welcome to Cosmic Trader! Evolution mode enabled. Game will auto-start in a moment...</div>
                
                <div style="background: rgba(255, 255, 255, 0.1); padding: 15px; border-radius: 10px; margin-bottom: 15px; font-size: 13px;">
                    <div id="generationDisplay" style="display: none; color: #667eea; font-weight: bold; margin-bottom: 8px;"></div>
                    <div><strong>Turn:</strong> <span id="turnCounter">0</span> / <span id="maxTurnsDisplay">200</span></div>
                    <div><strong>Properties Owned:</strong> <span id="propertiesOwned">0</span></div>
                    <div><strong>Total Rent Collected:</strong> $<span id="totalRent">0</span></div>
                </div>
                
                <div class="dice-display">
                    <div class="die" id="die1">?</div>
                    <div class="die" id="die2">?</div>
                </div>
                
                <button class="roll-button" id="rollButton">Roll Dice</button>
                <button class="action-button" id="endTurnButton" style="display: none;">End Turn</button>
            </div>
            
            <div class="players-info" id="playersInfo"></div>
        </div>
    </div>

    <div class="modal-overlay" id="modalOverlay"></div>
    <div class="property-modal" id="propertyModal">
        <h2 id="modalTitle"></h2>
        <div class="color-strip" id="modalColorStrip"></div>
        <div class="property-details" id="modalDetails"></div>
        <div class="modal-buttons">
            <button class="action-button" id="buyButton">Buy Property</button>
            <button class="roll-button" id="closeButton">Close</button>
        </div>
    </div>

    <div class="property-modal" id="buildingModal">
        <h2>Build on Your Monopoly</h2>
        <div class="property-details" id="buildingDetails"></div>
        <div class="modal-buttons">
            <button class="action-button" id="confirmBuildButton">Build Station</button>
            <button class="roll-button" id="skipBuildButton">Skip</button>
        </div>
    </div>

    <div class="property-modal" id="playerDetailsModal" style="max-width: 600px;">
        <h2 id="playerDetailsTitle">Player Details</h2>
        <div class="property-details" id="playerDetailsContent"></div>
        <div class="modal-buttons">
            <button class="roll-button" id="closePlayerDetailsButton">Close</button>
        </div>
    </div>

    <div class="property-modal" id="settingsModal" style="max-width: 500px; max-height: 80vh; overflow-y: auto;">
        <h2>Game Settings</h2>
        <div class="property-details" id="settingsContent" style="margin: 20px 0;">
            <div style="margin-bottom: 20px;">
                <h3 style="margin-bottom: 10px; font-size: 16px;">Player Configuration</h3>
                <div id="playerSettings"></div>
            </div>
            <div style="margin-bottom: 20px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.2);">
                <h3 style="margin-bottom: 10px; font-size: 16px;">Evolution Mode</h3>
                <div class="player-setting">
                    <label style="flex: 1;">
                        <input type="checkbox" id="evolutionModeCheckbox">
                        <span>Enable Evolution (Winner kept, opponents mutated)</span>
                    </label>
                </div>
                <div class="player-setting" style="margin-top: 5px;">
                    <label style="flex: 1;">
                        <input type="checkbox" id="autoContinueCheckbox">
                        <span>Auto-continue to next generation</span>
                    </label>
                </div>
                
                <div style="margin-top: 15px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 8px;">
                    <h4 style="margin-bottom: 10px; font-size: 14px; color: #a0aec0;">Mutation Settings</h4>
                    
                    <div style="margin-bottom: 10px;">
                        <label style="display: block; margin-bottom: 5px; font-size: 13px;">
                            Number of Winners Competing:
                        </label>
                        <input type="number" id="numCompetitors" min="1" max="3" value="1" 
                               style="width: 80px; padding: 5px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); color: white; border-radius: 5px;">
                        <span style="font-size: 12px; color: #a0aec0; margin-left: 10px;">(1-3, from winner pool)</span>
                    </div>
                    
                    <div style="margin-bottom: 10px;">
                        <label style="display: block; margin-bottom: 5px; font-size: 13px;">
                            Number of Mutants per Generation:
                        </label>
                        <input type="number" id="numMutants" min="1" max="3" value="3" 
                               style="width: 80px; padding: 5px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); color: white; border-radius: 5px;">
                        <span style="font-size: 12px; color: #a0aec0; margin-left: 10px;">(1-3 opponents)</span>
                    </div>
                    
                    <div style="margin-bottom: 10px;">
                        <label style="display: block; margin-bottom: 5px; font-size: 13px;">
                            Mutation Strength:
                        </label>
                        <input type="number" id="mutationRate" min="0.01" max="1.0" step="0.01" value="0.20" 
                               style="width: 80px; padding: 5px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); color: white; border-radius: 5px;">
                        <span style="font-size: 12px; color: #a0aec0; margin-left: 10px;">(0.01-1.0, default 0.20)</span>
                    </div>
                    
                    <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1);">
                        <h5 style="margin-bottom: 10px; font-size: 13px; color: #a0aec0;">Genetic Crossover (Mating)</h5>
                        
                        <div style="margin-bottom: 10px;">
                            <label style="display: block; margin-bottom: 5px; font-size: 13px;">
                                Mating Rate:
                            </label>
                            <input type="number" id="matingRate" min="0.0" max="1.0" step="0.1" value="0.5" 
                                   style="width: 80px; padding: 5px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); color: white; border-radius: 5px;">
                            <span style="font-size: 12px; color: #a0aec0; margin-left: 10px;">(0.0-1.0, fraction using crossover)</span>
                        </div>
                        
                        <div style="margin-bottom: 10px;">
                            <label style="display: block; margin-bottom: 5px; font-size: 13px;">
                                Crossover Method:
                            </label>
                            <select id="matingMethod" 
                                    style="padding: 5px 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); color: white; border-radius: 5px;">
                                <option value="average">Average (blend parents)</option>
                                <option value="random">Random (pick each gene from random parent)</option>
                            </select>
                        </div>
                    </div>
                    
                    <div style="font-size: 11px; color: #718096; line-height: 1.4; margin-top: 8px;">
                        <strong>Winner Pool Evolution:</strong> Winners are saved to a pool. Each game selects competitors from this pool with probability proportional to their win rate. Mutants and offspring from mating fill remaining slots.
                    </div>
                </div>
                
                <div style="margin-top: 10px;">
                    <label style="display: block; margin-bottom: 5px; font-size: 14px;">
                        Max Turns Per Game:
                    </label>
                    <input type="number" id="maxTurns" min="50" max="1000" value="200" 
                           style="width: 100px; padding: 5px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); color: white; border-radius: 5px;">
                    <span style="font-size: 12px; color: #a0aec0; margin-left: 10px;">(50-1000, default 200)</span>
                </div>
                
                <div style="margin-top: 10px;">
                    <label style="display: block; margin-bottom: 5px; font-size: 14px;">
                        Number of Generations to Run:
                    </label>
                    <input type="number" id="generationsToRun" min="1" max="1000" value="10" 
                           style="width: 100px; padding: 5px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); color: white; border-radius: 5px;">
                    <span style="font-size: 12px; color: #a0aec0; margin-left: 10px;">(1-1000)</span>
                </div>
                <div style="margin-top: 10px;">
                    <label style="display: block; margin-bottom: 5px; font-size: 14px;">
                        Evaluation Games (Champion vs Always Spend + Random):
                    </label>
                    <input type="number" id="evaluationGames" min="0" max="100" value="10" 
                           style="width: 100px; padding: 5px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); color: white; border-radius: 5px;">
                    <span style="font-size: 12px; color: #a0aec0; margin-left: 10px;">(0-100, 0 = skip)</span>
                </div>
                <div style="margin-top: 10px; font-size: 12px; color: #a0aec0; line-height: 1.5;">
                    Evolution uses a winner pool system. All AI players are tracked - winners join the pool, losers update their stats. Each game selects competitors from the pool with probability proportional to their win rate. This prevents good strategies from being lost due to a single unlucky game.
                </div>
                
                <div style="margin-top: 20px; padding: 15px; background: rgba(102, 126, 234, 0.1); border-radius: 8px; border: 1px solid rgba(102, 126, 234, 0.3);">
                    <h4 style="margin-bottom: 10px; font-size: 14px; color: #667eea;">🧪 Experiment Presets</h4>
                    <div style="font-size: 11px; color: #a0aec0; margin-bottom: 10px;">
                        Quick configurations to explore evolutionary principles:
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <button onclick="applyPreset('sexual')" style="padding: 8px; background: rgba(102, 126, 234, 0.2); border: 1px solid rgba(102, 126, 234, 0.4); color: white; border-radius: 5px; cursor: pointer; font-size: 11px;">
                            Sexual Reproduction (100% mating)
                        </button>
                        <button onclick="applyPreset('asexual')" style="padding: 8px; background: rgba(102, 126, 234, 0.2); border: 1px solid rgba(102, 126, 234, 0.4); color: white; border-radius: 5px; cursor: pointer; font-size: 11px;">
                            Asexual (0% mating)
                        </button>
                        <button onclick="applyPreset('highMutation')" style="padding: 8px; background: rgba(102, 126, 234, 0.2); border: 1px solid rgba(102, 126, 234, 0.4); color: white; border-radius: 5px; cursor: pointer; font-size: 11px;">
                            High Mutation (r-strategy)
                        </button>
                        <button onclick="applyPreset('lowMutation')" style="padding: 8px; background: rgba(102, 126, 234, 0.2); border: 1px solid rgba(102, 126, 234, 0.4); color: white; border-radius: 5px; cursor: pointer; font-size: 11px;">
                            Low Mutation (K-strategy)
                        </button>
                        <button onclick="applyPreset('small')" style="padding: 8px; background: rgba(102, 126, 234, 0.2); border: 1px solid rgba(102, 126, 234, 0.4); color: white; border-radius: 5px; cursor: pointer; font-size: 11px;">
                            Small Population
                        </button>
                        <button onclick="applyPreset('large')" style="padding: 8px; background: rgba(102, 126, 234, 0.2); border: 1px solid rgba(102, 126, 234, 0.4); color: white; border-radius: 5px; cursor: pointer; font-size: 11px;">
                            Large Population
                        </button>
                        <button onclick="applyPreset('bottleneck')" style="padding: 8px; background: rgba(102, 126, 234, 0.2); border: 1px solid rgba(102, 126, 234, 0.4); color: white; border-radius: 5px; cursor: pointer; font-size: 11px;">
                            Genetic Bottleneck
                        </button>
                        <button onclick="applyPreset('diverse')" style="padding: 8px; background: rgba(102, 126, 234, 0.2); border: 1px solid rgba(102, 126, 234, 0.4); color: white; border-radius: 5px; cursor: pointer; font-size: 11px;">
                            High Diversity
                        </button>
                    </div>
                    
                    <div style="margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 5px; font-size: 10px; color: #a0aec0; line-height: 1.4;">
                        <strong>Experiment Ideas:</strong><br>
                        • Compare sexual vs asexual after 50 generations<br>
                        • Test if high mutation helps escape local optima<br>
                        • See how bottlenecks affect long-term fitness<br>
                        • Compare average vs random crossover methods
                    </div>
                </div>
                
                <div style="margin-top: 15px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 8px;">
                    <h4 style="margin-bottom: 10px; font-size: 14px; color: #a0aec0;">Save/Load Champion</h4>
                    <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                        <button class="action-button" id="saveChampionButton" style="flex: 1; margin: 0; padding: 10px; font-size: 14px;">
                            Save Weights
                        </button>
                        <button class="action-button" id="loadChampionButton" style="flex: 1; margin: 0; padding: 10px; font-size: 14px;">
                            Load Weights
                        </button>
                    </div>
                    <input type="file" id="loadChampionFile" accept=".json" style="display: none;">
                    <div style="font-size: 11px; color: #718096; line-height: 1.4;">
                        Save your evolved champion's weights to a JSON file or load previously saved weights.
                    </div>
                </div>
                
                <button class="action-button" id="viewHistoryButton" style="margin-top: 15px; display: none; width: 100%;">View Evolution History</button>
                <button class="action-button" id="saveRunButton" style="margin-top: 10px; display: none; width: 100%; background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);">Save This Run for Comparison</button>
                <button class="action-button" id="newExperimentButton" style="margin-top: 10px; display: none; width: 100%; background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);">Start New Experiment</button>
                <button class="action-button" id="viewComparisonButton" style="margin-top: 10px; display: none; width: 100%; background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);">View Experiment Comparison</button>
            </div>
        </div>
        <div class="modal-buttons">
            <button class="roll-button" id="closeSettingsButton">Close</button>
        </div>
    </div>

    <div class="property-modal" id="historyModal" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
        <h2>Evolution History</h2>
        <div id="historyContent" style="margin: 20px 0; font-family: monospace; font-size: 12px; line-height: 1.6;">
        </div>
        <div class="modal-buttons">
            <button class="action-button" id="downloadHistoryButton">Export HTML Report</button>
            <button class="roll-button" id="closeHistoryButton">Close</button>
        </div>
    </div>

    <script>
        const spaces = [
            { name: "Launch Pad", type: "corner", color: null, price: 0, buildings: 0 },
            { name: "Mercury Station", type: "property", color: "#8B4513", price: 60, buildings: 0 },
            { name: "Cosmic Event", type: "event", color: null, price: 0, buildings: 0 },
            { name: "Venus Outpost", type: "property", color: "#8B4513", price: 60, buildings: 0 },
            { name: "Fuel Tax", type: "tax", color: null, price: 0, buildings: 0 },
            { name: "Warp Gate Alpha", type: "transport", color: "#718096", price: 200, buildings: 0 },
            { name: "Mars Colony", type: "property", color: "#3182CE", price: 100, buildings: 0 },
            { name: "Nebula Chance", type: "chance", color: null, price: 0, buildings: 0 },
            { name: "Jupiter Base", type: "property", color: "#3182CE", price: 100, buildings: 0 },
            { name: "Saturn Ring", type: "property", color: "#3182CE", price: 120, buildings: 0 },
            { name: "Asteroid Belt", type: "corner", color: null, price: 0, buildings: 0 },
            { name: "Uranus Hub", type: "property", color: "#D53F8C", price: 140, buildings: 0 },
            { name: "Power Core", type: "utility", color: "#F6AD55", price: 150, buildings: 0 },
            { name: "Neptune Port", type: "property", color: "#D53F8C", price: 140, buildings: 0 },
            { name: "Pluto Station", type: "property", color: "#D53F8C", price: 160, buildings: 0 },
            { name: "Warp Gate Beta", type: "transport", color: "#718096", price: 200, buildings: 0 },
            { name: "Proxima A", type: "property", color: "#F56565", price: 180, buildings: 0 },
            { name: "Cosmic Event", type: "event", color: null, price: 0, buildings: 0 },
            { name: "Proxima B", type: "property", color: "#F56565", price: 180, buildings: 0 },
            { name: "Proxima C", type: "property", color: "#F56565", price: 200, buildings: 0 },
            { name: "Starport", type: "corner", color: null, price: 0, buildings: 0 },
            { name: "Alpha Centauri", type: "property", color: "#F6E05E", price: 220, buildings: 0 },
            { name: "Nebula Chance", type: "chance", color: null, price: 0, buildings: 0 },
            { name: "Betelgeuse", type: "property", color: "#F6E05E", price: 220, buildings: 0 },
            { name: "Sirius System", type: "property", color: "#F6E05E", price: 240, buildings: 0 },
            { name: "Warp Gate Gamma", type: "transport", color: "#718096", price: 200, buildings: 0 },
            { name: "Andromeda I", type: "property", color: "#48BB78", price: 260, buildings: 0 },
            { name: "Andromeda II", type: "property", color: "#48BB78", price: 260, buildings: 0 },
            { name: "Fusion Plant", type: "utility", color: "#F6AD55", price: 150, buildings: 0 },
            { name: "Andromeda III", type: "property", color: "#48BB78", price: 280, buildings: 0 },
            { name: "Black Hole", type: "corner", color: null, price: 0, buildings: 0 },
            { name: "Milky Core", type: "property", color: "#805AD5", price: 300, buildings: 0 },
            { name: "Cosmic Event", type: "event", color: null, price: 0, buildings: 0 },
            { name: "Galactic Center", type: "property", color: "#805AD5", price: 300, buildings: 0 },
            { name: "Singularity", type: "property", color: "#805AD5", price: 320, buildings: 0 },
            { name: "Warp Gate Delta", type: "transport", color: "#718096", price: 200, buildings: 0 },
            { name: "Nebula Chance", type: "chance", color: null, price: 0, buildings: 0 },
            { name: "Omega Station", type: "property", color: "#2C5282", price: 350, buildings: 0 },
            { name: "Space Tax", type: "tax", color: null, price: 0, buildings: 0 },
            { name: "Quantum Realm", type: "property", color: "#2C5282", price: 400, buildings: 0 }
        ];

        // Game state variables
        let currentPlayer = 0;
        let hasRolled = false;
        let decisionThreshold = 0;
        let fastMode = false;
        let fastModeInterval = null;
        let turnCount = 0;
        let gameStats = {
            propertiesSold: 0,
            totalRentPaid: 0,
            totalTaxesPaid: 0
        };
        let evolutionMode = true;
        let evolutionHistory = [];
        let championWeights = null;
        let autoContinue = true;
        let playerAISettings = [true, true, true, true];
        let shouldResumeFastMode = false;
        let isPaused = false;
        let maxGenerations = 10;
        let evaluationGames = 10;
        let isInEvaluationPhase = false;
        let evaluationResults = [];
        let numMutants = 3; // How many opponents are mutants (1-3)
        let mutationRate = 0.20; // How much weights change (0.01-1.0)
        let maxTurns = 200; // Maximum turns before declaring richest player winner
        
        // Population-based evolution
        let winnerPool = []; // Array of {weights, wins, games, score}
        let numCompetitors = 1; // How many winners compete (1-3)
        
        // Mating/crossover settings
        let matingRate = 0.5; // Fraction of offspring created by mating vs mutation (0.0-1.0)
        let matingMethod = 'average'; // 'average' or 'random' - how to combine parent genes
        
        // Experiment tracking
        let experimentRuns = []; // Store multiple runs for comparison
        let currentExperimentName = '';
        
        // Debug logging control
        let debugLogging = false;
        let debugTurnsRemaining = 0;
        let player1BankruptTurn = -1;

        let players = [
            { name: "Player 1", money: 1200, position: 0, color: "#f56565", properties: [], isAI: playerAISettings[0], aiWeights: null, totalRentCollected: 0, alwaysSpend: false },
            { name: "Player 2", money: 1200, position: 0, color: "#48bb78", properties: [], isAI: playerAISettings[1], aiWeights: null, totalRentCollected: 0, alwaysSpend: false },
            { name: "Player 3", money: 1200, position: 0, color: "#4299e1", properties: [], isAI: playerAISettings[2], aiWeights: null, totalRentCollected: 0, alwaysSpend: false },
            { name: "Player 4", money: 1200, position: 0, color: "#ed8936", properties: [], isAI: playerAISettings[3], aiWeights: null, totalRentCollected: 0, alwaysSpend: false }
        ];

        // Initialize AI weights for computer players
        function initializeAIWeights() {
            players.forEach(player => {
                if (player.isAI && !player.alwaysSpend) {
                    player.aiWeights = {
                        // Purchase decision weights (5)
                        cashOnHandForBuying: (Math.random() - 0.5) * 2,
                        propertyPrice: (Math.random() - 0.5) * 2,
                        rentValue: (Math.random() - 0.5) * 2,
                        colorGroupOwned: (Math.random() - 0.5) * 2,
                        colorGroupAvailable: (Math.random() - 0.5) * 2,
                        
                        // Building decision weights (3)
                        cashOnHandForBuilding: (Math.random() - 0.5) * 2,
                        buildingRentWeight: (Math.random() - 0.5) * 2,
                        buildingCostWeight: (Math.random() - 0.5) * 2
                    };
                }
            });
            
            decisionThreshold = 0;
        }

        // Create mutated version of weights
        function mutateWeights(baseWeights) {
            const mutated = {};
            
            for (const key in baseWeights) {
                // Add random mutation using the global mutationRate setting
                const mutation = (Math.random() - 0.5) * mutationRate * 2;
                mutated[key] = Math.max(-1, Math.min(1, baseWeights[key] + mutation));
            }
            
            return mutated;
        }
        
        // Create offspring by mating two parent weights
        function mateWeights(parent1, parent2) {
            const offspring = {};
            
            if (matingMethod === 'average') {
                // Average method: blend the weights from both parents
                for (const key in parent1) {
                    offspring[key] = (parent1[key] + parent2[key]) / 2;
                }
            } else {
                // Random method: randomly pick each gene from one parent or the other
                for (const key in parent1) {
                    offspring[key] = Math.random() < 0.5 ? parent1[key] : parent2[key];
                }
            }
            
            return offspring;
        }
        
        // Select two different parents from winner pool for mating
        function selectParentsForMating() {
            if (winnerPool.length < 2) {
                // Not enough parents, return null
                return null;
            }
            
            // Select first parent using fitness-proportionate selection
            const parent1 = selectFromWinnerPool();
            
            // Select second parent (must be different)
            let parent2;
            let attempts = 0;
            do {
                parent2 = selectFromWinnerPool();
                attempts++;
            } while (attempts < 10 && JSON.stringify(parent1) === JSON.stringify(parent2));
            
            if (JSON.stringify(parent1) === JSON.stringify(parent2)) {
                // Couldn't find different parent, return null
                return null;
            }
            
            return { parent1, parent2 };
        }
        
        // Add winner to pool or update existing
        function updateWinnerPool(weights, won) {
            // Find if this AI already exists in pool (similar weights)
            let existingIndex = -1;
            for (let i = 0; i < winnerPool.length; i++) {
                const pool = winnerPool[i];
                let similarity = 0;
                for (const key in weights) {
                    similarity += Math.abs(weights[key] - pool.weights[key]);
                }
                if (similarity < 0.5) { // Very similar weights
                    existingIndex = i;
                    break;
                }
            }
            
            if (existingIndex >= 0) {
                // Update existing
                winnerPool[existingIndex].games++;
                if (won) winnerPool[existingIndex].wins++;
                winnerPool[existingIndex].score = winnerPool[existingIndex].wins / winnerPool[existingIndex].games;
            } else if (won) {
                // Add new winner
                winnerPool.push({
                    weights: cloneWeights(weights),
                    wins: 1,
                    games: 1,
                    score: 1.0
                });
            }
            
            // Keep only top 20 by score
            winnerPool.sort((a, b) => b.score - a.score);
            if (winnerPool.length > 20) {
                winnerPool = winnerPool.slice(0, 20);
            }
        }
        
        // Select competitor from winner pool using fitness-proportionate selection
        function selectFromWinnerPool() {
            if (winnerPool.length === 0) return null;
            
            // Calculate total fitness
            let totalFitness = 0;
            winnerPool.forEach(w => totalFitness += w.score);
            
            // Roulette wheel selection
            let random = Math.random() * totalFitness;
            let sum = 0;
            for (let i = 0; i < winnerPool.length; i++) {
                sum += winnerPool[i].score;
                if (random <= sum) {
                    return cloneWeights(winnerPool[i].weights);
                }
            }
            
            return cloneWeights(winnerPool[winnerPool.length - 1].weights);
        }

        // Clone weights
        function cloneWeights(weights) {
            const cloned = {};
            for (const key in weights) {
                cloned[key] = weights[key];
            }
            return cloned;
        }

        function initBoard() {
            const board = document.getElementById('board');
            spaces.forEach((space, index) => {
                const spaceDiv = document.createElement('div');
                spaceDiv.className = 'space' + (space.type === 'corner' ? ' corner' : '');
                spaceDiv.dataset.position = index;
                
                if (space.color) {
                    const colorStrip = document.createElement('div');
                    colorStrip.className = 'color-strip';
                    colorStrip.style.background = space.color;
                    spaceDiv.appendChild(colorStrip);
                }
                
                const nameDiv = document.createElement('div');
                nameDiv.className = 'space-name';
                nameDiv.textContent = space.name;
                spaceDiv.appendChild(nameDiv);
                
                if (space.price > 0) {
                    const priceDiv = document.createElement('div');
                    priceDiv.className = 'space-price';
                    priceDiv.textContent = `$${space.price}`;
                    spaceDiv.appendChild(priceDiv);
                }
                
                if (space.buildings > 0 && space.type === 'property') {
                    const buildingDiv = document.createElement('div');
                    buildingDiv.style.cssText = 'font-size: 0.7em; color: #ffd700; font-weight: bold;';
                    if (space.buildings === 5) {
                        buildingDiv.textContent = 'STAR';
                    } else {
                        buildingDiv.textContent = 'BUILD'.repeat(space.buildings);
                    }
                    spaceDiv.appendChild(buildingDiv);
                }
                
                spaceDiv.addEventListener('click', () => showPropertyInfo(index));
                board.appendChild(spaceDiv);
            });
            
            updatePlayerPositions();
            updatePlayersInfo();
        }

        function updatePlayerPositions() {
            document.querySelectorAll('.player-token').forEach(token => token.remove());
            
            players.forEach((player, index) => {
                const space = document.querySelector(`[data-position="${player.position}"]`);
                const token = document.createElement('div');
                token.className = `player-token player-${index}`;
                space.appendChild(token);
            });
        }

        function updatePlayersInfo() {
            const playersInfo = document.getElementById('playersInfo');
            playersInfo.innerHTML = '<h2 style="margin-bottom: 15px;">Players</h2>';
            
            players.forEach((player, index) => {
                const card = document.createElement('div');
                card.className = 'player-card' + (index === currentPlayer ? ' active' : '');
                card.style.borderLeftColor = player.color;
                
                if (player.money <= 0) {
                    card.style.opacity = '0.5';
                }
                
                const colors = new Set(player.properties.map(p => spaces[p].color).filter(c => c));
                let monopolies = 0;
                colors.forEach(color => {
                    if (hasMonopoly(index, color)) {
                        monopolies++;
                    }
                });
                
                const monopolyText = monopolies > 0 ? ` | Monopolies: ${monopolies}` : '';
                const strategyLabel = player.alwaysSpend ? ' (Always Spend)' : (player.isAI ? ' (AI)' : '');
                const status = player.money <= 0 ? ' BANKRUPT' : strategyLabel;
                
                let potentialRent = 0;
                player.properties.forEach(propIndex => {
                    const space = spaces[propIndex];
                    if (space.type === 'property' && space.owner === index) {
                        potentialRent += calculateRent(space, index);
                    }
                });
                
                const currentMoney = player.money || 0;
                const currentRentCollected = player.totalRentCollected || 0;
                
                card.innerHTML = `
                    <h3>
                        <div class="player-indicator" style="background: ${player.color};"></div>
                        ${player.name}${status}
                    </h3>
                    <div>Credits: $${currentMoney.toLocaleString()}</div>
                    <div>Properties: ${player.properties.length}${monopolyText}</div>
                    <div style="font-size: 0.9em; color: #a0aec0;">Rent Earned: $${currentRentCollected.toLocaleString()}</div>
                    <div style="font-size: 0.9em; color: #cbd5e0;">Potential: $${potentialRent.toLocaleString()}/turn</div>
                    <div>Location: ${spaces[player.position].name}</div>
                `;
                
                // Make card clickable to show details
                card.style.cursor = 'pointer';
                card.addEventListener('click', () => showPlayerDetails(index));
                card.title = 'Click to view property details';
                
                playersInfo.appendChild(card);
            });
        }

        function rollDice() {
            if (hasRolled || isPaused) return;
            
            if (players[currentPlayer].money <= 0) {
                endTurn();
                return;
            }
            
            const die1 = Math.floor(Math.random() * 6) + 1;
            const die2 = Math.floor(Math.random() * 6) + 1;
            const total = die1 + die2;
            
            if (!fastMode) {
                document.getElementById('die1').textContent = die1;
                document.getElementById('die2').textContent = die2;
            }
            
            hasRolled = true;
            
            if (!fastMode) {
                document.getElementById('rollButton').disabled = true;
                document.getElementById('endTurnButton').style.display = 'block';
            }
            
            const player = players[currentPlayer];
            const oldPosition = player.position;
            player.position = (player.position + total) % 40;
            
            if (player.position < oldPosition) {
                if (debugLogging) {
                    console.log(`[PASS GO] Turn ${turnCount}: ${player.name} passed GO. Before: $${player.money}`);
                }
                player.money += 150;
                if (debugLogging) {
                    console.log(`[PASS GO] After: ${player.name} has $${player.money}`);
                }
                if (!fastMode) {
                    showMessage(`${player.name} passed the Launch Pad! Collected $150.`);
                }
            }
            
            if (!fastMode) {
                updatePlayerPositions();
                updatePlayersInfo();
            }
            
            const landingDelay = fastMode ? 0 : 500;
            const turnDelay = fastMode ? 0 : 1500;
            
            setTimeout(() => {
                handleLanding();
                
                if (player.isAI) {
                    setTimeout(() => {
                        endTurn();
                        // Continue with next player if they're also AI
                        playAITurnsUntilHuman();
                    }, turnDelay);
                }
            }, landingDelay);
        }

        function handleLanding() {
            const player = players[currentPlayer];
            const space = spaces[player.position];
            
            if (space.type === 'property' && !space.owner) {
                if (player.isAI) {
                    handleAIPropertyDecision(player.position);
                } else {
                    if (!fastMode) {
                        showPropertyModal(player.position);
                    }
                }
            } else if (space.type === 'property' && space.owner !== undefined && space.owner !== currentPlayer) {
                const rent = calculateRent(space, space.owner);
                
                if (debugLogging) {
                    console.log(`[RENT] Turn ${turnCount}: ${player.name} (P${currentPlayer}) landed on ${space.name} owned by ${players[space.owner].name} (P${space.owner}). Rent: $${rent}`);
                    console.log(`[RENT] Before: ${player.name} has $${player.money}, ${players[space.owner].name} has $${players[space.owner].money}`);
                }
                
                if (player.money < rent) {
                    const amountPaid = player.money;
                    const ownerName = players[space.owner].name; // Save before any changes
                    const ownerIndex = space.owner; // Save owner index
                    
                    players[space.owner].money += amountPaid;
                    players[space.owner].totalRentCollected += amountPaid;
                    player.money = 0;
                    gameStats.totalRentPaid += amountPaid;
                    
                    // Check if this is Player 1 going bankrupt
                    if (currentPlayer === 0 && player1BankruptTurn === -1) {
                        player1BankruptTurn = turnCount;
                        debugLogging = true;
                        debugTurnsRemaining = 30;
                        console.log('╔══════════════════════════════════════════════════════╗');
                        console.log('║  PLAYER 1 BANKRUPTCY DETECTED - LOGGING ACTIVATED    ║');
                        console.log('║  Logging next 30 turns to track money flow           ║');
                        console.log('╚══════════════════════════════════════════════════════╝');
                    }
                    
                    // Log BEFORE clearing properties array
                    const propertyNames = player.properties.map(p => spaces[p].name);
                    if (debugLogging) {
                        console.log(`[BANKRUPTCY] ${player.name} BANKRUPT! Paid only $${amountPaid} of $${rent}. Returning ${player.properties.length} properties to bank.`);
                        console.log(`[BANKRUPTCY] Properties being returned:`, propertyNames);
                    }
                    
                    // BANKRUPTCY: Return all properties to the bank
                    player.properties.forEach(propIndex => {
                        const prop = spaces[propIndex];
                        delete prop.owner;
                        prop.buildings = 0;
                    });
                    player.properties = [];
                    
                    if (debugLogging) {
                        console.log(`[RENT] After: ${player.name} has $${player.money}, ${ownerName} has $${players[ownerIndex].money}`);
                    }
                    
                    if (!fastMode) {
                        showMessage(`${player.name} is BANKRUPT! Could not pay $${rent} rent to ${ownerName}. All properties returned to bank.`);
                        updatePlayersInfo();
                    }
                } else {
                    player.money -= rent;
                    players[space.owner].money += rent;
                    players[space.owner].totalRentCollected += rent;
                    gameStats.totalRentPaid += rent;
                    
                    if (debugLogging) {
                        console.log(`[RENT] After: ${player.name} has $${player.money}, ${players[space.owner].name} has $${players[space.owner].money}`);
                    }
                    
                    if (!fastMode) {
                        const monopolyText = hasMonopoly(space.owner, space.color) ? ' (MONOPOLY!)' : '';
                        showMessage(`${player.name} paid $${rent} rent to ${players[space.owner].name}${monopolyText}`);
                        updatePlayersInfo();
                    }
                }
            } else if (space.type === 'tax') {
                const tax = 200;
                
                if (debugLogging) {
                    console.log(`[TAX] Turn ${turnCount}: ${player.name} landed on tax space. Tax: $${tax}, Money: $${player.money}`);
                }
                
                if (player.money < tax) {
                    const amountPaid = player.money;
                    player.money = 0;
                    gameStats.totalTaxesPaid += amountPaid;
                    
                    // Check if this is Player 1 going bankrupt
                    if (currentPlayer === 0 && player1BankruptTurn === -1) {
                        player1BankruptTurn = turnCount;
                        debugLogging = true;
                        debugTurnsRemaining = 30;
                        console.log('╔══════════════════════════════════════════════════════╗');
                        console.log('║  PLAYER 1 BANKRUPTCY DETECTED - LOGGING ACTIVATED    ║');
                        console.log('║  Logging next 30 turns to track money flow           ║');
                        console.log('╚══════════════════════════════════════════════════════╝');
                    }
                    
                    if (debugLogging) {
                        console.log(`[BANKRUPTCY] ${player.name} BANKRUPT from tax! Returning ${player.properties.length} properties to bank.`);
                    }
                    
                    // BANKRUPTCY: Return all properties to the bank
                    player.properties.forEach(propIndex => {
                        const prop = spaces[propIndex];
                        delete prop.owner;
                        prop.buildings = 0;
                    });
                    player.properties = [];
                    
                    if (!fastMode) {
                        showMessage(`${player.name} is BANKRUPT! Could not pay $${tax} tax at ${space.name}. All properties returned to bank.`);
                        updatePlayersInfo();
                    }
                } else {
                    player.money -= tax;
                    gameStats.totalTaxesPaid += tax;
                    
                    if (!fastMode) {
                        showMessage(`${player.name} paid $${tax} in ${space.name}!`);
                        updatePlayersInfo();
                    }
                }
            } else if (space.type === 'event' || space.type === 'chance') {
                handleRandomEvent();
            } else {
                if (!fastMode) {
                    showMessage(`${player.name} landed on ${space.name}.`);
                }
            }
        }

        function handleAIPropertyDecision(position) {
            const player = players[currentPlayer];
            const space = spaces[position];
            
            // Safety check: property must not be owned
            if (space.owner !== undefined) {
                console.error('[BUG] AI tried to buy already-owned property:', space.name, 'owned by', space.owner);
                return;
            }
            
            if (player.money < space.price) {
                if (!fastMode) {
                    showMessage(`${player.name} cannot afford ${space.name}.`);
                }
                return;
            }
            
            // Always Spend strategy
            if (player.alwaysSpend) {
                if (player.money - space.price >= 400) { // Increased from 300 to 400
                    buyProperty(position);
                    if (!fastMode) {
                        showMessage(`${player.name} (Always Spend) purchased ${space.name} for $${space.price}!`);
                    }
                } else {
                    if (!fastMode) {
                        showMessage(`${player.name} (Always Spend) keeping cash reserve.`);
                    }
                }
                return;
            }
            
            // AI weight-based decision
            const factors = calculatePurchaseFactors(player, space, position);
            const weights = player.aiWeights;
            const weightedSum = 
                factors.cashOnHandForBuying * weights.cashOnHandForBuying +
                factors.propertyPrice * weights.propertyPrice +
                factors.rentValue * weights.rentValue +
                factors.colorGroupOwned * weights.colorGroupOwned +
                factors.colorGroupAvailable * weights.colorGroupAvailable;
            
            if (weightedSum > decisionThreshold) {
                buyProperty(position);
                if (!fastMode) {
                    showMessage(`${player.name} (AI) purchased ${space.name} for $${space.price}!`);
                }
            } else {
                if (!fastMode) {
                    showMessage(`${player.name} (AI) decided not to buy ${space.name}.`);
                }
            }
        }

        function calculatePurchaseFactors(player, space, position) {
            const cashOnHandForBuying = Math.min(player.money / 2000, 1);
            const propertyPrice = 1 - (space.price / 400);
            const rentValue = (space.price * 0.15) / 60;
            const colorGroupInfo = analyzeColorGroup(player, space.color);
            const colorGroupOwned = colorGroupInfo.owned / colorGroupInfo.total;
            const colorGroupAvailable = colorGroupInfo.available / colorGroupInfo.total;
            
            return {
                cashOnHandForBuying,
                propertyPrice,
                rentValue,
                colorGroupOwned,
                colorGroupAvailable
            };
        }

        function analyzeColorGroup(player, color) {
            if (!color) return { owned: 0, available: 0, total: 0 };
            
            const colorGroup = spaces.filter(s => s.color === color);
            const total = colorGroup.length;
            
            let owned = 0;
            let available = 0;
            
            colorGroup.forEach(space => {
                const spaceIndex = spaces.indexOf(space);
                if (player.properties.includes(spaceIndex)) {
                    owned++;
                }
                if (!space.owner) {
                    available++;
                }
            });
            
            return { owned, available, total };
        }

        function hasMonopoly(playerIndex, color) {
            if (!color) return false;
            const colorGroup = spaces.filter(s => s.color === color);
            return colorGroup.every(space => space.owner === playerIndex);
        }

        function calculateRent(space, ownerIndex) {
            let baseRent = Math.floor(space.price * 0.06); // Reduced from 0.10 to 0.06
            
            if (hasMonopoly(ownerIndex, space.color)) {
                baseRent *= 2;
            }
            
            if (space.buildings > 0) {
                const buildingMultipliers = [1, 5, 15, 45, 80, 120];
                baseRent *= buildingMultipliers[space.buildings];
            }
            
            return baseRent;
        }

        function getBuildingCost(space) {
            return Math.floor(space.price * 1.5); // 150% of property price
        }

        function calculateBuildingFactors(player, propertyIndex) {
            const space = spaces[propertyIndex];
            const buildCost = getBuildingCost(space);
            
            const cashOnHandForBuilding = Math.min(player.money / (buildCost * 2), 1);
            
            const currentRent = calculateRent(space, currentPlayer);
            const tempBuildings = space.buildings;
            space.buildings = Math.min(5, space.buildings + 1);
            const newRent = calculateRent(space, currentPlayer);
            space.buildings = tempBuildings;
            
            const rentMultiplier = currentRent > 0 ? (newRent - currentRent) / currentRent : 0;
            const buildingRentWeight = Math.min(rentMultiplier / 5, 1);
            const buildingCostWeight = 1 - (buildCost / 200);
            
            return {
                cashOnHandForBuilding,
                buildingRentWeight,
                buildingCostWeight
            };
        }

        // CORRECTED: Building rules - must land on monopoly property and build evenly
        function considerBuilding(playerIndex) {
            if (isPaused) return;
            
            const player = players[playerIndex];
            
            // For human players, show building modal
            if (!player.isAI) {
                if (!fastMode) {
                    showBuildingModal(playerIndex);
                }
                return;
            }
            
            const currentSpace = spaces[player.position];
            
            // Rule 1: Can only build if on a property you own
            if (currentSpace.type !== 'property' || currentSpace.owner !== playerIndex) {
                return;
            }
            
            // Rule 2: Must have monopoly on this color
            if (!hasMonopoly(playerIndex, currentSpace.color)) {
                return;
            }
            
            // Get all properties in this color group
            const colorGroup = player.properties
                .filter(i => spaces[i].color === currentSpace.color)
                .map(i => spaces[i]);
            
            // Rule 3: Find minimum building count (must build evenly)
            const minBuildings = Math.min(...colorGroup.map(s => s.buildings));
            
            // Rule 4: Can only build on properties at minimum level
            const canBuildOn = colorGroup.filter(s => s.buildings === minBuildings);
            
            // Prefer current space if possible, otherwise cheapest
            let targetSpace = canBuildOn.find(s => s === currentSpace);
            if (!targetSpace) {
                targetSpace = canBuildOn.sort((a, b) => a.price - b.price)[0];
            }
            
            if (!targetSpace || targetSpace.buildings >= 5) return;
            
            const buildCost = getBuildingCost(targetSpace);
            if (player.money < buildCost) return;
            
            // Always Spend strategy
            if (player.alwaysSpend) {
                if (player.money - buildCost >= 400) { // Increased from 300 to 400
                    player.money -= buildCost;
                    targetSpace.buildings++;
                    
                    const buildingName = targetSpace.buildings === 5 ? 'Starbase' : `Station ${targetSpace.buildings}`;
                    
                    if (!fastMode) {
                        showMessage(`${player.name} (Always Spend) built ${buildingName} on ${targetSpace.name} for $${buildCost}!`);
                        updatePlayersInfo();
                    }
                }
                return;
            }
            
            // AI weight-based decision
            const targetIndex = spaces.indexOf(targetSpace);
            const factors = calculateBuildingFactors(player, targetIndex);
            const weights = player.aiWeights;
            const weightedSum =
                factors.cashOnHandForBuilding * weights.cashOnHandForBuilding +
                factors.buildingRentWeight * weights.buildingRentWeight +
                factors.buildingCostWeight * weights.buildingCostWeight;
            
            if (weightedSum > decisionThreshold) {
                if (debugLogging) {
                    console.log(`[BUILDING] Turn ${turnCount}: ${player.name} building on ${targetSpace.name} for $${buildCost}. Before: $${player.money}`);
                }
                player.money -= buildCost;
                targetSpace.buildings++;
                if (debugLogging) {
                    console.log(`[BUILDING] After: ${player.name} has $${player.money}. ${targetSpace.name} now has ${targetSpace.buildings} buildings`);
                }
                
                const buildingName = targetSpace.buildings === 5 ? 'Starbase' : `Station ${targetSpace.buildings}`;
                
                if (!fastMode) {
                    showMessage(`${player.name} (AI) built ${buildingName} on ${targetSpace.name} for $${buildCost}!`);
                    updatePlayersInfo();
                }
            }
        }

        function handleRandomEvent() {
            const events = [
                { message: "Found space debris! Collect $50.", money: 50 },
                { message: "Solar storm! Pay $50 for repairs.", money: -50 },
                { message: "Successful mining operation! Collect $100.", money: 100 },
                { message: "Meteor damage! Pay $75.", money: -75 },
                { message: "Discovery bonus! Collect $150.", money: 150 }
            ];
            
            const event = events[Math.floor(Math.random() * events.length)];
            const player = players[currentPlayer];
            
            if (event.money < 0 && player.money + event.money < 0) {
                player.money = 0;
                
                // Check if this is Player 1 going bankrupt
                if (currentPlayer === 0 && player1BankruptTurn === -1) {
                    player1BankruptTurn = turnCount;
                    debugLogging = true;
                    debugTurnsRemaining = 30;
                    console.log('╔══════════════════════════════════════════════════════╗');
                    console.log('║  PLAYER 1 BANKRUPTCY DETECTED - LOGGING ACTIVATED    ║');
                    console.log('║  Logging next 30 turns to track money flow           ║');
                    console.log('╚══════════════════════════════════════════════════════╝');
                }
                
                // BANKRUPTCY: Return all properties to the bank
                player.properties.forEach(propIndex => {
                    const prop = spaces[propIndex];
                    delete prop.owner;
                    prop.buildings = 0;
                });
                player.properties = [];
                
                if (!fastMode) {
                    showMessage(`${event.message} ${player.name} is BANKRUPT! All properties returned to bank.`);
                    updatePlayersInfo();
                }
            } else {
                player.money += event.money;
                if (!fastMode) {
                    showMessage(event.message);
                    updatePlayersInfo();
                }
            }
        }

        function showPropertyModal(position) {
            const space = spaces[position];
            const modal = document.getElementById('propertyModal');
            const overlay = document.getElementById('modalOverlay');
            
            const baseRent = Math.floor(space.price * 0.06); // Updated to 6%
            const monopolyRent = baseRent * 2;
            const buildCost = getBuildingCost(space);
            
            document.getElementById('modalTitle').textContent = space.name;
            document.getElementById('modalColorStrip').style.background = space.color;
            
            let detailsHTML = `
                <div><strong>Price:</strong> $${space.price}</div>
                <div><strong>Base Rent:</strong> $${baseRent}</div>
                <div><strong>Monopoly Rent:</strong> $${monopolyRent} (2x)</div>
                <div><strong>Building Cost:</strong> $${buildCost} (150% of price)</div>
                <div style="margin-top: 10px; font-size: 0.9em; color: #a0aec0;">
                    With Buildings:<br>
                    1 Station: $${baseRent * 5} | 2: $${baseRent * 15} | 3: $${baseRent * 45}<br>
                    4 Stations: $${baseRent * 80} | Starbase: $${baseRent * 120}
                </div>`;
            
            if (space.buildings > 0) {
                const buildingName = space.buildings === 5 ? 'Starbase' : `${space.buildings} Station${space.buildings > 1 ? 's' : ''}`;
                detailsHTML += `<div style="margin-top: 10px; color: #ffd700;"><strong>Current:</strong> ${buildingName}</div>`;
            }
            
            document.getElementById('modalDetails').innerHTML = detailsHTML;
            
            const buyButton = document.getElementById('buyButton');
            if (players[currentPlayer].money >= space.price) {
                buyButton.disabled = false;
                buyButton.onclick = () => {
                    buyButton.disabled = true; // Prevent double-click
                    buyProperty(position);
                };
            } else {
                buyButton.disabled = true;
            }
            
            modal.style.display = 'block';
            overlay.style.display = 'block';
        }

        function closePropertyModal() {
            document.getElementById('propertyModal').style.display = 'none';
            document.getElementById('modalOverlay').style.display = 'none';
        }
        
        function showBuildingModal(playerIndex) {
            const player = players[playerIndex];
            const currentSpace = spaces[player.position];
            
            // Find all buildable monopolies
            const buildableMonopolies = [];
            
            for (const propIndex of player.properties) {
                const space = spaces[propIndex];
                if (space.type === 'property' && hasMonopoly(playerIndex, space.color)) {
                    const colorGroup = player.properties
                        .filter(i => spaces[i].color === space.color)
                        .map(i => spaces[i]);
                    
                    const minBuildings = Math.min(...colorGroup.map(s => s.buildings));
                    const canBuildOn = colorGroup.filter(s => s.buildings === minBuildings && s.buildings < 5);
                    
                    if (canBuildOn.length > 0) {
                        const cheapest = canBuildOn.sort((a, b) => a.price - b.price)[0];
                        const buildCost = getBuildingCost(cheapest);
                        
                        if (player.money >= buildCost) {
                            buildableMonopolies.push({
                                space: cheapest,
                                index: spaces.indexOf(cheapest),
                                cost: buildCost,
                                color: space.color,
                                groupSize: colorGroup.length
                            });
                        }
                    }
                }
            }
            
            if (buildableMonopolies.length === 0) {
                // No building opportunities - just end turn
                actuallyEndTurn();
                return;
            }
            
            const modal = document.getElementById('buildingModal');
            const overlay = document.getElementById('modalOverlay');
            
            let detailsHTML = `<div style="margin-bottom: 15px;">You have ${buildableMonopolies.length} monopol${buildableMonopolies.length > 1 ? 'ies' : 'y'} where you can build!</div>`;
            
            buildableMonopolies.forEach(mono => {
                const space = mono.space;
                const baseRent = Math.floor(space.price * 0.06);
                const currentRent = calculateRent(space, playerIndex);
                const newRent = space.buildings === 4 ? baseRent * 120 : baseRent * [5, 15, 45, 80][space.buildings];
                
                detailsHTML += `
                    <div style="margin: 15px 0; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 8px; border-left: 4px solid ${space.color};">
                        <div style="font-weight: bold; margin-bottom: 8px;">${space.name}</div>
                        <div style="font-size: 0.9em;">
                            <div>Current: ${space.buildings === 0 ? 'No buildings' : (space.buildings === 5 ? 'Starbase' : `${space.buildings} Station${space.buildings > 1 ? 's' : ''}`)}</div>
                            <div>Current Rent: $${currentRent}</div>
                            <div style="color: #48bb78;">After Building: $${newRent} rent</div>
                            <div style="margin-top: 5px;"><strong>Cost: $${mono.cost}</strong></div>
                        </div>
                        <button onclick="buildOnProperty(${mono.index})" 
                                style="margin-top: 10px; padding: 8px 15px; background: #48bb78; color: white; border: none; border-radius: 5px; cursor: pointer;">
                            Build Here ($${mono.cost})
                        </button>
                    </div>
                `;
            });
            
            detailsHTML += `<div style="margin-top: 15px; font-size: 0.85em; color: #a0aec0;">
                Building Rule: You must build evenly across all properties in a color group.
            </div>`;
            
            document.getElementById('buildingDetails').innerHTML = detailsHTML;
            
            const skipButton = document.getElementById('skipBuildButton');
            skipButton.onclick = actuallyEndTurn;
            
            modal.style.display = 'block';
            overlay.style.display = 'block';
        }
        
        function closeBuildingModal() {
            document.getElementById('buildingModal').style.display = 'none';
            document.getElementById('modalOverlay').style.display = 'none';
        }
        
        function showPlayerDetails(playerIndex) {
            const player = players[playerIndex];
            const modal = document.getElementById('playerDetailsModal');
            const overlay = document.getElementById('modalOverlay');
            
            // Map hex colors to readable names
            const colorNames = {
                '#8B4513': 'Brown',
                '#3182CE': 'Light Blue',
                '#D53F8C': 'Pink',
                '#F56565': 'Red',
                '#F6E05E': 'Yellow',
                '#48BB78': 'Green',
                '#4299E1': 'Blue',
                '#9F7AEA': 'Purple'
            };
            
            document.getElementById('playerDetailsTitle').textContent = player.name;
            
            let html = `
                <div style="margin-bottom: 20px;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                        <div style="padding: 10px; background: rgba(255,255,255,0.05); border-radius: 5px;">
                            <div style="font-size: 0.9em; color: #a0aec0;">Cash</div>
                            <div style="font-size: 1.3em; font-weight: bold; color: ${player.money > 0 ? '#48bb78' : '#fc8181'};">$${player.money.toLocaleString()}</div>
                        </div>
                        <div style="padding: 10px; background: rgba(255,255,255,0.05); border-radius: 5px;">
                            <div style="font-size: 0.9em; color: #a0aec0;">Properties</div>
                            <div style="font-size: 1.3em; font-weight: bold;">${player.properties.length}</div>
                        </div>
                    </div>
                    <div style="padding: 10px; background: rgba(255,255,255,0.05); border-radius: 5px; margin-bottom: 15px;">
                        <div style="font-size: 0.9em; color: #a0aec0;">Total Rent Collected This Game</div>
                        <div style="font-size: 1.3em; font-weight: bold; color: #667eea;">$${player.totalRentCollected.toLocaleString()}</div>
                    </div>
                </div>
            `;
            
            if (player.properties.length === 0) {
                html += `<div style="padding: 20px; text-align: center; color: #a0aec0;">No properties owned</div>`;
            } else {
                // Group properties by color
                const colorGroups = {};
                player.properties.forEach(propIndex => {
                    const space = spaces[propIndex];
                    if (space.type === 'property') {
                        if (!colorGroups[space.color]) {
                            colorGroups[space.color] = [];
                        }
                        colorGroups[space.color].push(space);
                    }
                });
                
                // Check for monopolies
                const monopolies = [];
                for (const color in colorGroups) {
                    if (hasMonopoly(playerIndex, color)) {
                        monopolies.push(color);
                    }
                }
                
                if (monopolies.length > 0) {
                    html += `<div style="padding: 10px; background: rgba(255, 215, 0, 0.1); border-radius: 5px; margin-bottom: 15px; border: 1px solid rgba(255, 215, 0, 0.3);">
                        <strong style="color: #ffd700;">🏆 Monopolies (${monopolies.length})</strong>
                    </div>`;
                }
                
                html += `<h3 style="margin-top: 20px; margin-bottom: 10px; font-size: 1.1em;">Properties:</h3>`;
                
                // Display properties grouped by color
                for (const color in colorGroups) {
                    const props = colorGroups[color];
                    const isMonopoly = monopolies.includes(color);
                    
                    // Get readable color name
                    const colorName = colorNames[color] || 'Unknown';
                    
                    html += `
                        <div style="margin-bottom: 15px; padding: 12px; background: rgba(255,255,255,0.05); border-radius: 8px; border-left: 4px solid ${color};">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <strong style="color: ${color};">${colorName.toUpperCase()} (${props.length} propert${props.length > 1 ? 'ies' : 'y'})</strong>
                                ${isMonopoly ? '<span style="color: #ffd700; font-size: 0.9em;">⭐ MONOPOLY</span>' : ''}
                            </div>
                    `;
                    
                    props.forEach(space => {
                        const rent = calculateRent(space, playerIndex);
                        const buildingText = space.buildings === 0 ? '' : 
                            (space.buildings === 5 ? ' 🏢 Starbase' : ` 🏗️ ${space.buildings} Station${space.buildings > 1 ? 's' : ''}`);
                        
                        html += `
                            <div style="padding: 8px; margin: 5px 0; background: rgba(0,0,0,0.2); border-radius: 5px;">
                                <div style="display: flex; justify-content: space-between;">
                                    <span>${space.name}${buildingText}</span>
                                    <span style="color: #48bb78; font-weight: bold;">$${rent} rent</span>
                                </div>
                                <div style="font-size: 0.85em; color: #a0aec0;">
                                    Value: $${space.price}
                                </div>
                            </div>
                        `;
                    });
                    
                    html += `</div>`;
                }
                
                // Calculate total property value and potential income
                let totalValue = 0;
                let totalPotentialRent = 0;
                player.properties.forEach(propIndex => {
                    const space = spaces[propIndex];
                    if (space.type === 'property') {
                        totalValue += space.price;
                        totalPotentialRent += calculateRent(space, playerIndex);
                    }
                });
                
                html += `
                    <div style="margin-top: 20px; padding: 15px; background: rgba(102, 126, 234, 0.1); border-radius: 8px; border: 1px solid rgba(102, 126, 234, 0.3);">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                            <div>
                                <div style="font-size: 0.9em; color: #a0aec0;">Portfolio Value</div>
                                <div style="font-size: 1.2em; font-weight: bold;">$${totalValue.toLocaleString()}</div>
                            </div>
                            <div>
                                <div style="font-size: 0.9em; color: #a0aec0;">Potential Rent/Turn</div>
                                <div style="font-size: 1.2em; font-weight: bold; color: #48bb78;">$${totalPotentialRent.toLocaleString()}</div>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            document.getElementById('playerDetailsContent').innerHTML = html;
            modal.style.display = 'block';
            overlay.style.display = 'block';
        }
        
        function closePlayerDetails() {
            document.getElementById('playerDetailsModal').style.display = 'none';
            document.getElementById('modalOverlay').style.display = 'none';
        }
        
        function buildOnProperty(propertyIndex) {
            const player = players[currentPlayer];
            const space = spaces[propertyIndex];
            const buildCost = getBuildingCost(space);
            
            if (player.money < buildCost) {
                alert('Not enough money!');
                return;
            }
            
            player.money -= buildCost;
            space.buildings++;
            
            const buildingName = space.buildings === 5 ? 'Starbase' : `Station ${space.buildings}`;
            showMessage(`${player.name} built ${buildingName} on ${space.name} for $${buildCost}!`);
            updateBoard();
            updatePlayersInfo();
            
            // Close and re-show to update options
            closeBuildingModal();
            setTimeout(() => showBuildingModal(currentPlayer), 100);
        }

        function buyProperty(position) {
            const player = players[currentPlayer];
            const space = spaces[position];
            
            // Check if property is already owned
            if (space.owner !== undefined) {
                console.error('[BUG] Attempted to buy already-owned property:', space.name, 'owned by player', space.owner);
                closePropertyModal();
                showMessage(`${space.name} is already owned!`);
                return;
            }
            
            // Check if player can afford it
            if (player.money < space.price) {
                console.error('[BUG] Player cannot afford property:', player.money, '<', space.price);
                closePropertyModal();
                showMessage(`You cannot afford ${space.name}!`);
                return;
            }
            
            if (debugLogging) {
                console.log(`[PURCHASE] Turn ${turnCount}: ${player.name} buying ${space.name} for $${space.price}. Before: $${player.money}`);
            }
            
            player.money -= space.price;
            space.owner = currentPlayer;
            
            // Add to properties array only if not already there (safety check)
            if (!player.properties.includes(position)) {
                player.properties.push(position);
            } else {
                console.error('[BUG] Property', position, 'already in player properties array');
            }
            
            gameStats.propertiesSold++;
            
            if (debugLogging) {
                console.log(`[PURCHASE] After: ${player.name} has $${player.money}, owns ${player.properties.length} properties`);
            }
            
            if (!fastMode) {
                showMessage(`${player.name} purchased ${space.name} for $${space.price}!`);
                updatePlayersInfo();
            }
            closePropertyModal();
            
            // Check if human player now has building opportunities
            if (!player.isAI && !fastMode) {
                showBuildingModal(currentPlayer);
            }
        }

        function showPropertyInfo(position) {
            const space = spaces[position];
            if (space.type === 'property' || space.type === 'transport' || space.type === 'utility') {
                let info = `<strong>${space.name}</strong><br>`;
                if (space.price > 0) {
                    info += `Price: $${space.price}<br>`;
                    if (space.owner !== undefined) {
                        const rent = calculateRent(space, space.owner);
                        const monopolyStatus = hasMonopoly(space.owner, space.color) ? ' [MONOPOLY]' : '';
                        info += `Rent: $${rent}${monopolyStatus}<br>`;
                        
                        if (space.buildings > 0) {
                            const buildingName = space.buildings === 5 ? 'Starbase' : `${space.buildings} Station${space.buildings > 1 ? 's' : ''}`;
                            info += `Buildings: ${buildingName}<br>`;
                        }
                    } else {
                        const baseRent = Math.floor(space.price * 0.06); // Updated to 6%
                        info += `Base Rent: $${baseRent} (Monopoly: $${baseRent * 2})<br>`;
                        info += `Build Cost: $${getBuildingCost(space)}<br>`;
                    }
                }
                if (space.owner !== undefined) {
                    info += `Owner: ${players[space.owner].name}`;
                } else if (space.price > 0) {
                    info += `Status: Available`;
                }
                showMessage(info);
            }
        }

        function showMessage(msg) {
            document.getElementById('messageBox').innerHTML = msg;
        }
        
        function actuallyEndTurn() {
            console.log('[DEBUG] actuallyEndTurn called');
            closeBuildingModal();
            endTurn();
            
            // Continue playing AI turns until we reach a human player
            playAITurnsUntilHuman();
        }
        
        function playAITurnsUntilHuman() {
            console.log('[DEBUG] playAITurnsUntilHuman - current player:', currentPlayer, 'isAI:', players[currentPlayer].isAI);
            
            // Check if all players are AI
            const allAI = players.every(p => p.isAI);
            
            // Check if current player is AI and game is not over
            if (players[currentPlayer].isAI && !checkWinner()) {
                // Roll for the AI player after a short delay
                console.log('[DEBUG] Scheduling AI roll for player', currentPlayer);
                setTimeout(() => {
                    if (!hasRolled) {
                        rollDice();
                    }
                }, 500);
            } else if (!players[currentPlayer].isAI && !allAI) {
                // Human player's turn - enable roll button (only if not all AI)
                console.log('[DEBUG] Human player turn, enabling roll button');
                document.getElementById('rollButton').disabled = false;
                showMessage(`${players[currentPlayer].name}'s turn!`);
            }
        }

        function endTurn() {
            // Only AI players do building during endTurn - humans already had their chance
            if (players[currentPlayer].isAI && players[currentPlayer].money > 0) {
                considerBuilding(currentPlayer);
            }
            
            const previousPlayer = currentPlayer;
            currentPlayer = (currentPlayer + 1) % players.length;
            
            // Increment turn counter when we wrap around (complete a round)
            if (currentPlayer < previousPlayer) {
                turnCount++;
            }
            
            let skipped = 0;
            while (players[currentPlayer].money <= 0 && skipped < players.length) {
                const beforeSkip = currentPlayer;
                currentPlayer = (currentPlayer + 1) % players.length;
                
                // Also check for wrap-around during skipping
                if (currentPlayer < beforeSkip) {
                    turnCount++;
                }
                
                skipped++;
            }
            
            // Decrement debug turns counter
            if (debugLogging) {
                debugTurnsRemaining--;
                if (debugTurnsRemaining <= 0) {
                    console.log('╔══════════════════════════════════════════════════════╗');
                    console.log('║  DEBUG LOGGING COMPLETE - FINAL SNAPSHOT             ║');
                    console.log('╚══════════════════════════════════════════════════════╝');
                    players.forEach((p, i) => {
                        console.log(`P${i} ${p.name}: $${p.money}, Props: ${p.properties.length}, RentEarned: $${p.totalRentCollected}`);
                    });
                    debugLogging = false;
                }
            }
            
            // Log start of new turn
            if (skipped < players.length && debugLogging) {
                const p = players[currentPlayer];
                console.log(`--- Turn ${turnCount} START: ${p.name} has $${p.money}, ${p.properties.length} props ---`);
            }
            
            if (skipped >= players.length) {
                if (debugLogging) {
                    console.log('=== ALL PLAYERS BANKRUPT - FINDING WINNER ===');
                    console.log('Turn:', turnCount);
                    players.forEach((p, i) => {
                        console.log(`P${i} ${p.name}: $${p.money}, Props: ${p.properties.length}, RentEarned: $${p.totalRentCollected}`);
                    });
                }
                
                let richest = players[0];
                players.forEach(p => {
                    if (p.money > richest.money) {
                        richest = p;
                    }
                });
                
                if (fastMode) {
                    shouldResumeFastMode = true;
                    toggleFastMode();
                }
                
                handleWinner(richest);
                showMessage(`${richest.name} wins with $${richest.money}! All others bankrupt!`);
                updatePlayersInfo();
                updateGameStats();
                
                if (evolutionMode && autoContinue && richest.isAI) {
                    if (evolutionHistory.length >= maxGenerations && !isInEvaluationPhase) {
                        if (evaluationGames > 0) {
                            isInEvaluationPhase = true;
                            evaluationResults = [];
                            showMessage(`Training Complete! Starting ${evaluationGames} evaluation games...`);
                            setTimeout(() => resetGame(), 3000);
                        } else {
                            shouldResumeFastMode = false;
                            showMessage(`Evolution complete after ${evolutionHistory.length} generations!`);
                            document.getElementById('rollButton').disabled = true;
                        }
                    } else if (isInEvaluationPhase && evaluationResults.length >= evaluationGames) {
                        shouldResumeFastMode = false;
                        const wins = evaluationResults.filter(r => r.championWon).length;
                        const winRate = ((wins / evaluationGames) * 100).toFixed(1);
                        showMessage(`Evaluation Complete! Champion won ${wins}/${evaluationGames} games (${winRate}% win rate)`);
                        document.getElementById('rollButton').disabled = true;
                    } else {
                        setTimeout(() => resetGame(), 2000);
                    }
                } else {
                    document.getElementById('rollButton').disabled = true;
                    shouldResumeFastMode = false;
                }
                
                return;
            }
            
            if (isInEvaluationPhase && players[0].money <= 0) {
                const winner = checkWinner();
                if (winner) {
                    if (fastMode) {
                        shouldResumeFastMode = true;
                        toggleFastMode();
                    }
                    
                    handleWinner(winner);
                    showMessage(`${winner.name} wins! Champion eliminated!`);
                    updatePlayersInfo();
                    updateGameStats();
                    
                    if (evolutionMode && autoContinue) {
                        if (evaluationResults.length >= evaluationGames) {
                            shouldResumeFastMode = false;
                            const wins = evaluationResults.filter(r => r.championWon).length;
                            const winRate = ((wins / evaluationGames) * 100).toFixed(1);
                            showMessage(`Evaluation Complete! Champion won ${wins}/${evaluationGames} games (${winRate}% win rate)`);
                            document.getElementById('rollButton').disabled = true;
                        } else {
                            setTimeout(() => resetGame(), 2000);
                        }
                    } else {
                        document.getElementById('rollButton').disabled = true;
                        shouldResumeFastMode = false;
                    }
                    
                    return;
                }
            }
            
            hasRolled = false;
            
            const winner = checkWinner();
            if (winner) {
                if (fastMode) {
                    shouldResumeFastMode = true;
                    toggleFastMode();
                }
                
                handleWinner(winner);
                showMessage(`${winner.name} wins with $${winner.money}! Game Over!`);
                updatePlayersInfo();
                updateGameStats();
                
                if (evolutionMode && autoContinue && winner.isAI) {
                    if (evolutionHistory.length >= maxGenerations && !isInEvaluationPhase) {
                        if (evaluationGames > 0) {
                            isInEvaluationPhase = true;
                            evaluationResults = [];
                            showMessage(`Training Complete! Starting ${evaluationGames} evaluation games...`);
                            setTimeout(() => resetGame(), 3000);
                        } else {
                            shouldResumeFastMode = false;
                            showMessage(`Evolution complete after ${evolutionHistory.length} generations!`);
                            document.getElementById('rollButton').disabled = true;
                        }
                    } else if (isInEvaluationPhase && evaluationResults.length >= evaluationGames) {
                        shouldResumeFastMode = false;
                        const wins = evaluationResults.filter(r => r.championWon).length;
                        const winRate = ((wins / evaluationGames) * 100).toFixed(1);
                        showMessage(`Evaluation Complete! Champion won ${wins}/${evaluationGames} games (${winRate}% win rate)`);
                        document.getElementById('rollButton').disabled = true;
                    } else {
                        setTimeout(() => resetGame(), 2000);
                    }
                } else {
                    document.getElementById('rollButton').disabled = true;
                    shouldResumeFastMode = false;
                }
                
                return;
            }
            
            if (!fastMode) {
                document.getElementById('die1').textContent = '?';
                document.getElementById('die2').textContent = '?';
                document.getElementById('endTurnButton').style.display = 'none';
                updatePlayersInfo();
                updateGameStats();
                showMessage(`${players[currentPlayer].name}'s turn! Roll the dice.`);
                
                if (!players[currentPlayer].isAI) {
                    document.getElementById('rollButton').disabled = false;
                } else {
                    document.getElementById('rollButton').disabled = true;
                }
            }
            
            if (players[currentPlayer].isAI || fastMode) {
                const delay = fastMode ? 0 : 800;
                setTimeout(() => {
                    if (!isPaused) {
                        rollDice();
                    }
                }, delay);
            }
        }

        function checkWinner() {
            if (isInEvaluationPhase && players[0].money <= 0) {
                let richest = players[1];
                for (let i = 2; i < players.length; i++) {
                    if (players[i].money > richest.money) {
                        richest = players[i];
                    }
                }
                return richest;
            }
            
            const activePlayers = players.filter(p => p.money > 0);
            
            if (activePlayers.length === 1) {
                return activePlayers[0];
            }
            
            if (turnCount >= maxTurns) {
                console.log(`[CHECK WINNER] Turn ${turnCount} >= maxTurns ${maxTurns}, finding richest player`);
                let richest = players[0];
                players.forEach(p => {
                    if (p.money > richest.money) {
                        richest = p;
                    }
                });
                return richest;
            }
            
            return null;
        }

        function handleWinner(winner) {
            const winnerIndex = players.indexOf(winner);
            
            if (isInEvaluationPhase) {
                const result = {
                    gameNumber: evaluationResults.length + 1,
                    championWon: winnerIndex === 0,
                    winnerName: winner.name,
                    finalMoney: winner.money,
                    turns: turnCount
                };
                evaluationResults.push(result);
            } else {
                // Update winner pool with all AI players
                if (evolutionMode) {
                    players.forEach((p, i) => {
                        if (p.isAI && !p.alwaysSpend && p.aiWeights) {
                            updateWinnerPool(p.aiWeights, i === winnerIndex);
                        }
                    });
                }
                
                const gameRecord = {
                    generation: evolutionHistory.length + 1,
                    winner: winner.name,
                    winnerIndex: winnerIndex,
                    finalMoney: winner.money,
                    properties: winner.properties.length,
                    monopolies: countMonopolies(winnerIndex),
                    turns: turnCount,
                    totalRentCollected: winner.totalRentCollected,
                    weights: (winner.isAI && !winner.alwaysSpend) ? cloneWeights(winner.aiWeights) : null,
                    winnerPoolSize: winnerPool.length,
                    playerStats: players.map((p, i) => ({
                        name: p.name,
                        money: p.money,
                        properties: p.properties.length,
                        monopolies: countMonopolies(i),
                        totalRentCollected: p.totalRentCollected,
                        isChampion: p.name.includes('Champion'),
                        isMutant: p.name.includes('Mutant'),
                        isOffspring: p.name.includes('Offspring'),
                        isWinner: p.name.includes('Winner'),
                        isRandom: p.name.includes('Random') && !p.alwaysSpend,
                        isAlwaysSpend: p.alwaysSpend
                    }))
                };
                
                evolutionHistory.push(gameRecord);
                
                if (evolutionMode && winner.isAI && !winner.alwaysSpend) {
                    championWeights = cloneWeights(winner.aiWeights);
                }
            }
            
            document.getElementById('viewHistoryButton').style.display = 
                evolutionHistory.length > 0 ? 'block' : 'none';
            document.getElementById('saveRunButton').style.display = 
                evolutionHistory.length > 0 ? 'block' : 'none';
            document.getElementById('newExperimentButton').style.display = 
                evolutionHistory.length > 0 ? 'block' : 'none';
            document.getElementById('viewComparisonButton').style.display = 
                experimentRuns.length >= 2 ? 'block' : 'none';
        }

        function countMonopolies(playerIndex) {
            const colors = new Set(players[playerIndex].properties.map(p => spaces[p].color).filter(c => c));
            let monopolies = 0;
            colors.forEach(color => {
                if (hasMonopoly(playerIndex, color)) {
                    monopolies++;
                }
            });
            return monopolies;
        }

        function updateGameStats() {
            document.getElementById('turnCounter').textContent = turnCount;
            
            let totalProperties = 0;
            players.forEach(p => totalProperties += p.properties.length);
            document.getElementById('propertiesOwned').textContent = totalProperties;
            
            document.getElementById('totalRent').textContent = gameStats.totalRentPaid;
        }

        document.getElementById('rollButton').addEventListener('click', rollDice);
        document.getElementById('endTurnButton').addEventListener('click', () => {
            // For human players, show building modal first (if applicable)
            if (!players[currentPlayer].isAI) {
                // Only show building modal if they have money
                if (players[currentPlayer].money > 0) {
                    showBuildingModal(currentPlayer);
                    // Building modal's skip button or actuallyEndTurn will handle the rest
                } else {
                    actuallyEndTurn();
                }
            } else {
                actuallyEndTurn();
            }
        });
        document.getElementById('closeButton').addEventListener('click', closePropertyModal);
        document.getElementById('closePlayerDetailsButton').addEventListener('click', closePlayerDetails);
        document.getElementById('modalOverlay').addEventListener('click', () => {
            closePropertyModal();
            closeSettings();
            closeHistory();
            closeBuildingModal();
            closePlayerDetails();
        });
        document.getElementById('settingsButton').addEventListener('click', showSettings);
        document.getElementById('closeSettingsButton').addEventListener('click', closeSettings);
        document.getElementById('fastModeButton').addEventListener('click', toggleFastMode);
        document.getElementById('pauseButton').addEventListener('click', togglePause);
        document.getElementById('resetButton').addEventListener('click', resetGame);
        
        let viewHistoryHandler = null;
        function attachViewHistoryListener() {
            const button = document.getElementById('viewHistoryButton');
            if (button && !viewHistoryHandler) {
                viewHistoryHandler = () => {
                    closeSettings();
                    setTimeout(() => showHistory(), 100);
                };
                button.addEventListener('click', viewHistoryHandler);
            }
        }
        attachViewHistoryListener();
        
        document.getElementById('closeHistoryButton').addEventListener('click', closeHistory);
        document.getElementById('downloadHistoryButton').addEventListener('click', downloadHistory);
        
        document.getElementById('saveRunButton').addEventListener('click', () => {
            const runName = prompt('Name this experimental run:', currentExperimentName || `Run ${experimentRuns.length + 1}`);
            if (!runName) return;
            
            const bestWinRate = winnerPool.length > 0 ? winnerPool[0].score : 0;
            const avgWinnerMoney = evolutionHistory.length > 0 ? 
                (evolutionHistory.reduce((sum, r) => sum + r.finalMoney, 0) / evolutionHistory.length) : 0;
            
            const run = {
                name: runName,
                timestamp: new Date().toISOString(),
                settings: {
                    matingRate,
                    matingMethod,
                    mutationRate,
                    numCompetitors,
                    maxTurns,
                    generations: maxGenerations
                },
                results: {
                    generations: evolutionHistory.length,
                    poolSize: winnerPool.length,
                    bestWinRate: bestWinRate,
                    avgWinnerMoney: avgWinnerMoney,
                    evaluationWinRate: evaluationResults.length > 0 ?
                        (evaluationResults.filter(r => r.winnerName.includes('Best')).length / evaluationResults.length) : 0
                },
                history: evolutionHistory.slice(),
                evaluation: evaluationResults.slice()
            };
            
            experimentRuns.push(run);
            currentExperimentName = runName;
            showMessage(`Run "${runName}" saved! Total runs: ${experimentRuns.length}`);
            
            document.getElementById('viewComparisonButton').style.display = 
                experimentRuns.length >= 2 ? 'block' : 'none';
            
            if (experimentRuns.length >= 2) {
                showComparisonSummary();
            }
        });
        
        document.getElementById('viewComparisonButton').addEventListener('click', () => {
            if (experimentRuns.length < 2) {
                alert('You need to save at least 2 experimental runs to compare them!');
                return;
            }
            showComparisonSummary();
        });
        
        document.getElementById('newExperimentButton').addEventListener('click', () => {
            if (evolutionHistory.length > 0 && !confirm('Start a new experiment? Current run will be lost unless you save it first.')) {
                return;
            }
            
            // Reset all evolution state
            evolutionHistory = [];
            evaluationResults = [];
            isInEvaluationPhase = false;
            championWeights = null;
            winnerPool = [];
            currentExperimentName = '';
            
            // Hide completed experiment buttons
            document.getElementById('viewHistoryButton').style.display = 'none';
            document.getElementById('saveRunButton').style.display = 'none';
            document.getElementById('newExperimentButton').style.display = 'none';
            document.getElementById('viewComparisonButton').style.display = experimentRuns.length >= 2 ? 'block' : 'none';
            
            // Reset generation display
            const genDisplay = document.getElementById('generationDisplay');
            genDisplay.style.display = 'block';
            genDisplay.textContent = 'Ready for new experiment';
            
            // Reset the game
            resetGame();
            
            // If in fast mode, turn it off
            if (fastMode) {
                toggleFastMode();
            }
            
            showMessage('New experiment ready! Configure settings and click Fast Mode to start.');
        });

        function showSettings() {
            const modal = document.getElementById('settingsModal');
            const overlay = document.getElementById('modalOverlay');
            const playerSettings = document.getElementById('playerSettings');
            
            playerSettings.innerHTML = '';
            
            players.forEach((player, index) => {
                const settingDiv = document.createElement('div');
                settingDiv.className = 'player-setting';
                
                let baseName = player.name.replace(' (AI)', '').replace(' (Champion)', '').replace(' (Mutant)', '').replace(' (Always Spend)', '');
                
                settingDiv.innerHTML = `
                    <label>
                        <div class="player-indicator" style="background: ${player.color}; width: 16px; height: 16px; border-radius: 50%; border: 2px solid white;"></div>
                        <span>${baseName}</span>
                    </label>
                    <label style="flex: 0;">
                        <input type="checkbox" id="ai-${index}" ${playerAISettings[index] ? 'checked' : ''}>
                        <span>AI Controlled</span>
                    </label>
                `;
                
                playerSettings.appendChild(settingDiv);
            });
            
            players.forEach((player, index) => {
                const checkbox = document.getElementById(`ai-${index}`);
                const newCheckbox = checkbox.cloneNode(true);
                checkbox.parentNode.replaceChild(newCheckbox, checkbox);
                
                newCheckbox.addEventListener('change', (e) => {
                    playerAISettings[index] = e.target.checked;
                    players[index].isAI = e.target.checked;
                    if (players[index].isAI && !players[index].aiWeights && !players[index].alwaysSpend) {
                        players[index].aiWeights = {
                            cashOnHandForBuying: (Math.random() - 0.5) * 2,
                            propertyPrice: (Math.random() - 0.5) * 2,
                            rentValue: (Math.random() - 0.5) * 2,
                            colorGroupOwned: (Math.random() - 0.5) * 2,
                            colorGroupAvailable: (Math.random() - 0.5) * 2,
                            cashOnHandForBuilding: (Math.random() - 0.5) * 2,
                            buildingRentWeight: (Math.random() - 0.5) * 2,
                            buildingCostWeight: (Math.random() - 0.5) * 2
                        };
                    }
                    updatePlayersInfo();
                });
            });
            
            const evolutionCheckbox = document.getElementById('evolutionModeCheckbox');
            const newEvolutionCheckbox = evolutionCheckbox.cloneNode(true);
            evolutionCheckbox.parentNode.replaceChild(newEvolutionCheckbox, evolutionCheckbox);
            newEvolutionCheckbox.checked = evolutionMode;
            newEvolutionCheckbox.addEventListener('change', (e) => {
                evolutionMode = e.target.checked;
                if (evolutionMode) {
                    showMessage('Evolution mode enabled! Winners will breed the next generation.');
                } else {
                    showMessage('Evolution mode disabled.');
                }
            });
            
            const autoContinueCheckbox = document.getElementById('autoContinueCheckbox');
            const newAutoContinueCheckbox = autoContinueCheckbox.cloneNode(true);
            autoContinueCheckbox.parentNode.replaceChild(newAutoContinueCheckbox, autoContinueCheckbox);
            newAutoContinueCheckbox.checked = autoContinue;
            newAutoContinueCheckbox.addEventListener('change', (e) => {
                autoContinue = e.target.checked;
            });
            
            document.getElementById('generationsToRun').value = maxGenerations;
            document.getElementById('evaluationGames').value = evaluationGames;
            document.getElementById('numMutants').value = numMutants;
            document.getElementById('mutationRate').value = mutationRate;
            document.getElementById('maxTurns').value = maxTurns;
            document.getElementById('numCompetitors').value = numCompetitors;
            document.getElementById('matingRate').value = matingRate;
            document.getElementById('matingMethod').value = matingMethod;
            
            document.getElementById('generationsToRun').addEventListener('change', (e) => {
                const val = parseInt(e.target.value);
                if (val >= 1 && val <= 1000) {
                    maxGenerations = val;
                }
            });
            
            document.getElementById('evaluationGames').addEventListener('change', (e) => {
                const val = parseInt(e.target.value);
                if (val >= 0 && val <= 100) {
                    evaluationGames = val;
                }
            });
            
            document.getElementById('numMutants').addEventListener('change', (e) => {
                const val = parseInt(e.target.value);
                if (val >= 1 && val <= 3) {
                    numMutants = val;
                }
            });
            
            document.getElementById('mutationRate').addEventListener('change', (e) => {
                const val = parseFloat(e.target.value);
                if (val >= 0.01 && val <= 1.0) {
                    mutationRate = val;
                }
            });
            
            document.getElementById('maxTurns').addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                if (val >= 50 && val <= 1000) {
                    maxTurns = val;
                    document.getElementById('maxTurnsDisplay').textContent = maxTurns;
                }
            });
            
            document.getElementById('maxTurns').addEventListener('change', (e) => {
                const val = parseInt(e.target.value);
                if (val >= 50 && val <= 1000) {
                    maxTurns = val;
                    document.getElementById('maxTurnsDisplay').textContent = maxTurns;
                }
            });
            
            document.getElementById('numCompetitors').addEventListener('change', (e) => {
                const val = parseInt(e.target.value);
                if (val >= 1 && val <= 3) {
                    numCompetitors = val;
                }
            });
            
            document.getElementById('matingRate').addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                if (val >= 0.0 && val <= 1.0) {
                    matingRate = val;
                }
            });
            
            document.getElementById('matingRate').addEventListener('change', (e) => {
                const val = parseFloat(e.target.value);
                if (val >= 0.0 && val <= 1.0) {
                    matingRate = val;
                }
            });
            
            document.getElementById('matingMethod').addEventListener('change', (e) => {
                matingMethod = e.target.value;
            });
            
            // Save champion weights
            document.getElementById('saveChampionButton').addEventListener('click', () => {
                if (!championWeights && winnerPool.length === 0) {
                    alert('No champion weights to save yet. Run evolution mode first!');
                    return;
                }
                
                const saveData = {
                    version: "2.0",
                    timestamp: new Date().toISOString(),
                    
                    // Best weights
                    championWeights: championWeights,
                    bestFromPool: winnerPool.length > 0 ? {
                        weights: winnerPool[0].weights,
                        wins: winnerPool[0].wins,
                        games: winnerPool[0].games,
                        winRate: winnerPool[0].score
                    } : null,
                    
                    // Winner pool
                    winnerPool: winnerPool.map(w => ({
                        wins: w.wins,
                        games: w.games,
                        winRate: w.score,
                        weights: w.weights
                    })),
                    
                    // Settings used
                    settings: {
                        generations: maxGenerations,
                        mutationRate: mutationRate,
                        numMutants: numMutants,
                        numCompetitors: numCompetitors,
                        maxTurns: maxTurns,
                        evaluationGames: evaluationGames,
                        matingRate: matingRate,
                        matingMethod: matingMethod
                    },
                    
                    // Full evolution history
                    evolutionHistory: evolutionHistory.map(record => ({
                        generation: record.generation,
                        winner: record.winner,
                        finalMoney: record.finalMoney,
                        turns: record.turns,
                        totalRentCollected: record.totalRentCollected,
                        winnerPoolSize: record.winnerPoolSize,
                        playerStats: record.playerStats
                    })),
                    
                    // Evaluation results
                    evaluationResults: evaluationResults.map(result => ({
                        gameNumber: result.gameNumber,
                        winner: result.winnerName,
                        finalMoney: result.finalMoney,
                        turns: result.turns
                    })),
                    
                    // Summary statistics
                    summary: {
                        totalGenerations: evolutionHistory.length,
                        poolSize: winnerPool.length,
                        evaluationGames: evaluationResults.length,
                        bestWinRate: winnerPool.length > 0 ? winnerPool[0].score : 0
                    }
                };
                
                const blob = new Blob([JSON.stringify(saveData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `cosmic-trader-champion-${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showMessage('Champion data saved with full history!');
            });
            
            // Load champion weights
            document.getElementById('loadChampionButton').addEventListener('click', () => {
                document.getElementById('loadChampionFile').click();
            });
            
            document.getElementById('loadChampionFile').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        
                        // Handle both old and new format
                        if (data.version === "2.0") {
                            // New format with full data
                            if (data.championWeights) {
                                championWeights = data.championWeights;
                            }
                            
                            // Restore winner pool
                            if (data.winnerPool && Array.isArray(data.winnerPool)) {
                                winnerPool = data.winnerPool.map(w => ({
                                    weights: w.weights,
                                    wins: w.wins,
                                    games: w.games,
                                    score: w.winRate
                                }));
                            }
                            
                            // Restore settings
                            if (data.settings) {
                                if (data.settings.mutationRate !== undefined) {
                                    mutationRate = data.settings.mutationRate;
                                    document.getElementById('mutationRate').value = mutationRate;
                                }
                                if (data.settings.numMutants !== undefined) {
                                    numMutants = data.settings.numMutants;
                                    document.getElementById('numMutants').value = numMutants;
                                }
                                if (data.settings.numCompetitors !== undefined) {
                                    numCompetitors = data.settings.numCompetitors;
                                    document.getElementById('numCompetitors').value = numCompetitors;
                                }
                                if (data.settings.maxTurns !== undefined) {
                                    maxTurns = data.settings.maxTurns;
                                    document.getElementById('maxTurns').value = maxTurns;
                                }
                                if (data.settings.matingRate !== undefined) {
                                    matingRate = data.settings.matingRate;
                                    document.getElementById('matingRate').value = matingRate;
                                }
                                if (data.settings.matingMethod !== undefined) {
                                    matingMethod = data.settings.matingMethod;
                                    document.getElementById('matingMethod').value = matingMethod;
                                }
                            }
                            
                            // Restore evolution history
                            if (data.evolutionHistory && Array.isArray(data.evolutionHistory)) {
                                evolutionHistory = data.evolutionHistory;
                            }
                            
                            // Restore evaluation results
                            if (data.evaluationResults && Array.isArray(data.evaluationResults)) {
                                evaluationResults = data.evaluationResults;
                            }
                            
                            const info = `Loaded champion from ${new Date(data.timestamp).toLocaleDateString()}\n` + 
                                         `Generations: ${data.summary.totalGenerations}\n` +
                                         `Winner Pool: ${data.summary.poolSize} AIs\n` +
                                         `Best Win Rate: ${(data.summary.bestWinRate * 100).toFixed(1)}%`;
                            showMessage('Champion loaded with full evolution history!');
                            alert('Champion data loaded successfully!\n\n' + info);
                            
                        } else {
                            // Old format - just weights
                            if (data.weights || data.championWeights) {
                                championWeights = data.weights || data.championWeights;
                            } else {
                                alert('Invalid champion file: missing weights');
                                return;
                            }
                            
                            // Optionally restore old format settings
                            if (data.mutationRate !== undefined) {
                                mutationRate = data.mutationRate;
                                document.getElementById('mutationRate').value = mutationRate;
                            }
                            if (data.numMutants !== undefined) {
                                numMutants = data.numMutants;
                                document.getElementById('numMutants').value = numMutants;
                            }
                            
                            const info = `Loaded champion from ${new Date(data.timestamp).toLocaleDateString()}` + 
                                         (data.generations ? ` (${data.generations} generations)` : '');
                            showMessage(info);
                            alert('Champion weights loaded successfully!\n\n' + info + '\n\nNote: Old format - no winner pool or history data.');
                        }
                        
                        document.getElementById('viewHistoryButton').style.display = 
                            evolutionHistory.length > 0 ? 'block' : 'none';
                        
                    } catch (err) {
                        alert('Error loading champion file: ' + err.message);
                    }
                };
                reader.readAsText(file);
                
                // Reset file input so same file can be loaded again
                e.target.value = '';
            });
            
            const historyButton = document.getElementById('viewHistoryButton');
            if (evolutionHistory.length > 0) {
                historyButton.style.display = 'block';
            } else {
                historyButton.style.display = 'none';
            }
            
            modal.style.display = 'block';
            overlay.style.display = 'block';
        }

        function closeSettings() {
            document.getElementById('settingsModal').style.display = 'none';
            document.getElementById('modalOverlay').style.display = 'none';
        }
        
        function applyPreset(presetName) {
            const presets = {
                sexual: {
                    name: "Sexual Reproduction",
                    description: "100% offspring from mating, like most complex organisms",
                    matingRate: 1.0,
                    matingMethod: 'random',
                    mutationRate: 0.10,
                    numCompetitors: 2,
                    maxGenerations: 50
                },
                asexual: {
                    name: "Asexual Reproduction", 
                    description: "0% mating, pure cloning with mutations (bacteria, some plants)",
                    matingRate: 0.0,
                    mutationRate: 0.15,
                    numCompetitors: 1,
                    maxGenerations: 50
                },
                highMutation: {
                    name: "High Mutation (r-strategy)",
                    description: "Many offspring, high variation, rapid adaptation",
                    matingRate: 0.7,
                    matingMethod: 'random',
                    mutationRate: 0.50,
                    numCompetitors: 3,
                    maxGenerations: 30
                },
                lowMutation: {
                    name: "Low Mutation (K-strategy)",
                    description: "Few offspring, low variation, stable strategies",
                    matingRate: 0.5,
                    matingMethod: 'average',
                    mutationRate: 0.05,
                    numCompetitors: 1,
                    maxGenerations: 100
                },
                small: {
                    name: "Small Population",
                    description: "Genetic drift dominates, founder effects visible",
                    matingRate: 0.5,
                    mutationRate: 0.20,
                    numCompetitors: 1,
                    maxGenerations: 50
                },
                large: {
                    name: "Large Population",
                    description: "Natural selection dominates, more stable evolution",
                    matingRate: 0.5,
                    mutationRate: 0.20,
                    numCompetitors: 3,
                    maxGenerations: 50
                },
                bottleneck: {
                    name: "Genetic Bottleneck",
                    description: "Simulates population crash - only 1 survivor per generation",
                    matingRate: 0.3,
                    mutationRate: 0.30,
                    numCompetitors: 1,
                    maxGenerations: 50
                },
                diverse: {
                    name: "High Diversity",
                    description: "Many winners compete, maintains genetic variation",
                    matingRate: 0.6,
                    matingMethod: 'random',
                    mutationRate: 0.15,
                    numCompetitors: 3,
                    maxGenerations: 50
                }
            };
            
            const preset = presets[presetName];
            if (!preset) return;
            
            // Apply settings
            matingRate = preset.matingRate;
            document.getElementById('matingRate').value = matingRate;
            
            if (preset.matingMethod) {
                matingMethod = preset.matingMethod;
                document.getElementById('matingMethod').value = matingMethod;
            }
            
            mutationRate = preset.mutationRate;
            document.getElementById('mutationRate').value = mutationRate;
            
            numCompetitors = preset.numCompetitors;
            document.getElementById('numCompetitors').value = numCompetitors;
            
            maxGenerations = preset.maxGenerations;
            document.getElementById('generationsToRun').value = maxGenerations;
            
            currentExperimentName = preset.name;
            showMessage(`Preset applied: ${preset.name} - ${preset.description}`);
        }
        
        function showComparisonSummary() {
            if (experimentRuns.length < 2) {
                alert('Need at least 2 saved runs to compare!');
                return;
            }
            
            let html = `<div style="padding: 20px;">`;
            html += `<h2 style="color: #667eea; margin-bottom: 20px;">Experiment Comparison (${experimentRuns.length} runs)</h2>`;
            
            html += `<table style="width: 100%; border-collapse: collapse; color: white;">`;
            html += `<tr style="background: rgba(102, 126, 234, 0.2); font-weight: bold;">`;
            html += `<th style="padding: 10px; text-align: left; border: 1px solid rgba(255,255,255,0.1);">Run Name</th>`;
            html += `<th style="padding: 10px; text-align: center; border: 1px solid rgba(255,255,255,0.1);">Mating Rate</th>`;
            html += `<th style="padding: 10px; text-align: center; border: 1px solid rgba(255,255,255,0.1);">Mutation Rate</th>`;
            html += `<th style="padding: 10px; text-align: center; border: 1px solid rgba(255,255,255,0.1);">Pop Size</th>`;
            html += `<th style="padding: 10px; text-align: center; border: 1px solid rgba(255,255,255,0.1);">Best Win Rate</th>`;
            html += `<th style="padding: 10px; text-align: center; border: 1px solid rgba(255,255,255,0.1);">Avg Money</th>`;
            html += `<th style="padding: 10px; text-align: center; border: 1px solid rgba(255,255,255,0.1);">Eval Win %</th>`;
            html += `</tr>`;
            
            experimentRuns.forEach((run, i) => {
                const bgColor = i % 2 === 0 ? 'rgba(255,255,255,0.05)' : 'rgba(255,255,255,0.02)';
                html += `<tr style="background: ${bgColor};">`;
                html += `<td style="padding: 10px; border: 1px solid rgba(255,255,255,0.1);">${run.name}</td>`;
                html += `<td style="padding: 10px; text-align: center; border: 1px solid rgba(255,255,255,0.1);">${(run.settings.matingRate * 100).toFixed(0)}%</td>`;
                html += `<td style="padding: 10px; text-align: center; border: 1px solid rgba(255,255,255,0.1);">${run.settings.mutationRate.toFixed(2)}</td>`;
                html += `<td style="padding: 10px; text-align: center; border: 1px solid rgba(255,255,255,0.1);">${run.settings.numCompetitors}</td>`;
                html += `<td style="padding: 10px; text-align: center; border: 1px solid rgba(255,255,255,0.1);">${(run.results.bestWinRate * 100).toFixed(1)}%</td>`;
                html += `<td style="padding: 10px; text-align: center; border: 1px solid rgba(255,255,255,0.1);">$${Math.round(run.results.avgWinnerMoney).toLocaleString()}</td>`;
                html += `<td style="padding: 10px; text-align: center; border: 1px solid rgba(255,255,255,0.1);">${(run.results.evaluationWinRate * 100).toFixed(1)}%</td>`;
                html += `</tr>`;
            });
            
            html += `</table>`;
            
            html += `<div style="margin-top: 30px;">`;
            html += `<h3 style="color: #667eea; margin-bottom: 15px;">Key Insights:</h3>`;
            
            // Find best performing run by evaluation
            const bestEval = experimentRuns.reduce((best, run) => 
                run.results.evaluationWinRate > best.results.evaluationWinRate ? run : best
            );
            
            html += `<div style="padding: 15px; background: rgba(72, 187, 120, 0.1); border-radius: 8px; margin-bottom: 10px;">`;
            html += `<strong style="color: #48bb78;">Best Performance:</strong> ${bestEval.name} `;
            html += `(${(bestEval.results.evaluationWinRate * 100).toFixed(1)}% evaluation win rate)`;
            html += `</div>`;
            
            // Mating vs no mating
            const withMating = experimentRuns.filter(r => r.settings.matingRate > 0.5);
            const withoutMating = experimentRuns.filter(r => r.settings.matingRate < 0.3);
            
            if (withMating.length > 0 && withoutMating.length > 0) {
                const avgMating = withMating.reduce((sum, r) => sum + r.results.evaluationWinRate, 0) / withMating.length;
                const avgNoMating = withoutMating.reduce((sum, r) => sum + r.results.evaluationWinRate, 0) / withoutMating.length;
                
                html += `<div style="padding: 15px; background: rgba(102, 126, 234, 0.1); border-radius: 8px; margin-bottom: 10px;">`;
                html += `<strong>Sexual vs Asexual:</strong> `;
                html += `High mating (${withMating.length} runs): ${(avgMating * 100).toFixed(1)}% avg, `;
                html += `Low mating (${withoutMating.length} runs): ${(avgNoMating * 100).toFixed(1)}% avg`;
                if (avgMating > avgNoMating * 1.1) {
                    html += ` → Sexual reproduction shows ${(((avgMating / avgNoMating) - 1) * 100).toFixed(1)}% advantage!`;
                } else if (avgNoMating > avgMating * 1.1) {
                    html += ` → Asexual reproduction shows ${(((avgNoMating / avgMating) - 1) * 100).toFixed(1)}% advantage!`;
                } else {
                    html += ` → No clear advantage`;
                }
                html += `</div>`;
            }
            
            html += `<button onclick="document.getElementById('comparisonModal').style.display='none'; document.getElementById('modalOverlay').style.display='none';" style="margin-top: 20px; padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 5px; cursor: pointer;">Close</button>`;
            html += `<button onclick="experimentRuns=[]; showMessage('All experiment runs cleared!'); document.getElementById('comparisonModal').style.display='none'; document.getElementById('modalOverlay').style.display='none';" style="margin-left: 10px; padding: 10px 20px; background: #fc8181; color: white; border: none; border-radius: 5px; cursor: pointer;">Clear All Runs</button>`;
            html += `</div>`;
            html += `</div>`;
            
            // Create modal if it doesn't exist
            let modal = document.getElementById('comparisonModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'comparisonModal';
                modal.className = 'modal';
                modal.innerHTML = `<div class="modal-content" style="max-width: 1200px;"><div id="comparisonContent"></div></div>`;
                document.body.appendChild(modal);
            }
            
            document.getElementById('comparisonContent').innerHTML = html;
            modal.style.display = 'block';
            document.getElementById('modalOverlay').style.display = 'block';
        }

        function showHistory() {
            const modal = document.getElementById('historyModal');
            const overlay = document.getElementById('modalOverlay');
            const content = document.getElementById('historyContent');
            
            if (evolutionHistory.length === 0 && evaluationResults.length === 0) {
                content.innerHTML = '<p>No evolution history yet. Play some games in evolution mode!</p>';
            } else {
                let html = '<div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; margin-bottom: 15px;">';
                html += '<strong>EVOLUTION LOG</strong><br>';
                html += `Training Generations: ${evolutionHistory.length}<br>`;
                if (evaluationResults.length > 0) {
                    const wins = evaluationResults.filter(r => r.championWon).length;
                    const winRate = ((wins / evaluationResults.length) * 100).toFixed(1);
                    html += `Evaluation: ${wins}/${evaluationResults.length} wins (${winRate}%)<br>`;
                }
                html += '</div>';
                
                evolutionHistory.forEach((record, index) => {
                    html += '<div style="background: rgba(255,255,255,0.05); padding: 12px; border-radius: 8px; margin-bottom: 10px; border-left: 3px solid #667eea;">';
                    html += `<div style="color: #667eea; font-weight: bold;">GENERATION ${record.generation}</div>`;
                    html += `<div>Winner: ${record.winner}</div>`;
                    html += `<div>Final Money: $${record.finalMoney} | Properties: ${record.properties} | Monopolies: ${record.monopolies}</div>`;
                    html += `<div>Turns: ${record.turns} | Rent Collected: $${record.totalRentCollected}</div>`;
                    
                    if (record.weights) {
                        html += '<div style="margin-top: 8px; font-size: 11px; color: #a0aec0;">Weights:</div>';
                        html += '<div style="font-size: 10px; color: #cbd5e0;">';
                        for (const [key, value] of Object.entries(record.weights)) {
                            html += `${key}: ${value.toFixed(3)} `;
                        }
                        html += '</div>';
                    }
                    
                    html += '<div style="margin-top: 8px; font-size: 11px;">Final Standings:</div>';
                    record.playerStats.forEach((stat, i) => {
                        const badge = stat.isChampion ? ' CHAMP' : 
                                      (stat.isWinner ? ' WIN' :
                                      (stat.isOffspring ? ' OFF' :
                                      (stat.isMutant ? ' MUT' : 
                                      (stat.isRandom ? ' RND' : 
                                      (stat.isAlwaysSpend ? ' SPEND' : '')))));
                        html += `<div style="font-size: 11px; color: ${i === record.winnerIndex ? '#48bb78' : '#a0aec0'};">`;
                        html += `${stat.name}${badge}: $${stat.money} (${stat.properties} props, Rent: $${stat.totalRentCollected})`;
                        html += '</div>';
                    });
                    
                    if (record.winnerPoolSize !== undefined) {
                        html += `<div style="margin-top: 5px; font-size: 10px; color: #718096;">Winner Pool: ${record.winnerPoolSize} AIs</div>`;
                    }
                    
                    html += '</div>';
                });
                
                if (evaluationResults.length > 0) {
                    html += '<div style="background: rgba(72, 187, 120, 0.1); padding: 15px; border-radius: 8px; margin-top: 20px; border-left: 3px solid #48bb78;">';
                    html += '<div style="color: #48bb78; font-weight: bold; margin-bottom: 10px;">EVALUATION RESULTS</div>';
                    
                    // Count wins by player type
                    const bestWins = evaluationResults.filter(r => r.winnerName.includes('Best')).length;
                    const alwaysSpendWins = evaluationResults.filter(r => r.winnerName === 'Always Spend').length;
                    const randomWins = evaluationResults.filter(r => r.winnerName.startsWith('Random')).length;
                    
                    // Calculate average stats
                    const avgTurns = (evaluationResults.reduce((sum, r) => sum + r.turns, 0) / evaluationResults.length).toFixed(1);
                    const avgMoney = (evaluationResults.reduce((sum, r) => sum + r.finalMoney, 0) / evaluationResults.length).toFixed(0);
                    
                    // Win rate stats
                    const bestWinRate = ((bestWins/evaluationResults.length)*100).toFixed(1);
                    const alwaysSpendWinRate = ((alwaysSpendWins/evaluationResults.length)*100).toFixed(1);
                    const randomWinRate = ((randomWins/evaluationResults.length)*100).toFixed(1);
                    
                    html += `<div style="font-size: 14px; margin-bottom: 15px;">`;
                    html += `<div style="margin-bottom: 5px;"><strong>Best from Pool:</strong> ${bestWins}/${evaluationResults.length} wins (${bestWinRate}%)</div>`;
                    html += `<div style="margin-bottom: 5px;"><strong>Always Spend:</strong> ${alwaysSpendWins}/${evaluationResults.length} wins (${alwaysSpendWinRate}%)</div>`;
                    html += `<div style="margin-bottom: 5px;"><strong>Random:</strong> ${randomWins}/${evaluationResults.length} wins (${randomWinRate}%)</div>`;
                    html += `</div>`;
                    
                    html += `<div style="font-size: 12px; color: #a0aec0; margin-top: 10px;">`;
                    html += `<div>Avg Game Length: ${avgTurns} turns</div>`;
                    html += `<div>Avg Winner Money: $${avgMoney}</div>`;
                    html += `</div>`;
                    
                    // Performance verdict
                    html += `<div style="margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 5px; font-size: 13px;">`;
                    if (bestWinRate >= 50) {
                        html += `<div style="color: #48bb78;">✓ Evolved AI dominates (${bestWinRate}% win rate)</div>`;
                    } else if (bestWinRate >= 40) {
                        html += `<div style="color: #ecc94b;">~ Evolved AI is competitive (${bestWinRate}% win rate)</div>`;
                    } else if (bestWinRate >= 25) {
                        html += `<div style="color: #ed8936;">⚠ Evolved AI struggles (${bestWinRate}% win rate)</div>`;
                    } else {
                        html += `<div style="color: #fc8181;">✗ Evolved AI performs poorly (${bestWinRate}% win rate)</div>`;
                    }
                    html += `</div>`;
                    
                    html += '<div style="margin-top: 10px; font-size: 11px; color: #a0aec0;">Game-by-Game:</div>';
                    evaluationResults.forEach((result) => {
                        const isBest = result.winnerName.includes('Best');
                        const color = isBest ? '#48bb78' : '#fc8181';
                        html += `<div style="font-size: 11px; color: ${color}; padding: 5px 0;">`;
                        html += `Game ${result.gameNumber}: ${result.winnerName} won with $${result.finalMoney} (${result.turns} turns)`;
                        html += '</div>';
                    });
                    
                    html += '</div>';
                }
                
                content.innerHTML = html;
            }
            
            modal.style.display = 'block';
            overlay.style.display = 'block';
        }

        function closeHistory() {
            document.getElementById('historyModal').style.display = 'none';
            document.getElementById('modalOverlay').style.display = 'none';
        }

        function downloadHistory() {
            if (evolutionHistory.length === 0) {
                alert('No history to download yet!');
                return;
            }
            
            // Calculate comprehensive statistics
            const totalGames = evolutionHistory.length;
            const winnerTypeStats = {
                winner: evolutionHistory.filter(r => r.winner.includes('Winner')).length,
                offspring: evolutionHistory.filter(r => r.winner.includes('Offspring')).length,
                mutant: evolutionHistory.filter(r => r.winner.includes('Mutant')).length,
                random: evolutionHistory.filter(r => r.winner.includes('Random')).length,
                champion: evolutionHistory.filter(r => r.winner.includes('Champion')).length
            };
            
            const avgTurns = (evolutionHistory.reduce((sum, r) => sum + r.turns, 0) / totalGames).toFixed(1);
            const avgMoney = Math.round(evolutionHistory.reduce((sum, r) => sum + r.finalMoney, 0) / totalGames);
            const avgProperties = (evolutionHistory.reduce((sum, r) => sum + r.properties, 0) / totalGames).toFixed(1);
            const avgRent = Math.round(evolutionHistory.reduce((sum, r) => sum + r.totalRentCollected, 0) / totalGames);
            
            const maxMoney = Math.max(...evolutionHistory.map(r => r.finalMoney));
            const minMoney = Math.min(...evolutionHistory.map(r => r.finalMoney));
            const maxTurns = Math.max(...evolutionHistory.map(r => r.turns));
            const minTurns = Math.min(...evolutionHistory.map(r => r.turns));
            
            let html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Trader Evolution Report - ${new Date().toLocaleDateString()}</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 100%); 
            color: #e2e8f0; 
            padding: 40px 20px;
            line-height: 1.6;
        }
        .container { 
            max-width: 1400px; 
            margin: 0 auto; 
            background: rgba(255,255,255,0.05); 
            padding: 40px; 
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        }
        h1 { 
            text-align: center; 
            font-size: 2.8em; 
            margin-bottom: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .subtitle {
            text-align: center;
            color: #a0aec0;
            margin-bottom: 40px;
            font-size: 1.1em;
        }
        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }
        .stat-card {
            background: rgba(102, 126, 234, 0.1);
            padding: 25px;
            border-radius: 15px;
            border-left: 4px solid #667eea;
        }
        .stat-label {
            color: #a0aec0;
            font-size: 0.9em;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
        }
        .stat-detail {
            color: #cbd5e0;
            font-size: 0.85em;
            margin-top: 5px;
        }
        .section {
            background: rgba(255,255,255,0.03);
            padding: 30px;
            margin-bottom: 30px;
            border-radius: 15px;
        }
        .section-title {
            font-size: 1.8em;
            color: #667eea;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(102, 126, 234, 0.3);
        }
        .winner-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .winner-card {
            background: rgba(72, 187, 120, 0.1);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }
        .winner-type {
            font-size: 1.1em;
            color: #48bb78;
            margin-bottom: 10px;
            font-weight: bold;
        }
        .winner-count {
            font-size: 2.5em;
            font-weight: bold;
            color: #48bb78;
        }
        .winner-percent {
            color: #a0aec0;
            font-size: 0.9em;
        }
        .generation {
            background: rgba(255,255,255,0.02);
            padding: 20px;
            margin-bottom: 15px;
            border-radius: 12px;
            border-left: 4px solid #764ba2;
            transition: transform 0.2s;
        }
        .generation:hover {
            transform: translateX(5px);
            background: rgba(255,255,255,0.05);
        }
        .gen-header {
            font-size: 1.3em;
            color: #764ba2;
            margin-bottom: 12px;
            font-weight: bold;
        }
        .gen-winner {
            font-size: 1.1em;
            color: #48bb78;
            margin-bottom: 10px;
        }
        .gen-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        .gen-stat {
            color: #cbd5e0;
            font-size: 0.9em;
        }
        .gen-stat strong {
            color: #e2e8f0;
        }
        .player-standings {
            margin-top: 15px;
            padding: 15px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
        }
        .player-row {
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .player-row:last-child {
            border-bottom: none;
        }
        .player-name {
            font-weight: 500;
        }
        .player-stats {
            color: #a0aec0;
            font-size: 0.9em;
        }
        .winner-badge {
            background: #48bb78;
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            margin-left: 8px;
        }
        .evaluation-section {
            background: linear-gradient(135deg, rgba(72,187,120,0.1) 0%, rgba(56,161,105,0.1) 100%);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid rgba(72,187,120,0.3);
            margin-top: 30px;
        }
        .eval-title {
            font-size: 2em;
            color: #48bb78;
            margin-bottom: 20px;
            text-align: center;
        }
        .eval-verdict {
            text-align: center;
            padding: 20px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            margin: 20px 0;
            font-size: 1.3em;
        }
        .eval-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .eval-card {
            background: rgba(0,0,0,0.2);
            padding: 20px;
            border-radius: 10px;
        }
        .eval-games {
            margin-top: 20px;
        }
        .eval-game {
            padding: 12px;
            margin-bottom: 8px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            border-left: 3px solid #48bb78;
        }
        .eval-game.loss {
            border-left-color: #fc8181;
        }
        .pool-info {
            background: rgba(102, 126, 234, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }
        .pool-title {
            font-size: 1.3em;
            color: #667eea;
            margin-bottom: 15px;
        }
        .pool-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        @media print {
            body { background: white; color: black; }
            .container { box-shadow: none; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🚀 Cosmic Trader Evolution Report</h1>
        <div class="subtitle">Generated on ${new Date().toLocaleString()}</div>
        
        <div class="summary-grid">
            <div class="stat-card">
                <div class="stat-label">Total Generations</div>
                <div class="stat-value">${totalGames}</div>
                <div class="stat-detail">Evolution cycles completed</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Average Game Length</div>
                <div class="stat-value">${avgTurns}</div>
                <div class="stat-detail">turns (${minTurns}-${maxTurns} range)</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Average Winner Money</div>
                <div class="stat-value">$${avgMoney.toLocaleString()}</div>
                <div class="stat-detail">$${minMoney.toLocaleString()} - $${maxMoney.toLocaleString()}</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Average Properties</div>
                <div class="stat-value">${avgProperties}</div>
                <div class="stat-detail">per winning player</div>
            </div>
        </div>`;
            
            // Winner type breakdown
            html += `
        <div class="section">
            <div class="section-title">Winner Type Distribution</div>
            <div class="winner-stats">`;
            
            if (winnerTypeStats.winner > 0) {
                html += `
                <div class="winner-card">
                    <div class="winner-type">Pool Winners</div>
                    <div class="winner-count">${winnerTypeStats.winner}</div>
                    <div class="winner-percent">${((winnerTypeStats.winner/totalGames)*100).toFixed(1)}%</div>
                </div>`;
            }
            if (winnerTypeStats.offspring > 0) {
                html += `
                <div class="winner-card">
                    <div class="winner-type">Offspring (Mated)</div>
                    <div class="winner-count">${winnerTypeStats.offspring}</div>
                    <div class="winner-percent">${((winnerTypeStats.offspring/totalGames)*100).toFixed(1)}%</div>
                </div>`;
            }
            if (winnerTypeStats.mutant > 0) {
                html += `
                <div class="winner-card">
                    <div class="winner-type">Mutants</div>
                    <div class="winner-count">${winnerTypeStats.mutant}</div>
                    <div class="winner-percent">${((winnerTypeStats.mutant/totalGames)*100).toFixed(1)}%</div>
                </div>`;
            }
            if (winnerTypeStats.random > 0) {
                html += `
                <div class="winner-card">
                    <div class="winner-type">Random AIs</div>
                    <div class="winner-count">${winnerTypeStats.random}</div>
                    <div class="winner-percent">${((winnerTypeStats.random/totalGames)*100).toFixed(1)}%</div>
                </div>`;
            }
            if (winnerTypeStats.champion > 0) {
                html += `
                <div class="winner-card">
                    <div class="winner-type">Champions</div>
                    <div class="winner-count">${winnerTypeStats.champion}</div>
                    <div class="winner-percent">${((winnerTypeStats.champion/totalGames)*100).toFixed(1)}%</div>
                </div>`;
            }
            
            html += `
            </div>
        </div>`;
            
            // Winner pool info
            if (winnerPool.length > 0) {
                html += `
        <div class="pool-info">
            <div class="pool-title">Winner Pool (Top 5)</div>
            <div class="pool-stats">`;
                
                winnerPool.slice(0, 5).forEach((ai, index) => {
                    html += `
                <div>
                    <strong>#${index + 1}:</strong> ${ai.wins}W / ${ai.games}G 
                    (${(ai.score * 100).toFixed(1)}% win rate)
                </div>`;
                });
                
                html += `
            </div>
        </div>`;
            }
            
            // Evaluation results
            if (evaluationResults.length > 0) {
                const bestWins = evaluationResults.filter(r => r.winnerName.includes('Best')).length;
                const alwaysSpendWins = evaluationResults.filter(r => r.winnerName === 'Always Spend').length;
                const randomWins = evaluationResults.filter(r => r.winnerName.startsWith('Random')).length;
                const bestWinRate = ((bestWins/evaluationResults.length)*100).toFixed(1);
                
                const evalAvgTurns = (evaluationResults.reduce((sum, r) => sum + r.turns, 0) / evaluationResults.length).toFixed(1);
                const evalAvgMoney = Math.round(evaluationResults.reduce((sum, r) => sum + r.finalMoney, 0) / evaluationResults.length);
                
                html += `
        <div class="evaluation-section">
            <div class="eval-title">📊 Evaluation Results</div>
            
            <div class="eval-verdict">`;
                
                if (bestWinRate >= 50) {
                    html += `<div style="color: #48bb78;">✓ DOMINANT: Evolved AI wins ${bestWinRate}% of games</div>`;
                } else if (bestWinRate >= 40) {
                    html += `<div style="color: #ecc94b;">~ COMPETITIVE: Evolved AI wins ${bestWinRate}% of games</div>`;
                } else if (bestWinRate >= 25) {
                    html += `<div style="color: #ed8936;">⚠ STRUGGLING: Evolved AI wins ${bestWinRate}% of games</div>`;
                } else {
                    html += `<div style="color: #fc8181;">✗ WEAK: Evolved AI wins ${bestWinRate}% of games</div>`;
                }
                
                html += `
            </div>
            
            <div class="eval-stats-grid">
                <div class="eval-card">
                    <div class="stat-label">Best from Pool</div>
                    <div class="stat-value">${bestWins}/${evaluationResults.length}</div>
                    <div class="stat-detail">${bestWinRate}% win rate</div>
                </div>
                <div class="eval-card">
                    <div class="stat-label">Always Spend AI</div>
                    <div class="stat-value">${alwaysSpendWins}/${evaluationResults.length}</div>
                    <div class="stat-detail">${((alwaysSpendWins/evaluationResults.length)*100).toFixed(1)}% win rate</div>
                </div>
                <div class="eval-card">
                    <div class="stat-label">Random Opponents</div>
                    <div class="stat-value">${randomWins}/${evaluationResults.length}</div>
                    <div class="stat-detail">${((randomWins/evaluationResults.length)*100).toFixed(1)}% win rate</div>
                </div>
                <div class="eval-card">
                    <div class="stat-label">Avg Game Length</div>
                    <div class="stat-value">${evalAvgTurns}</div>
                    <div class="stat-detail">turns per game</div>
                </div>
                <div class="eval-card">
                    <div class="stat-label">Avg Winner Money</div>
                    <div class="stat-value">$${evalAvgMoney.toLocaleString()}</div>
                    <div class="stat-detail">at game end</div>
                </div>
            </div>
            
            <div class="eval-games">
                <h3 style="margin-bottom: 15px;">Game-by-Game Results:</h3>`;
                
                evaluationResults.forEach((result) => {
                    const isBest = result.winnerName.includes('Best');
                    const cssClass = isBest ? '' : 'loss';
                    html += `
                <div class="eval-game ${cssClass}">
                    <strong>Game ${result.gameNumber}:</strong> ${result.winnerName} won with $${result.finalMoney.toLocaleString()} (${result.turns} turns)
                </div>`;
                });
                
                html += `
            </div>
        </div>`;
            }
            
            // Generation-by-generation details
            html += `
        <div class="section">
            <div class="section-title">Generation History</div>`;
            
            evolutionHistory.forEach(record => {
                html += `
            <div class="generation">
                <div class="gen-header">Generation ${record.generation}</div>
                <div class="gen-winner">🏆 Winner: ${record.winner}</div>
                <div class="gen-stats">
                    <div class="gen-stat"><strong>Money:</strong> $${record.finalMoney.toLocaleString()}</div>
                    <div class="gen-stat"><strong>Properties:</strong> ${record.properties}</div>
                    <div class="gen-stat"><strong>Monopolies:</strong> ${record.monopolies || 0}</div>
                    <div class="gen-stat"><strong>Turns:</strong> ${record.turns}</div>
                    <div class="gen-stat"><strong>Rent Collected:</strong> $${record.totalRentCollected.toLocaleString()}</div>`;
                
                if (record.winnerPoolSize !== undefined) {
                    html += `<div class="gen-stat"><strong>Pool Size:</strong> ${record.winnerPoolSize}</div>`;
                }
                
                html += `
                </div>`;
                
                if (record.playerStats && record.playerStats.length > 0) {
                    html += `
                <div class="player-standings">
                    <strong style="color: #a0aec0; font-size: 0.9em;">Final Standings:</strong>`;
                    
                    record.playerStats.forEach((stat, i) => {
                        const isWinner = i === record.winnerIndex;
                        const badge = stat.isChampion ? 'CHAMP' : 
                                     (stat.isWinner ? 'WIN' :
                                     (stat.isOffspring ? 'OFF' :
                                     (stat.isMutant ? 'MUT' : 
                                     (stat.isRandom ? 'RND' : 
                                     (stat.isAlwaysSpend ? 'SPEND' : '')))));
                        
                        html += `
                    <div class="player-row" style="color: ${isWinner ? '#48bb78' : '#cbd5e0'}">
                        <div class="player-name">
                            ${stat.name}${badge ? `<span class="winner-badge">${badge}</span>` : ''}
                        </div>
                        <div class="player-stats">
                            $${stat.money.toLocaleString()} | ${stat.properties} props | $${stat.totalRentCollected.toLocaleString()} rent
                        </div>
                    </div>`;
                    });
                    
                    html += `
                </div>`;
                }
                
                html += `
            </div>`;
            });
            
            html += `
        </div>
        
        <div style="text-align: center; margin-top: 40px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.1); color: #a0aec0; font-size: 0.9em;">
            Generated by Cosmic Trader Evolution System
        </div>
    </div>
</body>
</html>`;

            const blob = new Blob([html], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `cosmic-trader-evolution-report-${Date.now()}.html`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showMessage('Comprehensive evolution report exported!');
        }

        function togglePause() {
            isPaused = !isPaused;
            const button = document.getElementById('pauseButton');
            
            if (isPaused) {
                button.textContent = 'Resume';
                button.style.background = 'linear-gradient(135deg, #48bb78 0%, #38a169 100%)';
                showMessage('Game paused. Click Resume to continue.');
            } else {
                button.textContent = 'Pause';
                button.style.background = 'linear-gradient(135deg, #ed8936 0%, #dd6b20 100%)';
                showMessage(`Game resumed. ${players[currentPlayer].name}'s turn.`);
                
                if (players[currentPlayer].isAI && !hasRolled) {
                    setTimeout(() => {
                        if (!isPaused) {
                            rollDice();
                        }
                    }, 800);
                }
            }
        }

        function toggleFastMode() {
            // Check if trying to enable fast mode when experiment is already complete
            if (!fastMode) {
                const trainingComplete = !evolutionMode || evolutionHistory.length >= maxGenerations;
                const evaluationComplete = !isInEvaluationPhase || evaluationResults.length >= evaluationGames;
                
                if (evolutionMode && trainingComplete && evaluationComplete) {
                    alert('Experiment complete! Click "Start New Experiment" to run another experiment with different settings.');
                    return;
                }
            }
            
            fastMode = !fastMode;
            const button = document.getElementById('fastModeButton');
            const boardContainer = document.querySelector('.board-container');
            const diceDisplay = document.querySelector('.dice-display');
            const rollButton = document.getElementById('rollButton');
            const endTurnButton = document.getElementById('endTurnButton');
            
            if (fastMode) {
                button.textContent = 'Show Board';
                button.style.background = 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)';
                boardContainer.style.display = 'none';
                diceDisplay.style.display = 'none';
                rollButton.style.display = 'none';
                endTurnButton.style.display = 'none';
                
                showMessage('Fast mode enabled! Running at maximum speed...');
                
                if (fastModeInterval) {
                    clearInterval(fastModeInterval);
                }
                
                fastModeInterval = setInterval(() => {
                    updatePlayersInfo();
                    updateGameStats();
                }, 100);
                
                if (!hasRolled) {
                    setTimeout(() => rollDice(), 10);
                }
            } else {
                button.textContent = 'Fast Mode';
                button.style.background = 'linear-gradient(135deg, #38b2ac 0%, #319795 100%)';
                
                // Only show board if we're completely done with evolution (both training and evaluation)
                const trainingComplete = !evolutionMode || evolutionHistory.length >= maxGenerations;
                const evaluationComplete = !isInEvaluationPhase || evaluationResults.length >= evaluationGames;
                const fullyComplete = trainingComplete && evaluationComplete;
                
                if (fullyComplete || !evolutionMode) {
                    boardContainer.style.display = 'block';
                    diceDisplay.style.display = 'flex';
                    rollButton.style.display = 'block';
                }
                
                if (fastModeInterval) {
                    clearInterval(fastModeInterval);
                    fastModeInterval = null;
                }
                
                updatePlayerPositions();
                updatePlayersInfo();
                updateGameStats();
                
                const winner = checkWinner();
                if (winner) {
                    showMessage(`${winner.name} wins with $${winner.money}! Game Over!`);
                    rollButton.disabled = true;
                } else {
                    showMessage(`Fast mode disabled. ${players[currentPlayer].name}'s turn.`);
                    if (!players[currentPlayer].isAI) {
                        rollButton.disabled = false;
                    }
                }
            }
        }

        // Read current settings from input fields
        function updateSettingsFromInputs() {
            const genInput = document.getElementById('generationsToRun');
            if (genInput) {
                const val = parseInt(genInput.value);
                if (val >= 1 && val <= 1000) maxGenerations = val;
            }
            
            const evalInput = document.getElementById('evaluationGames');
            if (evalInput) {
                const val = parseInt(evalInput.value);
                if (val >= 0 && val <= 100) evaluationGames = val;
            }
            
            const mutantsInput = document.getElementById('numMutants');
            if (mutantsInput) {
                const val = parseInt(mutantsInput.value);
                if (val >= 1 && val <= 3) numMutants = val;
            }
            
            const mutRateInput = document.getElementById('mutationRate');
            if (mutRateInput) {
                const val = parseFloat(mutRateInput.value);
                if (val >= 0.01 && val <= 1.0) mutationRate = val;
            }
            
            const turnsInput = document.getElementById('maxTurns');
            if (turnsInput) {
                const val = parseInt(turnsInput.value);
                if (val >= 50 && val <= 1000) {
                    maxTurns = val;
                    // Update display in case it wasn't updated yet
                    const display = document.getElementById('maxTurnsDisplay');
                    if (display) display.textContent = maxTurns;
                }
            }
            
            const competitorsInput = document.getElementById('numCompetitors');
            if (competitorsInput) {
                const val = parseInt(competitorsInput.value);
                if (val >= 1 && val <= 3) numCompetitors = val;
            }
            
            const matingRateInput = document.getElementById('matingRate');
            if (matingRateInput) {
                const val = parseFloat(matingRateInput.value);
                if (val >= 0.0 && val <= 1.0) matingRate = val;
            }
            
            const matingMethodInput = document.getElementById('matingMethod');
            if (matingMethodInput) {
                matingMethod = matingMethodInput.value;
            }
        }

        function resetGame() {
            const aiSettings = [...playerAISettings];
            
            // Update the display to show current max turns
            document.getElementById('maxTurnsDisplay').textContent = maxTurns;
            
            // Show what settings are being used for this game
            console.log(`[GAME START] Max Turns: ${maxTurns}, Mutants: ${numMutants}, Mutation Rate: ${mutationRate}, Competitors: ${numCompetitors}`);
            
            // Reset debug flags
            debugLogging = false;
            debugTurnsRemaining = 0;
            player1BankruptTurn = -1;
            
            players = [
                { name: "Player 1", money: 1200, position: 0, color: "#f56565", properties: [], isAI: aiSettings[0], aiWeights: null, totalRentCollected: 0, alwaysSpend: false },
                { name: "Player 2", money: 1200, position: 0, color: "#48bb78", properties: [], isAI: aiSettings[1], aiWeights: null, totalRentCollected: 0, alwaysSpend: false },
                { name: "Player 3", money: 1200, position: 0, color: "#4299e1", properties: [], isAI: aiSettings[2], aiWeights: null, totalRentCollected: 0, alwaysSpend: false },
                { name: "Player 4", money: 1200, position: 0, color: "#ed8936", properties: [], isAI: aiSettings[3], aiWeights: null, totalRentCollected: 0, alwaysSpend: false }
            ];
            
            spaces.forEach(space => {
                delete space.owner;
                space.buildings = 0;
            });
            
            currentPlayer = 0;
            hasRolled = false;
            turnCount = 0;
            isPaused = false;
            
            const pauseButton = document.getElementById('pauseButton');
            pauseButton.textContent = 'Pause';
            pauseButton.style.background = 'linear-gradient(135deg, #ed8936 0%, #dd6b20 100%)';
            
            gameStats = {
                propertiesSold: 0,
                totalRentPaid: 0,
                totalTaxesPaid: 0
            };
            
            if (evolutionMode && championWeights && !isInEvaluationPhase) {
                // Training generation: Select from winner pool + mutants/offspring + random
                const numWinners = Math.min(numCompetitors, 4); // Can't have more winners than players
                const numOffspring = 4 - numWinners; // Remaining slots for mutants/offspring
                
                // Calculate how many should be from mating vs mutation
                const numMated = Math.floor(numOffspring * matingRate);
                const numMutated = numOffspring - numMated;
                
                let playerIndex = 0;
                
                // Add winners from pool
                for (let i = 0; i < numWinners && playerIndex < 4; i++) {
                    if (players[playerIndex].isAI) {
                        const weights = selectFromWinnerPool();
                        if (weights) {
                            players[playerIndex].aiWeights = weights;
                            players[playerIndex].name = `Player ${playerIndex + 1} (Winner)`;
                            players[playerIndex].alwaysSpend = false;
                        } else {
                            // No winners yet, use random
                            players[playerIndex].aiWeights = {
                                cashOnHandForBuying: (Math.random() - 0.5) * 2,
                                propertyPrice: (Math.random() - 0.5) * 2,
                                rentValue: (Math.random() - 0.5) * 2,
                                colorGroupOwned: (Math.random() - 0.5) * 2,
                                colorGroupAvailable: (Math.random() - 0.5) * 2,
                                cashOnHandForBuilding: (Math.random() - 0.5) * 2,
                                buildingRentWeight: (Math.random() - 0.5) * 2,
                                buildingCostWeight: (Math.random() - 0.5) * 2
                            };
                            players[playerIndex].name = `Player ${playerIndex + 1} (Random)`;
                            players[playerIndex].alwaysSpend = false;
                        }
                        playerIndex++;
                    }
                }
                
                // Add offspring from mating
                for (let i = 0; i < numMated && playerIndex < 4; i++) {
                    if (players[playerIndex].isAI) {
                        const parents = selectParentsForMating();
                        if (parents) {
                            players[playerIndex].aiWeights = mateWeights(parents.parent1, parents.parent2);
                            players[playerIndex].name = `Player ${playerIndex + 1} (Offspring)`;
                            players[playerIndex].alwaysSpend = false;
                        } else {
                            // Not enough parents, use mutation instead
                            const baseWeights = winnerPool.length > 0 ? winnerPool[0].weights : championWeights;
                            players[playerIndex].aiWeights = mutateWeights(baseWeights);
                            players[playerIndex].name = `Player ${playerIndex + 1} (Mutant)`;
                            players[playerIndex].alwaysSpend = false;
                        }
                        playerIndex++;
                    }
                }
                
                // Add mutants
                for (let i = 0; i < numMutated && playerIndex < 4; i++) {
                    if (players[playerIndex].isAI) {
                        const baseWeights = winnerPool.length > 0 ? winnerPool[0].weights : championWeights;
                        players[playerIndex].aiWeights = mutateWeights(baseWeights);
                        players[playerIndex].name = `Player ${playerIndex + 1} (Mutant)`;
                        players[playerIndex].alwaysSpend = false;
                        playerIndex++;
                    }
                }
                
                // Fill remaining with random (shouldn't happen, but safety check)
                while (playerIndex < 4) {
                    if (players[playerIndex].isAI) {
                        players[playerIndex].aiWeights = {
                            cashOnHandForBuying: (Math.random() - 0.5) * 2,
                            propertyPrice: (Math.random() - 0.5) * 2,
                            rentValue: (Math.random() - 0.5) * 2,
                            colorGroupOwned: (Math.random() - 0.5) * 2,
                            colorGroupAvailable: (Math.random() - 0.5) * 2,
                            cashOnHandForBuilding: (Math.random() - 0.5) * 2,
                            buildingRentWeight: (Math.random() - 0.5) * 2,
                            buildingCostWeight: (Math.random() - 0.5) * 2
                        };
                        players[playerIndex].name = `Player ${playerIndex + 1} (Random)`;
                        players[playerIndex].alwaysSpend = false;
                    }
                    playerIndex++;
                }
                
                const genDisplay = document.getElementById('generationDisplay');
                genDisplay.style.display = 'block';
                genDisplay.textContent = `Generation ${evolutionHistory.length + 1}/${maxGenerations} (Pool: ${winnerPool.length})`;
                
                showMessage(`Generation ${evolutionHistory.length + 1}: ${numWinners} Winners, ${numMated} Offspring, ${numMutated} Mutants`);
            } else if (isInEvaluationPhase && championWeights) {
                // Evaluation: Best from pool vs 1 Always Spend + 2 Random opponents
                players.forEach((player, index) => {
                    if (player.isAI) {
                        if (index === 0) {
                            // Player 1 is the best from winner pool
                            const bestFromPool = winnerPool.length > 0 ? winnerPool[0] : null;
                            if (bestFromPool) {
                                player.aiWeights = cloneWeights(bestFromPool.weights);
                                player.name = `Best (${bestFromPool.wins}W/${bestFromPool.games}G)`;
                            } else {
                                player.aiWeights = cloneWeights(championWeights);
                                player.name = "Champion";
                            }
                            player.alwaysSpend = false;
                        } else if (index === 1) {
                            // Player 2 is Always Spend
                            player.aiWeights = null;
                            player.alwaysSpend = true;
                            player.name = "Always Spend";
                        } else {
                            // Players 3 & 4 are random opponents
                            player.aiWeights = {
                                cashOnHandForBuying: (Math.random() - 0.5) * 2,
                                propertyPrice: (Math.random() - 0.5) * 2,
                                rentValue: (Math.random() - 0.5) * 2,
                                colorGroupOwned: (Math.random() - 0.5) * 2,
                                colorGroupAvailable: (Math.random() - 0.5) * 2,
                                cashOnHandForBuilding: (Math.random() - 0.5) * 2,
                                buildingRentWeight: (Math.random() - 0.5) * 2,
                                buildingCostWeight: (Math.random() - 0.5) * 2
                            };
                            player.alwaysSpend = false;
                            player.name = `Random ${index}`;
                        }
                    }
                });
                
                const genDisplay = document.getElementById('generationDisplay');
                genDisplay.style.display = 'block';
                genDisplay.textContent = `Evaluation ${evaluationResults.length + 1}/${evaluationGames}`;
                
                showMessage(`Evaluation Game ${evaluationResults.length + 1}/${evaluationGames}: Best vs Always Spend + Random!`);
            } else {
                initializeAIWeights();
                
                const genDisplay = document.getElementById('generationDisplay');
                genDisplay.style.display = evolutionMode ? 'block' : 'none';
                if (evolutionMode) {
                    genDisplay.textContent = `Generation 1`;
                }
                
                showMessage('New game started! Configure players in settings or roll to begin.');
            }
            
            const allAI = players.every(p => p.isAI);
            const rollButton = document.getElementById('rollButton');
            rollButton.disabled = allAI;
            
            if (allAI) {
                rollButton.title = 'All players are AI - game runs automatically';
            } else {
                rollButton.title = 'Roll the dice to move';
            }
            
            document.getElementById('endTurnButton').style.display = 'none';
            document.getElementById('die1').textContent = '?';
            document.getElementById('die2').textContent = '?';
            
            updatePlayerPositions();
            updatePlayersInfo();
            updateGameStats();
            
            setTimeout(() => {
                const hasHuman = players.some(p => !p.isAI);
                
                if (allAI) {
                    if (evolutionMode && championWeights) {
                        showMessage(`Generation ${evolutionHistory.length + 1} starting...`);
                    } else {
                        showMessage('All players are AI. Game starting automatically...');
                    }
                    setTimeout(() => {
                        if (shouldResumeFastMode) {
                            toggleFastMode();
                            shouldResumeFastMode = false;
                        }
                        rollDice();
                    }, 1000);
                } else if (hasHuman && players[0].isAI) {
                    // Mixed game starting with AI player - auto-play until human turn
                    showMessage('Playing AI turns...');
                    setTimeout(() => playAITurnsUntilHuman(), 1000);
                } else if (hasHuman && !players[0].isAI) {
                    // Human player goes first
                    showMessage(`${players[0].name}'s turn! Roll the dice to start.`);
                }
            }, 500);
        }

        initializeAIWeights();
        initBoard();
        updateGameStats();
        
        // Initialize max turns display
        document.getElementById('maxTurnsDisplay').textContent = maxTurns;
        
        // Add real-time event listeners for all settings inputs
        // These update immediately as the user changes values
        document.getElementById('maxTurns').addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            if (val >= 50 && val <= 1000) {
                maxTurns = val;
                document.getElementById('maxTurnsDisplay').textContent = maxTurns;
                console.log(`[SETTING] Max Turns updated to: ${maxTurns}`);
            }
        });
        
        document.getElementById('generationsToRun').addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            if (val >= 1 && val <= 1000) {
                maxGenerations = val;
            }
        });
        
        document.getElementById('evaluationGames').addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            if (val >= 0 && val <= 100) {
                evaluationGames = val;
            }
        });
        
        document.getElementById('numMutants').addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            if (val >= 1 && val <= 3) {
                numMutants = val;
            }
        });
        
        document.getElementById('mutationRate').addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            if (val >= 0.01 && val <= 1.0) {
                mutationRate = val;
            }
        });
        
        document.getElementById('numCompetitors').addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            if (val >= 1 && val <= 3) {
                numCompetitors = val;
            }
        });
        
        const genDisplay = document.getElementById('generationDisplay');
        genDisplay.style.display = 'block';
        genDisplay.textContent = 'Generation 1';
        
        showMessage('Evolution mode ready. Click Fast Mode and New Game to start, or adjust settings first.');
    </script>
</body>
</html>