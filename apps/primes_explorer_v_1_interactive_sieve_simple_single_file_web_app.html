<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Primes Explorer — Interactive Sieve (with Start & Progress)</title>
  <style>
    :root{
      --bg:#0e1220; --panel:#151a2c; --ink:#eaf0ff; --muted:#96a3b8; --accent:#7bdcff;
      --prime:#8ef6a0; --comp:#ff5a91; --curr:#ffd166; --b1:#232a45; --b2:#2c3556;
      --bar:#3ad0ff; --barbg:#0b1020;
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--ink);
      font:15.5px/1.55 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Arial}
    header{padding:16px 20px;border-bottom:1px solid var(--b1);background:linear-gradient(180deg,rgba(255,255,255,.03),transparent)}
    h1{margin:0;font-size:20px;letter-spacing:.2px}
    main{display:grid;grid-template-columns:360px 1fr;gap:18px;padding:18px}
    @media (max-width:980px){ main{grid-template-columns:1fr} }

    .card{background:var(--panel);border:1px solid var(--b1);border-radius:16px;box-shadow:0 6px 28px rgba(0,0,0,.25)}
    .controls{padding:14px 14px 10px}
    .controls h2{margin:0 0 8px;font-size:16px;color:var(--accent)}
    .row{display:flex;align-items:center;gap:10px;margin:8px 0}
    .row label{min-width:140px;color:var(--muted)}
    .row input[type="number"]{width:140px;padding:6px 8px;border-radius:10px;border:1px solid var(--b2);background:#0b1020;color:var(--ink)}
    .row input[type="range"]{width:100%}
    .btns{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px}
    button{cursor:pointer;border:1px solid var(--b2);background:#0b1020;color:var(--ink);padding:8px 12px;border-radius:12px}
    button.primary{background:linear-gradient(180deg,#1b2547,#121a38);border-color:#425ab0}
    button:disabled{opacity:.55;cursor:not-allowed}

    .gridWrap{padding:10px}
    .gridHeader{display:flex;justify-content:space-between;align-items:center;margin:0 10px 6px 10px;color:var(--muted)}
    .grid{display:grid;gap:4px;grid-auto-rows:42px;align-content:start;padding:10px}
    .cell{display:grid;place-items:center;border-radius:10px;border:1px solid var(--b2);font-weight:600}
    .cell.small{font-size:12px}
    .cell.prime{background:linear-gradient(180deg, rgba(142,246,160,.18), transparent); color:var(--prime); border-color:rgba(142,246,160,.45)}
    .cell.comp{background:linear-gradient(180deg, rgba(255,90,145,.16), transparent); color:#ffc7da; border-color:rgba(255,90,145,.45)}
    .cell.semi{background:linear-gradient(180deg, rgba(255,196,86,.2), transparent); color:#ffe2a8; border-color:rgba(255,196,86,.55)}
    .cell.curr{outline:2px solid var(--curr); box-shadow:0 0 0 4px rgba(255,209,102,.15)}
    .cell.tiny{font-size:0;padding:0}

    .legend{display:flex;gap:10px;flex-wrap:wrap;color:var(--muted);padding:0 16px 12px}
    .legend span{display:inline-flex;align-items:center;gap:6px}
    .dot{width:14px;height:14px;border-radius:6px;border:1px solid var(--b2)}
    .dot.pr{background:linear-gradient(180deg, rgba(142,246,160,.6), rgba(142,246,160,.25))}
    .dot.co{background:linear-gradient(180deg, rgba(255,90,145,.6), rgba(255,90,145,.2))}
    .dot.cu{background:var(--curr)}

    .stats{padding:12px 14px;border-top:1px solid var(--b1);color:var(--muted)}
    .stats strong{color:var(--ink)}
    .explain{padding:14px 16px 10px;color:#cfe1ff}
    .muted{color:var(--muted)}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono","Courier New",monospace}

    /* Progress UI */
    .progressWrap{padding:10px 14px 14px;border-top:1px solid var(--b1)}
    .progressBar{height:12px;background:var(--barbg);border:1px solid var(--b2);border-radius:999px;overflow:hidden}
    .progressFill{height:100%;width:0%;background:linear-gradient(90deg,#4fe8ff,#6ecbff);transition:width .12s ease}
    .progressInfo{display:flex;justify-content:space-between;gap:10px;color:#cfe1ff;margin-top:6px;font-size:13px;flex-wrap:wrap}

    details.tests{margin:12px 18px 0}
    .testlog{padding:12px 14px 16px;border-top:1px solid var(--b1);color:var(--muted)}
    .testlog .pass{color:#26d07c}.testlog .fail{color:#ff6b6b}
  </style>
</head>
<body>
  <header>
    <h1>Primes Explorer — Interactive Sieve</h1>
    <div class="muted">Explore primes in any interval. Set <strong>Start</strong> and <strong>Max (N)</strong>, then Step/Play or export a report.</div>
  </header>

  <main>
    <section class="card">
      <div class="controls">
        <h2>Sieve Controls</h2>
        <div class="row">
          <label for="startN">Start (inclusive)</label>
          <input id="startN" type="number" min="1" max="2000000" step="1" value="1"/>
        </div>
        <div class="row">
          <label for="maxN">Max number (N)</label>
          <input id="maxN" type="number" min="10" max="2000000" step="1" value="40"/>
        </div>
        <div class="row">
          <label for="cols">Columns</label>
          <input id="cols" type="number" min="5" max="100" step="1" value="10"/>
        </div>
        <div class="row">
          <label for="speed">Speed</label>
          <input id="speed" type="range" min="0" max="1000" value="500"/>
        </div>
        <div class="row">
          <label for="highlightSemi">Highlight semiprimes</label>
          <input id="highlightSemi" type="checkbox" />
        </div>
        <div class="row">
          <label for="fitGrid">Fit all cells (hide labels)</label>
          <input id="fitGrid" type="checkbox" />
        </div>

        <div class="btns">
          <button class="primary" id="btnInit">Reset & Build Grid</button>
          <button id="btnStep">Step</button>
          <button id="btnPlay">Play</button>
          <button id="btnPause" disabled>Pause</button>
          <button id="btnFinish">Finish</button>
          <button id="btnDownloadHtml">Download HTML report</button>
        </div>

        <div class="stats" id="stats">
          <div>Current base: <strong class="mono" id="statBase">–</strong> · Next multiple: <strong class="mono" id="statNext">–</strong></div>
          <div>Marked composites: <strong id="statComp">0</strong> · Primes found: <strong id="statPrime">0</strong> · π(N): <strong id="statPi">0</strong></div>
        </div>

        <!-- Progress indicator -->
        <div class="progressWrap">
          <div class="progressBar"><div class="progressFill" id="progressFill"></div></div>
          <div class="progressInfo">
            <div id="progressText">Ready.</div>
            <div id="progressMini" class="mono"></div>
          </div>
        </div>

        <div class="explain">
          <strong>How it works:</strong> We sieve up to N (global primality), but the grid shows only the chosen interval <span class="mono" id="lblRangeExplain">[1, 40]</span>.
        </div>

        <details class="tests">
          <summary>Developer tests</summary>
          <div class="testlog" id="testlog">
            <button id="btnRunTests">Run tests</button>
            <div id="testResults" style="margin-top:10px"></div>
            <div class="muted" style="margin-top:8px">Adds interval & progress tests; originals unchanged.</div>
          </div>
        </details>
      </div>
    </section>

    <section class="card gridWrap">
      <div class="gridHeader">
        <div>
          <span class="legend">
            <span><span class="dot pr"></span> prime</span>
            <span><span class="dot co"></span> composite</span>
            <span><span class="dot cu"></span> current base</span>
            <span><span class="dot" style="background:linear-gradient(180deg, rgba(255,196,86,.6), rgba(255,196,86,.25))"></span> semiprime (p×q)</span>
          </span>
        </div>
        <div class="muted">Range = <span id="lblRange">[1, 40]</span> · columns = <span id="lblCols">10</span></div>
      </div>
      <div class="grid" id="grid" aria-live="polite"></div>
    </section>
  </main>

  <script>
  // === Utilities ===
  const $ = (sel) => document.querySelector(sel);
  const sleep = (ms) => new Promise(r => setTimeout(r, ms));
  const clamp = (x,min,max)=>Math.max(min, Math.min(max, x));
  const fmt = (n)=> new Intl.NumberFormat().format(n);

  // === SIEVE state ===
  let A = 1;          // Start (inclusive)
  let N = 40;         // End (inclusive)
  let cols = 10, isPlaying=false, base=2, nextMultiple=0;
  let marked=[], isPrime=[], isSemiPrime=[], spf=[], gridReady=false;

  // Elements
  const gridEl = $('#grid');
  const statBase = $('#statBase');
  const statNext = $('#statNext');
  const statComp = $('#statComp');
  const statPrime = $('#statPrime');
  const statPi = $('#statPi');

  const lblRange = $('#lblRange');
  const lblRangeExplain = $('#lblRangeExplain');
  const lblCols = $('#lblCols');

  const maxNInput = $('#maxN');
  const startNInput = $('#startN');
  const colsInput = $('#cols');
  const speedInput = $('#speed');
  const btnInit = $('#btnInit');
  const btnStep = $('#btnStep');
  const btnPlay = $('#btnPlay');
  const btnPause = $('#btnPause');
  const btnFinish = $('#btnFinish');
  const btnDownloadHtml = $('#btnDownloadHtml');
  const btnRunTests = $('#btnRunTests');

  // Progress UI
  const progressFill = $('#progressFill');
  const progressText = $('#progressText');
  const progressMini = $('#progressMini');

  let effectiveCols = cols;

  function resetState(){
    const rawA = parseInt(startNInput.value||1,10);
    const rawN = parseInt(maxNInput.value||40,10);
    N = clamp(rawN, 10, 2000000);
    A = clamp(rawA, 1, N); // ensure 1 ≤ A ≤ N
    cols = clamp(parseInt(colsInput.value||10), 5, 100);

    base = 2; nextMultiple = 0; isPlaying = false;
    marked = Array(N+1).fill(false);
    isPrime = Array(N+1).fill(true);
    if(N>=0) isPrime[0]=false; if(N>=1) isPrime[1]=false;

    buildSPF(N);
    buildSemiprimes(N);
    buildGrid();
    updateStats();
    updateInfoLabels();
    updateButtons();
    setProgress(0, 'Ready.', '');
  }

  function updateInfoLabels(){
    lblRange.textContent = `[${A}, ${N}]`;
    lblRangeExplain.textContent = `[${A}, ${N}]`;
    lblCols.textContent = cols;
  }

  function totalCells(){ return N - A + 1; }

  function buildGrid(){
    gridReady=false;
    gridEl.innerHTML='';
    const frag = document.createDocumentFragment();
    const hideLabels = !!($('#fitGrid') && $('#fitGrid').checked);
    for(let v=A; v<=N; v++){
      const d = document.createElement('div');
      d.className='cell small'; d.dataset.value=v; d.textContent= hideLabels ? '' : v;
      if(hideLabels) d.classList.add('tiny');
      frag.appendChild(d);
    }
    gridEl.appendChild(frag);
    applyGridLayout();
    gridReady=true; paintGrid();
  }

  function applyGridLayout(){
    const fitToggle = $('#fitGrid');
    const hideLabels = !!(fitToggle && fitToggle.checked);
    if(!hideLabels){
      gridEl.style.gridTemplateColumns = `repeat(${cols}, minmax(36px, 1fr))`;
      gridEl.style.gridAutoRows = '42px';
      for(const d of gridEl.children){ if(d){ d.classList.remove('tiny'); if(!d.textContent) d.textContent = d.dataset.value; } }
      effectiveCols = cols; lblCols.textContent = String(effectiveCols);
      return;
    }
    const header = document.querySelector('.gridHeader');
    const card = document.querySelector('.gridWrap');
    const cardRect = card.getBoundingClientRect();
    const headerH = header ? header.offsetHeight : 0;
    const pad = 20;
    const availW = Math.max(100, cardRect.width - 2*pad);
    const availH = Math.max(100, window.innerHeight - cardRect.top - headerH - pad);
    const gap = 4;
    const aspect = availW / availH;
    const count = totalCells();
    let bestCols = Math.max(1, Math.floor(Math.sqrt(count * aspect)));
    let bestRows = Math.ceil(count / bestCols);
    let cellSize = Math.floor(Math.min(
      (availW - gap*(bestCols-1)) / bestCols,
      (availH - gap*(bestRows-1)) / bestRows
    ));
    if(cellSize < 4){ cellSize = 4; }

    gridEl.style.gridTemplateColumns = `repeat(${bestCols}, ${cellSize}px)`;
    gridEl.style.gridAutoRows = `${cellSize}px`;

    for(const d of gridEl.children){ if(d){ d.textContent=''; d.classList.add('tiny'); } }
    effectiveCols = bestCols; lblCols.textContent = String(effectiveCols);
  }

  function paintGrid(){
    if(!gridReady) return;
    const cells = gridEl.children; if(!cells || cells.length < totalCells()) return;
    const hs = $('#highlightSemi');
    let comp=0, primes=0;
    let idx=0;
    for(let v=A; v<=N; v++, idx++){
      const d = cells[idx]; if(!d) continue;
      d.classList.remove('prime','comp','curr','semi');
      if(v===base) d.classList.add('curr');
      if(marked[v]){
        d.classList.add('comp');
        if(hs && hs.checked && isSemiPrime[v]) d.classList.add('semi');
        comp++;
      } else if(isPrime[v]){ d.classList.add('prime'); primes++; }
    }
    statComp.textContent=fmt(comp); statPrime.textContent=fmt(primes); statPi.textContent=fmt(primes);
  }

  function updateStats(){
    statBase.textContent = (base<=N? base : '–');
    statNext.textContent = (nextMultiple>0? nextMultiple : '–');
    paintGrid();
    updateProgress();
  }

  function nextBase(){
    for(let k=base+1;k<=N;k++){
      if(!marked[k]){ base=k; nextMultiple=base*base; return; }
    }
    base = N+1;
  }

  function step(){
    if(base*base > N){ isPlaying=false; updateButtons(); finalizePrimes(); setProgress(100,'Done.',''); updateStats(); return; }
    if(nextMultiple===0){
      if(marked[base] || !isPrime[base]){ nextBase(); updateStats(); return; }
      nextMultiple = base*base; updateStats(); return;
    }
    if(nextMultiple <= N){
      if(!marked[nextMultiple]){ marked[nextMultiple]=true; isPrime[nextMultiple]=false; }
      nextMultiple += base; updateStats(); return;
    } else { nextMultiple=0; nextBase(); updateStats(); return; }
  }

  function finalizePrimes(){
    for(let k=2;k<=N;k++) isPrime[k] = !marked[k];
    paintGrid();
  }

  async function playLoop(){
    isPlaying = true; updateButtons();
    while(isPlaying){
      step(); if(!(base*base <= N)) break;
      const delay = 1020 - parseInt(speedInput.value||500); await sleep(delay);
    }
    isPlaying=false; updateButtons();
  }

  function updateButtons(){ btnPlay.disabled = isPlaying; btnPause.disabled = !isPlaying; }

  // ===== Progress computation =====
  function setProgress(percent, text, mini){
    const p = clamp(percent,0,100);
    progressFill.style.width = p + '%';
    progressText.textContent = text;
    progressMini.textContent = mini || '';
  }

  function updateProgress(){
    if(base*base > N){ setProgress(100, 'Done.', `π(N)≈${statPi.textContent}, comps=${statComp.textContent}`); return; }

    const maxBase = Math.floor(Math.sqrt(N));
    const baseSpan = Math.max(0, maxBase - 1); // bases 2..maxBase
    const baseIndex = Math.max(0, Math.min(base, maxBase)) - 2; // 0-based
    let coarse = baseSpan>0 ? baseIndex / baseSpan : 1;

    let refine = 0;
    if(base*base <= N){
      const totalForBase = Math.floor((N - base*base)/base) + 1; // includes base*base
      let doneForBase = 0;
      if(nextMultiple===0){ doneForBase = 0; }
      else { doneForBase = Math.floor((Math.min(nextMultiple, N+base) - (base*base)) / base); }
      if(totalForBase>0) refine = clamp(doneForBase/totalForBase, 0, 1);

      const percent = Math.round(100 * clamp(((baseIndex + refine) / (baseSpan || 1)), 0, 1));
      const mini = `base ${base}: ${doneForBase}/${totalForBase} · comps=${statComp.textContent} · primes≈${statPi.textContent}`;
      setProgress(percent, `Sieving up to √N (≈ ${maxBase})`, mini);
    } else {
      const percent = Math.round(100 * coarse);
      setProgress(percent, `Sieving up to √N (≈ ${maxBase})`, `base ${base} · comps=${statComp.textContent}`);
    }
  }

  // Smooth, non-blocking finish that updates progress about once/second
  async function finishAll(){
    isPlaying = true; updateButtons();
    const UPDATE_EVERY_MS = 1000;
    let last = performance.now();

    while (base*base <= N){
      step();
      const now = performance.now();
      if (now - last >= UPDATE_EVERY_MS){
        updateStats();
        await sleep(0); // yield to keep UI responsive
        last = now;
      }
    }
    finalizePrimes();
    updateStats();
    setProgress(100,'Done.', `π(N)≈${statPi.textContent}, comps=${statComp.textContent}`);
    isPlaying = false; updateButtons();
  }

  // ===== Reference sieve (pure) =====
  function sieveCount(M){
    if(M<2) return 0; const arr=new Array(M+1).fill(true); arr[0]=false; arr[1]=false;
    for(let p=2;p*p<=M;p++) if(arr[p]) for(let m=p*p;m<=M;m+=p) arr[m]=false;
    let c=0; for(let i=2;i<=M;i++) if(arr[i]) c++; return c;
  }

  // Smallest prime factor sieve for semiprimes
  function buildSPF(limit){
    spf = new Array(limit+1).fill(0);
    for(let i=2;i<=limit;i++) if(spf[i]===0){
      spf[i]=i;
      if(i*i<=limit){
        for(let m=i*i; m<=limit; m+=i){ if(spf[m]===0) spf[m]=i; }
      }
    }
  }
  function buildSemiprimes(limit){
    isSemiPrime = new Array(limit+1).fill(false);
    for(let n=4;n<=limit;n++){
      const a = spf[n]; if(!a || a===n) continue;
      const b = n / a; if(Number.isInteger(b) && spf[b]===b) isSemiPrime[n]=true;
    }
  }

  // ===== HTML report (fresh sieve + interval filter) =====
  function buildPrimesReportHTML(){
    // Pure sieve up to N
    function primesUpTo(M){
      const arr = new Array(M+1).fill(true);
      arr[0]=false; arr[1]=false;
      for(let p=2;p*p<=M;p++){
        if(arr[p]) for(let m=p*p; m<=M; m+=p) arr[m]=false;
      }
      const list=[]; for(let i=2;i<=M;i++) if(arr[i]) list.push(i);
      return list;
    }
    // SPFs for semiprimes
    function spfUpTo(M){
      const spf = new Array(M+1).fill(0);
      for(let i=2;i<=M;i++) if(spf[i]===0){
        spf[i]=i; if(i*i<=M) for(let m=i*i; m<=M; m+=i) if(spf[m]===0) spf[m]=i;
      }
      return spf;
    }

    const primesAll = primesUpTo(N);
    const primes = primesAll.filter(p => p>=A); // interval [A, N]
    const pcountAll = primesAll.length;
    const pcountInRange = primes.length;
    const largest = pcountAll? primesAll[pcountAll-1] : 'none';
    const density = (pcountAll/N);
    const approx = (N>1)? (N/Math.log(N)) : 0;
    const approxErr = (pcountAll - approx);

    // Twin primes (global; show examples in range)
    let twinCount=0; const twinPairs=[];
    for(let i=0;i<pcountAll-1;i++){
      if(primesAll[i+1]-primesAll[i]===2){
        twinCount++;
        const a=primesAll[i], b=primesAll[i+1];
        if(twinPairs.length<12 && a>=A && b<=N) twinPairs.push(`(${a}, ${b})`);
      }
    }

    // Semiprimes count in [A,N]
    const spf = spfUpTo(N);
    let semiCount=0;
    for(let n=Math.max(4,A); n<=N; n++){
      const a=spf[n]; if(a && a!==n){ const b=n/a; if(Number.isInteger(b) && spf[b]===b) semiCount++; }
    }

    // Gaps (global)
    const gaps=[]; for(let i=0;i<pcountAll-1;i++) gaps.push(primesAll[i+1]-primesAll[i]);
    const maxGap = gaps.length? Math.max(...gaps) : 0;
    const maxGapAt = (()=> {
      if(!gaps.length) return '—';
      const g=maxGap, idx=gaps.indexOf(g);
      return `${primesAll[idx]}→${primesAll[idx+1]}`;
    })();
    const avgGap = gaps.length? (gaps.reduce((a,b)=>a+b,0)/gaps.length) : 0;

    // Distributions (in range)
    const lastDigit = {1:0,3:0,7:0,9:0};
    for(const p of primes){ if(p>5){ const d=p%10; if(lastDigit[d]!=null) lastDigit[d]++; } }
    let mod6_1=0, mod6_5=0; for(const p of primes){ if(p>=5){ const r=p%6; if(r===1) mod6_1++; else if(r===5) mod6_5++; } }

    // Checksums (in range)
    const sumMod1e9p7 = primes.reduce((acc,p)=> (acc + p) % 1000000007, 0);
    let xor=0; for(const p of primes) xor ^= p;

    const esc = (s)=>String(s).replace(/[&<>]/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;' }[m]));
    const now = new Date().toLocaleString();

    const styles = `
      :root{--bg:#0e1220;--panel:#151a2c;--ink:#eaf0ff;--muted:#96a3b8;--accent:#7bdcff;--b1:#232a45;--b2:#2c3556}
      *{box-sizing:border-box}
      body{margin:0;background:var(--bg);color:var(--ink);font:15.5px/1.6 system-ui,-apple-system,Segoe UI,Roboto,Arial}
      header{padding:18px 22px;border-bottom:1px solid var(--b1);background:linear-gradient(180deg,rgba(255,255,255,.03),transparent)}
      h1{margin:0 0 2px 0;font-size:22px}
      main{padding:20px;display:grid;gap:18px}
      .card{background:var(--panel);border:1px solid var(--b1);border-radius:14px;box-shadow:0 6px 28px rgba(0,0,0,.25)}
      .sec{padding:14px 16px}
      h2{margin:0 0 10px;color:var(--accent);font-size:18px}
      .row{padding:10px 0;border-bottom:1px dashed var(--b2)}
      .row strong{font-weight:800}
      details{margin:8px 0;border-left:3px solid var(--b2);background:#0b1020;border-radius:8px}
      details>summary{list-style:none;cursor:pointer;padding:8px 12px;font-weight:600;color:#cfe1ff;position:relative}
      details>summary::before{content:"▸";position:absolute;left:8px;transform:translateX(-4px)}
      details[open]>summary::before{content:"▾"}
      details>div{padding:0 12px 12px 12px;color:#dbe6ff}
      .flow{display:flex;flex-wrap:wrap;gap:8px;margin-top:6px}
      .badge{border:1px solid var(--b2);border-radius:999px;padding:3px 10px;background:#0b1020}
      .code{white-space:pre-wrap;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;background:#0b1020;border:1px solid var(--b1);border-radius:10px;padding:10px;margin-top:8px}
    `;

    const html = `<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1">
<title>Primes Report — [${esc(A)}, ${esc(N)}]</title>
<style>${styles}</style>
</head>
<body>
<header>
  <h1>Primes Report</h1>
  <div class="muted">Generated ${esc(now)} · range = <strong>[${esc(A)}, ${esc(N)}]</strong> · π(N) = <strong>${esc(pcountAll)}</strong> · primes in range = <strong>${esc(pcountInRange)}</strong></div>
</header>

<main>
  <section class="card sec">
    <h2>Summary</h2>
    <div class="row"><strong>${esc(largest)}</strong> is the largest prime ≤ N.</div>
    <details><summary>Explain: largest prime ≤ N</summary>
      <div>The last prime not exceeding N is useful for discussing prime gaps and distribution near N.</div>
    </details>

    <div class="row"><strong>${(density*100).toFixed(3)}%</strong> of numbers ≤ N are prime (π(N) = ${esc(pcountAll)}).</div>
    <details><summary>Explain: prime density</summary>
      <div>Prime density is the proportion of integers ≤ N that are prime; by the Prime Number Theorem it is ≈ 1/ln N for large N.</div>
    </details>

    <div class="row"><strong>${approx.toFixed(3)}</strong> is Gauss's N/log N; the error π(N) − N/log N is <strong>${approxErr.toFixed(3)}</strong>.</div>
    <details><summary>Explain: Gauss approximation</summary>
      <div><strong>Gauss conjectured</strong> (and later mathematicians rigorously proved) that <span class="code">π(N) ~ N/log N</span>. Li(N) improves the estimate, but N/log N is a simple baseline.</div>
    </details>
  </section>

  <section class="card sec">
    <h2>Patterns &amp; counts (in range [${esc(A)}, ${esc(N)}])</h2>
    <div class="row"><strong>${esc(twinCount)}</strong> twin prime pairs up to N. Examples inside the range:${twinPairs.length?`<div class="flow">${twinPairs.map(s=>`<span class="badge mono">${esc(s)}</span>`).join('')}</div>`:' <em>none shown</em>'}</div>
    <details><summary>Explain: twin primes</summary>
      <div>Pairs of primes differing by 2. It remains open whether infinitely many exist.</div>
    </details>

    <div class="row"><strong>${esc(semiCount)}</strong> semiprimes (Ω(n)=2) in [${esc(A)}, ${esc(N)}].</div>
    <details><summary>Explain: semiprimes</summary>
      <div>Semiprimes have exactly two prime factors counted with multiplicity (e.g., 6=2×3, 9=3×3).</div>
    </details>

    <div class="row"><strong>${esc(maxGap)}</strong> is the maximum prime gap ≤ N; it occurs at <strong class="mono">${esc(maxGapAt)}</strong>. The average gap is <strong>${avgGap.toFixed(3)}</strong>.</div>
    <details><summary>Explain: prime gaps</summary>
      <div>Gaps are differences between consecutive primes. Heuristics suggest the average gap near N is about ln N; record gaps grow faster.</div>
    </details>

    <div class="row"><strong>Last digits</strong> in range (≥ 7): 1→${esc(lastDigit[1])}, 3→${esc(lastDigit[3])}, 7→${esc(lastDigit[7])}, 9→${esc(lastDigit[9])}.</div>
    <div class="row"><strong>mod 6 residues</strong> in range (p ≥ 5): ≡1 → ${esc(mod6_1)}, ≡5 → ${esc(mod6_5)}.</div>
    <details><summary>Explain: residues</summary>
      <div>Except 2 and 5, base-10 primes end with 1, 3, 7, or 9. For p ≥ 5, primes are ≡ ±1 (mod 6) since they’re not divisible by 2 or 3.</div>
    </details>

    <div class="row"><strong>Checksums (range):</strong> sum(primes) mod 1e9+7 = <strong>${esc(sumMod1e9p7)}</strong>, XOR = <strong>${esc(xor)}</strong>.</div>
    <details><summary>Explain: checksums</summary>
      <div>
        Two fast, order-independent fingerprints for the primes in the selected interval. Good for confirming another run produced the same set (not cryptographic).
        <br><br>
        <strong>Modular sum:</strong> <code>S = (∑ p) mod 1,000,000,007</code>. Overflow-safe and order-independent; collisions unlikely for random differences (~1/M).<br>
        <strong>Bitwise XOR:</strong> <code>X = p₁ ⊕ p₂ ⊕ ··· ⊕ p_k</code>. Order-independent; changing one element flips bits (and <code>a ⊕ a = 0</code> cancels duplicates).
      </div>
    </details>
  </section>

  <section class="card sec">
    <h2>All primes in [${esc(A)}, ${esc(N)}]</h2>
    <div class="code">${esc(primes.join(', '))}</div>
  </section>
</main>
</body>
</html>`;
    return html;
  }

  function downloadPrimesHTML(){
    const html = buildPrimesReportHTML();
    const blob = new Blob([html],{type:'text/html'});
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a');
    a.href=url; a.download=`primes_report_[${A}_${N}].html`;
    a.click();
    URL.revokeObjectURL(url);
  }

  // ===== Tests =====
  function logResult(container, name, ok, extra=''){
    const div=document.createElement('div');
    div.innerHTML=`<strong>${name}:</strong> <span class="${ok?'pass':'fail'}">${ok?'PASS':'FAIL'}</span> ${extra?`<span class="muted">${extra}</span>`:''}`;
    container.appendChild(div);
  }

  async function runUITestPiMatches(M){
    const prevN = maxNInput.value, prevA = startNInput.value;
    startNInput.value='1'; maxNInput.value=String(M);
    resetState(); while(base*base<=N) step(); finalizePrimes();
    const uiPi=parseInt(statPi.textContent,10); const expected=sieveCount(M);
    startNInput.value=prevA; maxNInput.value=prevN; resetState();
    return {ok:uiPi===expected, uiPi, expected};
  }

  async function runTests(){
    const out=$('#testResults'); out.innerHTML='';

    // Original tests (default A=1)
    startNInput.value='1'; maxNInput.value='40'; colsInput.value='10';
    resetState();
    logResult(out,'Grid builds cells = N-A+1', gridEl.children.length=== (N-A+1), `cells=${gridEl.children.length}`);
    logResult(out,'Reference π(30)=10', sieveCount(30)===10, `got ${sieveCount(30)}`);
    logResult(out,'Reference π(100)=25', sieveCount(100)===25, `got ${sieveCount(100)}`);

    for(const M of [50,200,997,1000]){
      const {ok,uiPi,expected}=await runUITestPiMatches(M);
      logResult(out,`UI π(${M}) matches (A=1)`,ok,`(ui=${uiPi}, ref=${expected})`);
    }

    // Interval test
    startNInput.value='1000'; maxNInput.value='1020'; resetState();
    const expectedCount = [1009,1013,1019].length; // primes in [1000,1020]
    const uiRangeCount = [...gridEl.children].filter(c=>c.classList.contains('prime')).length;
    logResult(out,'Range [1000,1020] shows only 3 primes', uiRangeCount===expectedCount, `(ui=${uiRangeCount})`);

    // Base advances
    startNInput.value='1'; maxNInput.value='40'; resetState();
    let guard=0; while(base===2 && guard++<N){ step(); }
    const after2 = base; guard=0; while(base===3 && guard++<N){ step(); }
    const after3 = base;
    logResult(out,'Sieve advances base 2→3', after2===3, `base now ${after2}`);
    logResult(out,'Sieve advances base 3→5', after3===5, `base now ${after3}`);

    // Semiprime detector sanity
    startNInput.value='1'; maxNInput.value='40'; resetState();
    const semiOk = isSemiPrime[4] && isSemiPrime[6] && isSemiPrime[9] && isSemiPrime[10] && isSemiPrime[14] && !isSemiPrime[8] && !isSemiPrime[12];
    logResult(out,'Semiprime detector sanity', semiOk);

    // Fit mode basic check in a range
    startNInput.value='1000'; maxNInput.value='1100'; resetState();
    const toggle=$('#fitGrid'); if(toggle){ toggle.checked=true; buildGrid(); }
    const style = getComputedStyle(gridEl);
    const colsCount = style.gridTemplateColumns.split(' ').length;
    const cellPx = parseFloat(style.gridAutoRows);
    const layoutOk = colsCount>0 && cellPx>=4;
    logResult(out,'Fit mode works in range', layoutOk, `(cols=${colsCount}, cell=${cellPx}px)`);

    // Report: primes only (interval)
    try{
      startNInput.value='1'; maxNInput.value='30'; resetState();
      const html = buildPrimesReportHTML();
      const expected = [2,3,5,7,11,13,17,19,23,29].join(', ');
      logResult(out,'Report lists only primes (A=1)', html.includes(expected));
      startNInput.value='1000'; maxNInput.value='1020'; resetState();
      const html2 = buildPrimesReportHTML();
      const expected2 = [1009,1013,1019].join(', ');
      logResult(out,'Report lists only primes in range', html2.includes(expected2));
    }catch(e){ logResult(out,'Report builds', false, e.message); }

    // Progress reaches 100% after Finish (async)
    startNInput.value='1'; maxNInput.value='200'; resetState();
    await finishAll();
    const width = parseFloat(getComputedStyle(progressFill).width);
    const parentWidth = parseFloat(getComputedStyle(progressFill.parentElement).width);
    logResult(out,'Progress completes after Finish', width/parentWidth > 0.98);
  }

  // === Wire events ===
  btnInit.addEventListener('click', ()=>{ isPlaying=false; resetState(); });
  btnStep.addEventListener('click', step);
  btnPlay.addEventListener('click', playLoop);
  btnPause.addEventListener('click', ()=>{ isPlaying=false; updateButtons(); });
  btnFinish.addEventListener('click', ()=>{ finishAll(); });
  btnDownloadHtml.addEventListener('click', downloadPrimesHTML);
  btnRunTests.addEventListener('click', ()=>runTests());

  (function(){ const t=$('#fitGrid'); if(t){ t.addEventListener('change', ()=>{ buildGrid(); }); } })();
  window.addEventListener('resize', ()=>{ const t=$('#fitGrid'); if(t && t.checked) applyGridLayout(); });
  (function(){ const hsEl=$('#highlightSemi'); if(hsEl){ hsEl.addEventListener('change', paintGrid); } })();

  startNInput.addEventListener('change', ()=>{ isPlaying=false; resetState(); });
  maxNInput.addEventListener('change', ()=>{ isPlaying=false; resetState(); });
  colsInput.addEventListener('change', ()=>{ cols=clamp(parseInt(colsInput.value||10),5,100); const t=$('#fitGrid'); if(!(t && t.checked)) buildGrid(); else applyGridLayout(); });

  // === Init ===
  resetState();
  </script>
</body>
</html>
