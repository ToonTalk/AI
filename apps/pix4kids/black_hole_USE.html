
<!DOCTYPE html>
<html>
<head>
<title>Emoji Follow Cursor with Final Emoji Selection</title>
<style>
    body {
        cursor: none; /* Hide the default cursor */
    }
    .emoji {
        position: fixed;
        pointer-events: none; /* Ignore mouse events on emojis */
        transition: font-size 0.5s; /* Smooth transition for size change */
    }
    #microphoneButton {
        position: fixed;
        bottom: 20px;
        right: 20px;
        font-size: 40px;
        cursor: pointer;
    }
    #helpButton {
        font-size: 40px; /* Adjust size as needed */
        cursor: pointer;
        /* Additional styling as needed */
    }
</style>
</head>
<body>

<div id="microphoneButton">üé§</div>
<div id="helpButton">‚ùì</div> <!-- Big question mark button -->

<script src='emoji_dict.js'></script>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/universal-sentence-encoder"></script>

<script>
let useModel;

let emojiDescriptions = []; // Array to store emoji descriptions
let emojiDescriptionsEmbeddings; // Variable to store precomputed embeddings

async function loadUSEModel() {
    useModel = await use.load();
    console.log("USE Model loaded");

    // Populate emojiDescriptions array from emojiDict
    emojiDescriptions = Object.keys(emojiDict);

    // Compute and store embeddings for all emoji descriptions
    emojiDescriptionsEmbeddings = await useModel.embed(emojiDescriptions);
    onUSEModelLoaded();
}

function speak(text) {
    const msg = new SpeechSynthesisUtterance(text);
    // You can experiment with different voices to find one that's child-friendly
    const voices = window.speechSynthesis.getVoices();
    msg.voice = voices.find(voice => voice.lang === 'en-US'); // Example: English voice
    window.speechSynthesis.speak(msg);
}

function onUSEModelLoaded() {
    speak("I can now understand almost anything you say.");

    // Check if the microphone is not active and inform the user to click the microphone icon
    if (!listening) { 
        speak("Click on the picture of the microphone to talk.");
    }
}

async function findClosestEmojiDescription(userInput) {
    const userInputEmbedding = await useModel.embed([userInput]);
    let highestSimilarity = -1;
    let closestEmoji = null;

    // Convert embeddings to array once to avoid repeated conversions
    const userInputArray = userInputEmbedding.arraySync()[0];
    userInputEmbedding.dispose(); // Dispose of the userInputEmbedding tensor
    const emojiEmbeddingsArray = emojiDescriptionsEmbeddings.arraySync();

    // Calculate similarity with each emoji description
    for (let i = 0; i < emojiDescriptions.length; i++) {
        const similarity = cosineSimilarity(userInputArray, emojiEmbeddingsArray[i]);

        if (similarity > highestSimilarity) {
            highestSimilarity = similarity;
            closestEmoji = emojiDescriptions[i];
        }
    }

    return closestEmoji;
}

// Load the model and embeddings when the page loads
window.onload = loadUSEModel;

// Cosine similarity function
function cosineSimilarity(a, b) {
    let dotProduct = 0;
    let mA = 0;
    let mB = 0;
    for (let i = 0; i < a.length; i++) {
        dotProduct += (a[i] * b[i]);
        mA += (a[i] * a[i]);
        mB += (b[i] * b[i]);
    }
    mA = Math.sqrt(mA);
    mB = Math.sqrt(mB);
    const similarity = (dotProduct) / ((mA) * (mB));
    return similarity;
}

// Load the model when the page loads
window.onload = loadUSEModel;

let emojiSize = 30;
let currentEmoji = "";
let mouseDown = false;
let listening = false;
const recognition = new webkitSpeechRecognition();
recognition.continuous = true;
recognition.lang = 'en-US';
recognition.interimResults = true;
recognition.maxAlternatives = 1;

function createEmojiElement(x, y, emoji) {
    let emojiElement = document.createElement('div');
    emojiElement.classList.add('emoji');
    emojiElement.textContent = emoji || currentEmoji || Object.values(emojiDict)[Math.floor(Math.random() * Object.values(emojiDict).length)];
    emojiElement.style.left = x + 'px';
    emojiElement.style.top = y + 'px';
    emojiElement.style.fontSize = emojiSize + 'px';
    emojiElement.velocity = { x: 0, y: 0 };
    document.body.appendChild(emojiElement);
    return emojiElement;
}

function showFeedbackEmoji(emoji) {
    let feedbackEmoji = document.createElement('div');
    feedbackEmoji.textContent = emoji;
    feedbackEmoji.style.position = 'fixed';
    feedbackEmoji.style.left = '50%';
    feedbackEmoji.style.top = '50%';
    feedbackEmoji.style.transform = 'translate(-50%, -50%)';
    feedbackEmoji.style.fontSize = '100px';
    feedbackEmoji.style.zIndex = '1000';
    document.body.appendChild(feedbackEmoji);
    setTimeout(() => feedbackEmoji.remove(), 1000); // Remove after 1 second
}

function showBlackHoleBriefly() {
    if (!blackHoleActive) return;
    blackHole.style.display = 'block';
    setTimeout(() => {
        blackHole.style.display = 'none';
    }, 1000);  // Show for 1 second
}

document.addEventListener('mousemove', function(e) {
    if (mouseDown && !blackHoleActive) {  // Check if the black hole is not active
        createEmojiElement(e.clientX, e.clientY);
    }
});

document.addEventListener('mousedown', function() {
    mouseDown = true;
});

document.addEventListener('mouseup', function() {
    mouseDown = false;
});

document.addEventListener('touchmove', function(e) {
    e.preventDefault();
    if (!blackHoleActive) {  // Check if the black hole is not active
        let touch = e.touches[0];
        createEmojiElement(touch.clientX, touch.clientY);
    }
});

document.addEventListener('touchstart', function() {
    mouseDown = true;
});

document.addEventListener('touchend', function() {
    mouseDown = false;
});

const microphoneButton = document.getElementById('microphoneButton');
microphoneButton.addEventListener('click', function(event) {
    event.stopPropagation(); // Prevent click from propagating to parent elements
    if (!listening) {
        recognition.start();
        listening = true;
        microphoneButton.textContent = 'üõë'; // Emoji for the microphone 'on'
    } else {
        recognition.stop();
        listening = false;
        microphoneButton.textContent = 'üé§'; // Emoji for the microphone 'off'
    }
});

recognition.onresult = function(event) {
    for (let i = event.resultIndex; i < event.results.length; ++i) {
        if (event.results[i].isFinal) {
            const command = event.results[i][0].transcript.trim().toLowerCase();
            
            // Skip processing if the command is an empty string
            if (!command) {
                continue; // Skip to the next loop iteration
            }
            
            console.log("Spoken:", command);

            // Store the original state of blackHoleActive and set it to false by default
            const originalBlackHoleActive = blackHoleActive;
            blackHoleActive = false;
        
            if (command.includes('black hole')) {
                blackHoleActive = true;
                showBlackHoleBriefly();
            } else if (command.includes('random')) {
                currentEmoji = "";
            } else if (command.includes('bigger')) {
                emojiSize += 10;
            } else if (command.includes('smaller')) {
                emojiSize -= 10;
            } else if (emojiDict[command]) {
                currentEmoji = emojiDict[command];
                showFeedbackEmoji(currentEmoji);
            } else if (useModel) {
                // If USE model is loaded and no exact match is found
                findClosestEmojiDescription(command).then(closestEmojiDescription => {
                    if (closestEmojiDescription && emojiDict[closestEmojiDescription]) {
                        currentEmoji = emojiDict[closestEmojiDescription];
                        showFeedbackEmoji(currentEmoji);
                        console.log("->", closestEmojiDescription);
                    } else {
                        // Restore the original state if no specific command is recognized
                        blackHoleActive = originalBlackHoleActive;
                    }
                });
            } else {
                // Restore the original state if no specific command is recognized
                blackHoleActive = originalBlackHoleActive;
            }
        }
    }

    // Update the display of the black hole based on its active state
    blackHole.style.display = blackHoleActive ? 'block' : 'none';
};

recognition.onend = function() {
    console.log("Speech recognition service disconnected");
    if (listening) { // Assuming 'listening' is a flag indicating whether recognition should be active
        recognition.start();
    }
};

recognition.onerror = function(event) {
    console.error("Speech recognition error", event.error);
    // Optionally restart recognition or handle differently based on the error
};

document.addEventListener('click', function(e) {
    createEmojiElement(e.clientX, e.clientY);
});

document.addEventListener('touchstart', function(e) {
    if (!e.touches.length) return;
    let touch = e.touches[0];
    createEmojiElement(touch.clientX, touch.clientY);
});

function createBlackHole() {
    let blackHole = document.createElement('div');
    blackHole.id = 'blackHole';
    blackHole.style.width = '50px';
    blackHole.style.height = '50px';
    blackHole.style.borderRadius = '50%';
    blackHole.style.backgroundColor = 'black';
    blackHole.style.position = 'fixed';
    blackHole.style.display = 'none'; // Initially hidden
    document.body.appendChild(blackHole);
    return blackHole;
}

let blackHole = createBlackHole();
let blackHoleActive = false;

// Function to move the black hole
function moveBlackHole(x, y) {
    blackHole.style.left = x + 'px';
    blackHole.style.top = y + 'px';
    blackHole.style.display = 'block';
}

// Event listeners for mouse and touch movement
document.addEventListener('mousemove', function(e) {
    if (blackHoleActive) {
        moveBlackHole(e.clientX, e.clientY);
    }
});

document.addEventListener('touchmove', function(e) {
    if (blackHoleActive && e.touches.length) {
        let touch = e.touches[0];
        moveBlackHole(touch.clientX, touch.clientY);
    }
});

let frameCount = 0;
const batchSize = 100; // Number of emojis to update per frame
let isVelocityZero = true; // Flag to track if all velocities are zero

function updateEmojiVelocityAndPosition() {
    const blackHoleRadius = 25;
    const emojis = document.querySelectorAll('.emoji');
    const totalEmojis = emojis.length;

    let start, end;

    if (batchSize >= totalEmojis) {
        // If batchSize is greater than or equal to totalEmojis, update all emojis
        start = 0;
        end = totalEmojis;
    } else {
        // Otherwise, pick a random start and set end so that it doesn't exceed totalEmojis
        start = Math.floor(Math.random() * (totalEmojis - batchSize));
        end = start + batchSize;
    }

    // Skip updating if black hole is inactive and all velocities are zero
    if (!blackHoleActive && isVelocityZero) {
        frameCount++;
        requestAnimationFrame(updateEmojiVelocityAndPosition);
        return;
    }

    isVelocityZero = true; // Reset flag, will be updated in loop

    const blackHoleCenterX = parseInt(blackHole.style.left) + blackHoleRadius; // Center X of black hole
    const blackHoleCenterY = parseInt(blackHole.style.top) + blackHoleRadius;  // Center Y of black hole
    
    for (let i = start; i < end; i++) {
        const emoji = emojis[i];
        const emojiCenterX = emoji.offsetLeft + emoji.offsetWidth / 2;
        const emojiCenterY = emoji.offsetTop + emoji.offsetHeight / 2;
    
        let dx = blackHoleCenterX - emojiCenterX;
        let dy = blackHoleCenterY - emojiCenterY;
        let distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < blackHoleRadius) {
            emoji.remove();
            continue; // Skip the rest of the loop for this emoji
        }
        if (blackHoleActive && distance > 0) {
            // Update velocity
            let strength = 1000 / (distance * distance);
            emoji.velocity.x += strength * dx / distance;
            emoji.velocity.y += strength * dy / distance;
            isVelocityZero = false; // Velocities are being updated
        } else {
            emoji.velocity = { x: 0, y: 0 };
        }

        emoji.style.left = (emoji.offsetLeft + emoji.velocity.x) + 'px';
        emoji.style.top = (emoji.offsetTop + emoji.velocity.y) + 'px';
    }

    frameCount++;
    requestAnimationFrame(updateEmojiVelocityAndPosition);
}

// Start the animation loop
updateEmojiVelocityAndPosition();

document.getElementById('helpButton').addEventListener('click', function() {
    event.stopPropagation(); // Prevent click from propagating to parent elements
    const commandsInfo = "Here are some things you can say: " +
                         "'Black hole' to create a black hole. " +
                         "'Bigger' or 'smaller' to change the size of the emojis. " +
                         "'Random' to change emojis to random ones. " +
                         "You can also say any emoji description.";

    speak(commandsInfo);
});

</script>

</body>
</html>
